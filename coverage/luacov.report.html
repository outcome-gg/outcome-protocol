<!doctype html>
<html lang="en">
<head>
   <meta charset="utf-8" />
   <title>Code coverage report</title>
   <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/>
   <link rel="shortcut icon" type="image/png" sizes="16x16" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAFo9M/3AAAACXBIWXMAAADsAAAA7AF5KHG9AAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAYBJREFUOI2tkjtLA0EUhb+JjxQ+qhGtBAtbG0GJFj5rsfQXWKUUQau7QoRIUFBRyG8QBNuABhFNoY12dopso43iM2iuxe7ETXwQxQMLM3funnPumYFKiJaXJtiZyfJRJnOo4I0ZAOujAKc9fAlvDkStXSoAxEAXAW5uHvsdYZ/1Ud+iIqImYiIGTEBTDh4SQA7ExCIO34Bt1Zn7dHo8B03NoeGgwfpS5nL2skmhLCESmfOPWOgFb+TDk9yGc7pC6bilpWF3eflIId4FtDn1rfAP9by8qqqCPDpeA/IMxD9LinESqyJgfcH6ggj4VvBtcCMxkNmfrBv4PgMRMXW1RQCwGof+HRjehJEXyBcA6qs4p4A00BkpPgEbcLcGJIBW0FFgJdKzkAApubjcl0rtq0OQr2SqfYUjDJ0AzdWHhcIVr68lDg4uSaX2KRbfBmA0D3sXrse9pnOgW6T2RCAIMcygcRCKZ0D7+vRnlmRWmF6vrGeTwT58S/PXIB2/0/8nvAPwp5kuNmMrGQAAAABJRU5ErkJggg==" />

   <style>
      @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono&display=swap');
      
      html {
          height: 100%;
      }
      
      body {
          position: relative;
          margin: 0;
          font-family: 'Roboto Mono', monospace;
          display: flex;
          flex-direction: column;
          min-height: 100%;
      }
      
      main {
          flex: 1 0 auto;
      }
      
      footer {
          flex-shrink: 0;
          font-size: 12px;
          color: #808080;
          width: 100%;
          height: 30px;
          line-height: 30px;
          text-align: center;
      }
      
      .pln {
          color: #000
      }
      
      @media screen {
          .str {
              color: #080
          }
      
          .kwd {
              color: #008
          }
      
          .com {
              color: #800
          }
      
          .typ {
              color: #606
          }
      
          .lit {
              color: #066
          }
      
          .clo, .opn, .pun {
              color: #660
          }
      
          .tag {
              color: #008
          }
      
          .atn {
              color: #606
          }
      
          .atv {
              color: #080
          }
      
          .dec, .var {
              color: #606
          }
      
          .fun {
              color: red
          }
      }
      
      @media print, projection {
          .kwd, .tag, .typ {
              font-weight: 700
          }
      
          .str {
              color: #060
          }
      
          .kwd {
              color: #006
          }
      
          .com {
              color: #600;
              font-style: italic
          }
      
          .typ {
              color: #404
          }
      
          .lit {
              color: #044
          }
      
          .clo, .opn, .pun {
              color: #440
          }
      
          .tag {
              color: #006
          }
      
          .atn {
              color: #404
          }
      
          .atv {
              color: #060
          }
      }
      
      pre.prettyprint {
          padding: 0;
          margin: 0;
          border: 0;
          border-bottom: 1px solid #808080;
      }
      
      .file.hidden pre.prettyprint {
          display: none;
      }
      
      ol.linenums {
          margin-top: 0;
          margin-bottom: 0;
          counter-reset: number;
          list-style-type: none;
      }
      
      pre.prettyprint ol {
          margin: 0;
          padding: 0;
      }
      
      pre.prettyprint li {
          font-size: 14px;
          word-wrap: normal;
          white-space: pre;
          line-height: 20px;
      }
      
      pre.prettyprint li::before {
          counter-increment: number;
          content: counter(number) "\a0";
          float: left;
          position: relative;
          width: 1%;
          min-width: 50px;
          padding-right: 10px;
          padding-left: 10px;
          font-size: 12px;
          color: #6E7781;
          text-align: right;
          white-space: nowrap;
          vertical-align: top;
          line-height: 20px;
      }
      
      pre.prettyprint span.fc {
          background-color: #DFF0D8;
          display: block;
      }
      
      pre.prettyprint span.fc:before {
          content: attr(data-hits);
          position: absolute;
          left: 0;
          width: 30px;
          margin-left: 5px;
          text-align: center;
          font-size: 10px;
          color: #808080;
      }
      
      pre.prettyprint span.nc {
          background-color: #F2DEDE;
          display: block;
      }
      
      pre.prettyprint span.pc {
          background-color: #FFFFCC;
          display: block;
      }
      
      pre.prettyprint span.bpc:hover {
          background-color: #FFFF80;
      }
      
      pre.prettyprint span.hits {
          position: absolute;
          left: 0;
          width: 30px;
          margin-left: 5px;
          text-align: center;
          font-size: 10px;
      }
      
      
      .file .title {
          border-bottom: 1px solid #808080;
          border-left: 0;
          border-right: 0;
          padding: 0.67em;
          margin: 0;
          position: relative;
      }
      
      .file:not(.total) .title {
          cursor: pointer;
      }
      
      .file:not(.total) .title:before {
          content: "";
          display: block;
          width: 100%;
          height: 100%;
          position: absolute;
          left: 0;
          right: 0;
          bottom: 0;
          top: 0;
          background: #fff;
          opacity: 0.0;
          transition: all 200ms;
      }
      
      .file:not(.total) .title:not(.total):hover:before {
          opacity: 0.3;
      }
      
      .file.danger .title {
          background: #F2DEDE;
      }
      
      .file.warning .title {
          background: #FCF8E3;
      }
      
      .file.success-low .title {
          background: #DFF0D8;
      }
      
      .file.success-medium .title {
          background: #C3E3B5;
      }
      
      .file.success-high .title {
          background: #99CB84;
      }
      
      .file .title .stats {
          font-size: 12px;
          line-height: 12px;
          color: #444;
          margin-top: 2px;
          display: flex;
      }
      
      .file .title .stats .hits,
      .file .title .stats .cov,
      .file .title .stats .miss {
          padding: 2px 6px;
          border-radius: 12px;
          border: 1px solid #808080;
          position: relative;
          margin-right: 10px;
      }
      
      .file .title .stats .hits {
          background: #DFF0D8;
      }
      
      .file .title .stats .cov {
          background: #F2DEDE;
          overflow: hidden;
      }
      
      .file .title .stats .cov span {
          position: relative;
      }
      
      .file .title .stats .cov .bg {
          height: 100%;
          position: absolute;
          left: 0;
          top: 0;
          background-color: #DFF0D8;
      }
      
      .file .title .stats .miss {
          background: #F2DEDE;
      }
      
   </style>

</head>
<body onload="initialize()">
   <main>
      <div class="file success-medium total">
         <h1 class="title">
            Code coverage report
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 75.47%"></span>
                  <span><strong>75.47%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>1311</strong> Hits</span>
               <span class="miss"><strong>426</strong> Missed</span>
            </span>
         </h1>
      </div>

      <div class="hidden file success-low" id="src-configurator">
         <h2 class="title">
            src/configurator.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 74.65%"></span>
                  <span><strong>74.65%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>53</strong> Hits</span>
               <span class="miss"><strong>18</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums">--[[
======================================================================================
Outcome © 2025. All Rights Reserved.
======================================================================================
This code is proprietary and owned by Outcome.

You are permitted to build applications, integrations, and extensions that interact
with the Outcome Protocol, provided such usage adheres to the official Outcome
terms of service and does not result in unauthorized forks or clones of this codebase.

Redistribution, modification, or unauthorized use of this code is strictly prohibited
without explicit written permission from Outcome.
======================================================================================
]]

<span class="fc" data-hits="1">local json = require(&#39;json&#39;)</span>
<span class="fc" data-hits="1">local configurator = require(&#39;configuratorModules.configurator&#39;)</span>
<span class="fc" data-hits="1">local configuratorValidation = require(&#39;configuratorModules.configuratorValidation&#39;)</span>

--[[
============
CONFIGURATOR
============
]]

<span class="fc" data-hits="1">Env = &#39;DEV&#39;</span>
<span class="fc" data-hits="1">Admin = Admin or &#39;XkVOo16KMIHK-zqlR67cuNY0ayXIkPWODWw_HXAE20I&#39;</span>
-- @dev Reset state on load while in DEV mode
<span class="fc" data-hits="1">if not Configurator or Env == &#39;DEV&#39; then Configurator = configurator.new(Admin, Env) end</span>

--[[
============
INFO HANDLER
============
]]

--- Info handler
--- @param msg Message The message received
--- @return Message The reply message
<span class="fc" data-hits="2">Handlers.add(&quot;Info&quot;, {Action = &quot;Info&quot;}, function(msg)</span>
<span class="fc" data-hits="2">  return msg.reply({</span>
<span class="fc" data-hits="1">    Admin = Configurator.admin,</span>
<span class="fc" data-hits="1">    Delay = tostring(Configurator.delay),</span>
<span class="fc" data-hits="1">    Staged = json.encode(Configurator.staged)</span>
  })
end)

--[[
=====================
UPDATE WRITE HANDLERS
=====================
]]
--- Stage update handler
--- @param msg Message The message received, expected to contain:
---  - msg.Tags.UpdateProcess string The update process
---  - msg.Tags.UpdateAction string The update action
---  - msg.Tags.UpdateTags? string|nil The update tags or `nil`
---  - msg.Tags.UpdateData? string|nil The update data or `nil`
--- @return Message The reply message
<span class="fc" data-hits="2">Handlers.add(&quot;Stage-Update&quot;, {Action = &quot;Stage-Update&quot;}, function(msg)</span>
  -- Validate input
<span class="fc" data-hits="3">  local success, err = configuratorValidation.updateProcess(msg)</span>
  -- If validation fails, provide error response.
<span class="fc" data-hits="3">  if not success then</span>
<span class="nc">    return msg.reply({</span>
      Action = &quot;Stage-Update-Error&quot;,
<span class="nc">      Error = err</span>
    })
  end
  -- If validation passes, stage the update.
<span class="fc" data-hits="3">  local updateTags = msg.Tags.UpdateTags or &quot;&quot;</span>
<span class="fc" data-hits="3">  local updateData = msg.Tags.UpdateData or &quot;&quot;</span>
<span class="fc" data-hits="3">  return Configurator:stageUpdate(msg.Tags.UpdateProcess, msg.Tags.UpdateAction, updateTags, updateData, msg)</span>
end)

--- Unstage update handler
--- @param msg Message The message received, expected to contain:
---  - msg.Tags.UpdateProcess string The update process
---  - msg.Tags.UpdateAction string The update action
---  - msg.Tags.UpdateTags? string|nil The update tags or `nil`
---  - msg.Tags.UpdateData? string|nil The update data or `nil`
--- @return Message The reply message
<span class="fc" data-hits="2">Handlers.add(&quot;Unstage-Update&quot;, {Action = &quot;Unstage-Update&quot;}, function(msg)</span>
  -- Validate input
<span class="fc" data-hits="1">  local success, err = configuratorValidation.updateProcess(msg)</span>
  -- If validation fails, provide error response.
<span class="fc" data-hits="1">  if not success then</span>
<span class="nc">    return msg.reply({</span>
      Action = &quot;Unstage-Update-Error&quot;,
<span class="nc">      Error = err</span>
    })
  end
  -- If validation passes, unstage the update.
<span class="fc" data-hits="1">  local updateTags = msg.Tags.UpdateTags or &quot;&quot;</span>
<span class="fc" data-hits="1">  local updateData = msg.Tags.UpdateData or &quot;&quot;</span>
<span class="fc" data-hits="1">  return Configurator:unstageUpdate(msg.Tags.UpdateProcess, msg.Tags.UpdateAction, updateTags, updateData, msg)</span>
end)

--- Action update handler
--- @param msg Message The message received, expected to contain:
---  - msg.Tags.UpdateProcess string The update process
---  - msg.Tags.UpdateAction string The update action
---  - msg.Tags.UpdateTags? string|nil The update tags or `nil`
---  - msg.Tags.UpdateData? string|nil The update data or `nil`
--- @return Message The reply message
<span class="fc" data-hits="2">Handlers.add(&quot;Action-Update&quot;, {Action = &quot;Action-Update&quot;}, function(msg)</span>
  -- Validate input
<span class="fc" data-hits="1">  local success, err = configuratorValidation.updateProcess(msg)</span>
  -- If validation fails, provide error response.
<span class="fc" data-hits="1">  if not success then</span>
<span class="nc">    return msg.reply({</span>
      Action = &quot;Action-Update-Error&quot;,
<span class="nc">      Error = err</span>
    })
  end
  -- If validation passes, action the update.
<span class="fc" data-hits="1">  local updateTags = msg.Tags.UpdateTags or &quot;&quot;</span>
<span class="fc" data-hits="1">  local updateData = msg.Tags.UpdateData or &quot;&quot;</span>
<span class="fc" data-hits="1">  return Configurator:actionUpdate(msg.Tags.UpdateProcess, msg.Tags.UpdateAction, updateTags, updateData, msg)</span>
end)

--[[
===========================
UPDATE ADMIN WRITE HANDLERS
===========================
]]

--- Stage update admin handler
--- @param msg Message The message received, expected to contain:
---  - msg.Tags.UpdateAdmin string The new admin address
--- @return Message The reply message
<span class="fc" data-hits="2">Handlers.add(&quot;Stage-Update-Admin&quot;, {Action = &quot;Stage-Update-Admin&quot;}, function(msg)</span>
  -- Validate input
<span class="fc" data-hits="3">  local success, err = configuratorValidation.updateAdmin(msg)</span>
  -- If validation fails, provide error response.
<span class="fc" data-hits="3">  if not success then</span>
<span class="nc">    return msg.reply({</span>
      Action = &quot;Stage-Update-Admin-Error&quot;,
<span class="nc">      Error = err</span>
    })
  end
  -- If validation passes, stage the update admin.
<span class="fc" data-hits="3">  return Configurator:stageUpdateAdmin(msg.Tags.UpdateAdmin, msg)</span>
end)

--- Unstage update admin handler
--- @param msg Message The message received, expected to contain:
---  - msg.Tags.UpdateAdmin string The new admin address
--- @return Message The reply message
<span class="fc" data-hits="2">Handlers.add(&quot;Unstage-Update-Admin&quot;, {Action = &quot;Unstage-Update-Admin&quot;}, function(msg)</span>
  -- Validate input
<span class="fc" data-hits="1">  local success, err = configuratorValidation.updateAdmin(msg)</span>
  -- If validation fails, provide error response.
<span class="fc" data-hits="1">  if not success then</span>
<span class="nc">    return msg.reply({</span>
      Action = &quot;Unstage-Update-Admin-Error&quot;,
<span class="nc">      Error = err</span>
    })
  end
  -- If validation passes, unstage the update admin.
<span class="fc" data-hits="1">  return Configurator:unstageUpdateAdmin(msg.Tags.UpdateAdmin, msg)</span>
end)

--- Action update admin handler
--- @param msg Message The message received, expected to contain:
---  - msg.Tags.UpdateAdmin string The new admin address
--- @return Message The reply message
<span class="fc" data-hits="2">Handlers.add(&quot;Action-Update-Admin&quot;, {Action = &quot;Action-Update-Admin&quot;}, function(msg)</span>
  -- Validate input
<span class="fc" data-hits="1">  local success, err = configuratorValidation.updateAdmin(msg)</span>
  -- If validation fails, provide error response.
<span class="fc" data-hits="1">  if not success then</span>
<span class="nc">    return msg.reply({</span>
      Action = &quot;Action-Update-Admin-Error&quot;,
<span class="nc">      Error = err</span>
    })
  end
  -- If validation passes, action the update admin.
<span class="fc" data-hits="1">  return Configurator:actionUpdateAdmin(msg.Tags.UpdateAdmin, msg)</span>
end)

--[[
===========================
UPDATE DELAY WRITE HANDLERS
===========================
]]

--- Stage update delay handler
--- @param msg Message The message received, expected to contain:
---  - msg.Tags.UpdateDelay string The updated delay time in seconds
--- @return Message The reply message
<span class="fc" data-hits="2">Handlers.add(&quot;Stage-Update-Delay&quot;, {Action = &quot;Stage-Update-Delay&quot;}, function(msg)</span>
  -- Validate input
<span class="fc" data-hits="3">  local success, err = configuratorValidation.updateDelay(msg)</span>
  -- If validation fails, provide error response.
<span class="fc" data-hits="3">  if not success then</span>
<span class="nc">    return msg.reply({</span>
      Action = &quot;Stage-Update-Delay-Error&quot;,
<span class="nc">      Error = err</span>
    })
  end
  -- If validation passes, stage the update delay.
<span class="fc" data-hits="3">  return Configurator:stageUpdateDelay(msg.Tags.UpdateDelay, msg)</span>
end)

--- Unstage update delay handler
--- @param msg Message The message received, expected to contain:
---  - msg.Tags.UpdateDelay string The updated delay time in seconds
--- @return Message The reply message
<span class="fc" data-hits="2">Handlers.add(&quot;Unstage-Update-Delay&quot;, {Action = &quot;Unstage-Update-Delay&quot;}, function(msg)</span>
  -- Validate input
<span class="fc" data-hits="1">  local success, err = configuratorValidation.updateDelay(msg)</span>
  -- If validation fails, provide error response.
<span class="fc" data-hits="1">  if not success then</span>
<span class="nc">    return msg.reply({</span>
      Action = &quot;Unstage-Update-Delay-Error&quot;,
<span class="nc">      Error = err</span>
    })
  end
  -- If validation passes, unstage the update delay.
<span class="fc" data-hits="1">  return Configurator:unstageUpdateDelay(msg.Tags.UpdateDelay, msg)</span>
end)

--- Action update delay handler
--- @param msg Message The message received, expected to contain:
---  - msg.Tags.UpdateDelay string The updated delay time in seconds
--- @return Message The reply message
<span class="fc" data-hits="2">Handlers.add(&quot;Action-Update-Delay&quot;, {Action = &quot;Action-Update-Delay&quot;}, function(msg)</span>
  -- Validate input
<span class="fc" data-hits="1">  local success, err = configuratorValidation.updateDelay(msg)</span>
  -- If validation fails, provide error response.
<span class="fc" data-hits="1">  if not success then</span>
<span class="nc">    return msg.reply({</span>
      Action = &quot;Action-Update-Delay-Error&quot;,
<span class="nc">      Error = err</span>
    })
  end
  -- If validation passes, action the update delay.
<span class="fc" data-hits="1">  return Configurator:actionUpdateDelay(msg.Tags.UpdateDelay, msg)</span>
end)
</pre>
      </div>

      <div class="hidden file success-high" id="src-configuratormodules-configurator">
         <h2 class="title">
            src/configuratorModules/configurator.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 100.00%"></span>
                  <span><strong>100.00%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>83</strong> Hits</span>
               <span class="miss"><strong>0</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums">--[[
======================================================================================
Outcome © 2025. All Rights Reserved.
======================================================================================
This code is proprietary and owned by Outcome.

You are permitted to build applications, integrations, and extensions that interact
with the Outcome Protocol, provided such usage adheres to the official Outcome
terms of service and does not result in unauthorized forks or clones of this codebase.

Redistribution, modification, or unauthorized use of this code is strictly prohibited
without explicit written permission from Outcome.
======================================================================================
]]

<span class="fc" data-hits="2">local Configurator = {}</span>
<span class="fc" data-hits="2">local ConfiguratorMethods = {}</span>
<span class="fc" data-hits="2">local ConfiguratorNotices = require(&#39;configuratorModules.configuratorNotices&#39;)</span>
<span class="fc" data-hits="2">local sharedUtils = require(&#39;configuratorModules.sharedUtils&#39;)</span>
<span class="fc" data-hits="2">local json = require(&#39;json&#39;)</span>
<span class="fc" data-hits="2">local crypto = require(&#39;.crypto&#39;)</span>

-- Default Configurator delay
<span class="fc" data-hits="2">ConfiguratorDelay = {</span>
<span class="fc" data-hits="2">  DEV = 3 * 1000,                -- 3 seconds in milliseconds</span>
<span class="fc" data-hits="2">  PROD = 3 * 24 * 60 * 60 * 1000 -- 3 days in milliseconds</span>
<span class="fc" data-hits="2">}</span>

--- Represents a Configurator
--- @class Configurator
--- @field admin string The admin process ID
--- @field delay number The update delay in seconds
--- @field Staged table&lt;string, number&gt; A mapping of update hashes to their staged timestamps

--- Creates a new Constructor instance
--- @param admin string The admin process ID
--- @param env string The environment
--- @return Configurator configurator The new Configurator instance
<span class="fc" data-hits="2">function Configurator.new(admin, env)</span>
<span class="fc" data-hits="19">  assert(type(admin) == &quot;string&quot;, &#39;Admin process ID is required!&#39;)</span>
<span class="fc" data-hits="19">  assert(sharedUtils.isValidArweaveAddress(admin), &#39;Admin must be a valid Arweave address!&#39;)</span>
<span class="fc" data-hits="19">  assert(env == &quot;DEV&quot; or env == &quot;PROD&quot;, &#39;Invalid environment! Must be &quot;DEV&quot; or &quot;PROD&quot;.&#39;)</span>

<span class="fc" data-hits="19">  local configurator = {</span>
<span class="fc" data-hits="19">    admin = admin,</span>
<span class="fc" data-hits="19">    delay = ConfiguratorDelay[env],</span>
<span class="fc" data-hits="19">    staged = {},</span>
  }
<span class="fc" data-hits="38">  setmetatable(configurator, {</span>
    __index = function(_, k)
<span class="fc" data-hits="75">      if ConfiguratorMethods[k] then</span>
<span class="fc" data-hits="42">        return ConfiguratorMethods[k]</span>
<span class="fc" data-hits="33">      elseif ConfiguratorNotices[k] then</span>
<span class="fc" data-hits="33">        return ConfiguratorNotices[k]</span>
      end
    end
  })
<span class="fc" data-hits="19">  return configurator</span>
end

--- Stages an update
--- @param process string The process ID
--- @param action string The action name
--- @param tags string The JSON string of tags
--- @param data string The JSON string of data
--- @param msg Message The message received
--- @return Message The stage update notice
<span class="fc" data-hits="2">function ConfiguratorMethods:stageUpdate(process, action, tags, data, msg)</span>
<span class="fc" data-hits="7">  local hash = crypto.digest.keccak256(process .. action .. tags .. data).asHex()</span>
  -- stage
<span class="fc" data-hits="7">  self.staged[hash] = os.time()</span>
  -- stage notice
<span class="fc" data-hits="7">  return self.stageUpdateNotice(process, action, tags, data, hash, msg)</span>
end

--- Unstages an update
--- @param process string The process ID
--- @param action string The action name
--- @param tags string The JSON string of tags
--- @param data string The JSON string of data
--- @param msg Message The message received
--- @return Message The unstage update notice
<span class="fc" data-hits="2">function ConfiguratorMethods:unstageUpdate(process, action, tags, data, msg)</span>
<span class="fc" data-hits="3">  local hash = crypto.digest.keccak256(process .. action .. tags.. data).asHex()</span>
<span class="fc" data-hits="3">  assert(self.staged[hash], &#39;Update not staged! Hash: &#39; .. hash)</span>
  -- unstage
<span class="fc" data-hits="2">  self.staged[hash] = nil</span>
  -- unstage notice
<span class="fc" data-hits="2">  return self.unstageUpdateNotice(hash, msg)</span>
end

--- Actions an update
--- @param process string The process ID
--- @param action string The action name
--- @param tags string The JSON string of tags
--- @param data string The JSON string of data
--- @param msg Message The message received
--- @return Message The action update notice
<span class="fc" data-hits="2">function ConfiguratorMethods:actionUpdate(process, action, tags, data, msg)</span>
<span class="fc" data-hits="4">  local hash = crypto.digest.keccak256(process .. action .. tags .. data).asHex()</span>
<span class="fc" data-hits="4">  assert(self.staged[hash], &#39;Update not staged! Hash: &#39; .. hash)</span>
<span class="fc" data-hits="3">  local remaining = self.staged[hash] + self.delay - os.time()</span>
<span class="fc" data-hits="3">  assert(remaining &lt;= 0, &#39;Update not staged long enough! Remaining: &#39; .. remaining .. &#39;s.&#39;)</span>
  -- action update
<span class="fc" data-hits="2">  local message = {</span>
<span class="fc" data-hits="2">    Target = process,</span>
<span class="fc" data-hits="2">    Action = action,</span>
<span class="fc" data-hits="2">    Data = data ~= &#39;&#39; and json.decode(data) or nil</span>
  }
<span class="fc" data-hits="2">  if tags ~= &#39;&#39; then</span>
<span class="fc" data-hits="4">    for tagName, tagValue in pairs(json.decode(tags)) do</span>
<span class="fc" data-hits="2">      message[tostring(tagName)] = tostring(tagValue)</span>
    end
  end
<span class="fc" data-hits="2">  ao.send(message)</span>
  -- unstage
<span class="fc" data-hits="2">  self.staged[hash] = nil</span>
  -- action notice
<span class="fc" data-hits="2">  return self.actionUpdateNotice(hash, msg)</span>
end

--- Stages an update for the admin
--- @param updateAdmin string The new admin process ID
--- @param msg Message The message received
--- @return Message The stage update admin notice
<span class="fc" data-hits="2">function ConfiguratorMethods:stageUpdateAdmin(updateAdmin, msg)</span>
<span class="fc" data-hits="7">  local hash = crypto.digest.keccak256(updateAdmin).asHex()</span>
  -- stage
<span class="fc" data-hits="7">  self.staged[hash] = os.time()</span>
  -- stage notice
<span class="fc" data-hits="7">  return self.stageUpdateAdminNotice(updateAdmin, hash, msg)</span>
end

--- Unstages an update for the admin
--- @param updateAdmin string The new admin process ID
--- @param msg string The message received
--- @return Message The unstage update admin notice
<span class="fc" data-hits="2">function ConfiguratorMethods:unstageUpdateAdmin(updateAdmin, msg)</span>
<span class="fc" data-hits="3">  local hash = crypto.digest.keccak256(updateAdmin).asHex()</span>
<span class="fc" data-hits="3">  assert(self.staged[hash], &#39;Update not staged! Hash: &#39; .. hash)</span>
  -- unstage
<span class="fc" data-hits="2">  self.staged[hash] = nil</span>
  -- unstage notice
<span class="fc" data-hits="2">  return self.unstageUpdateAdminNotice(hash, msg)</span>
end

--- Actions an update for the admin
--- @param updateAdmin string The new admin process ID
--- @param msg string The message received
--- @return Message The action update admin notice
<span class="fc" data-hits="2">function ConfiguratorMethods:actionUpdateAdmin(updateAdmin, msg)</span>
<span class="fc" data-hits="4">  local hash = crypto.digest.keccak256(updateAdmin).asHex()</span>
<span class="fc" data-hits="4">  assert(self.staged[hash], &#39;Update not staged! Hash: &#39; .. hash)</span>
<span class="fc" data-hits="3">  local remaining = self.staged[hash] + self.delay - os.time()</span>
<span class="fc" data-hits="3">  assert(remaining &lt;= 0, &#39;Update not staged long enough! Remaining: &#39; .. remaining .. &#39;s.&#39;)</span>
  -- action update
<span class="fc" data-hits="2">  self.admin = updateAdmin</span>
  -- unstage
<span class="fc" data-hits="2">  self.staged[hash] = nil</span>
  -- action notice
<span class="fc" data-hits="2">  return self.actionUpdateAdminNotice(hash, msg)</span>
end

--- Stages an update for the delay time
--- @param delayInSeconds number The new delay time in seconds
--- @param msg string The message received
--- @return Message The stage update delay notice
<span class="fc" data-hits="2">function ConfiguratorMethods:stageUpdateDelay(delayInSeconds, msg)</span>
<span class="fc" data-hits="7">  local hash = crypto.digest.keccak256(tostring(delayInSeconds)).asHex()</span>
<span class="fc" data-hits="7">  self.staged[hash] = os.time()</span>
  -- stage notice
<span class="fc" data-hits="7">  return self.stageUpdateDelayNotice(delayInSeconds, hash, msg)</span>
end

--- Unstages an update for the delay time
--- @param delayInSeconds number The new delay time in seconds
--- @param msg string The message received
--- @return Message The unstage update delay notice
<span class="fc" data-hits="2">function ConfiguratorMethods:unstageUpdateDelay(delayInSeconds, msg)</span>
<span class="fc" data-hits="3">  local hash = crypto.digest.keccak256(tostring(delayInSeconds)).asHex()</span>
<span class="fc" data-hits="3">  assert(self.staged[hash], &#39;Update not staged! Hash: &#39; .. hash)</span>
  -- unstage
<span class="fc" data-hits="2">  self.staged[hash] = nil</span>
  -- unstage notice
<span class="fc" data-hits="2">  return self.unstageUpdateDelayNotice(hash, msg)</span>
end

--- Actions an update for the delay time
--- @param delayInSeconds number The new delay time in seconds
--- @param msg string The message received
--- @return Message The action update delay notice
<span class="fc" data-hits="2">function ConfiguratorMethods:actionUpdateDelay(delayInSeconds, msg)</span>
<span class="fc" data-hits="4">  local hash = crypto.digest.keccak256(tostring(delayInSeconds)).asHex()</span>
<span class="fc" data-hits="4">  assert(self.staged[hash], &#39;Update not staged! Hash: &#39; .. hash)</span>
<span class="fc" data-hits="3">  local remaining = self.staged[hash] + self.delay - os.time()</span>
<span class="fc" data-hits="3">  assert(remaining &lt;= 0, &#39;Update not staged long enough! Remaining: &#39; .. remaining .. &#39;s.&#39;)</span>
  -- action update
<span class="fc" data-hits="2">  self.delay = tonumber(delayInSeconds)</span>
  -- unstage
<span class="fc" data-hits="2">  self.staged[hash] = nil</span>
  -- action notice
<span class="fc" data-hits="2">  return self.actionUpdateDelayNotice(hash, msg)</span>
end

<span class="fc" data-hits="2">return Configurator</span>
</pre>
      </div>

      <div class="hidden file success-high" id="src-configuratormodules-configuratornotices">
         <h2 class="title">
            src/configuratorModules/configuratorNotices.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 100.00%"></span>
                  <span><strong>100.00%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>44</strong> Hits</span>
               <span class="miss"><strong>0</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums">--[[
=========================================================
Part of the Outcome codebase © 2025. All Rights Reserved.
See configurator.lua for full license details.
=========================================================
]]

<span class="fc" data-hits="3">local ConfiguratorNotices = {}</span>

--- Sends a stage update notice
--- @param process string The process ID
--- @param action string The action name
--- @param tags string The JSON string of tags
--- @param data string The JSON string of data
--- @param hash string The hash of the update
--- @param msg Message The message received
--- @return Message The stage update notice
<span class="fc" data-hits="3">function ConfiguratorNotices.stageUpdateNotice(process, action, tags, data, hash, msg)</span>
<span class="fc" data-hits="16">  return msg.reply({</span>
<span class="fc" data-hits="8">    Action = &#39;Stage-Update-Notice&#39;,</span>
<span class="fc" data-hits="8">    UpdateProcess = process,</span>
<span class="fc" data-hits="8">    UpdateAction = action,</span>
<span class="fc" data-hits="8">    UpdateTags = tags,</span>
<span class="fc" data-hits="8">    UpdateData = data,</span>
<span class="fc" data-hits="8">    Hash = hash</span>
  })
end

--- Sends an unstage update notice
--- @param hash string The hash of the update
--- @param msg Message The message received
--- @return Message The unstage update notice
<span class="fc" data-hits="3">function ConfiguratorNotices.unstageUpdateNotice(hash, msg)</span>
<span class="fc" data-hits="6">  return msg.reply({</span>
<span class="fc" data-hits="3">    Action = &#39;Unstage-Update-Notice&#39;,</span>
<span class="fc" data-hits="3">    Hash = hash</span>
  })
end

--- Sends an action update notice
--- @param hash string The hash of the update
--- @param msg Message The message received
--- @return Message The action update notice
<span class="fc" data-hits="3">function ConfiguratorNotices.actionUpdateNotice(hash, msg)</span>
<span class="fc" data-hits="6">  return msg.reply({</span>
<span class="fc" data-hits="3">    Action = &#39;Action-Update-Notice&#39;,</span>
<span class="fc" data-hits="3">    Hash = hash</span>
  })
end

--- Sends a stage update admin notice
--- @param admin string The admin address
--- @param hash string The hash of the update
--- @param msg Message The message received
--- @return Message The stage update admin notice
<span class="fc" data-hits="3">function ConfiguratorNotices.stageUpdateAdminNotice(admin, hash, msg)</span>
<span class="fc" data-hits="16">  return msg.reply({</span>
<span class="fc" data-hits="8">    Action = &#39;Stage-Update-Admin-Notice&#39;,</span>
<span class="fc" data-hits="8">    UpdateAdmin = admin,</span>
<span class="fc" data-hits="8">    Hash = hash</span>
  })
end

--- Sends an unstage update admin notice
--- @param hash string The hash of the update
--- @param msg Message The message received
--- @return Message The unstage update admin notice
<span class="fc" data-hits="3">function ConfiguratorNotices.unstageUpdateAdminNotice(hash, msg)</span>
<span class="fc" data-hits="6">  return msg.reply({</span>
<span class="fc" data-hits="3">    Action = &#39;Unstage-Update-Admin-Notice&#39;,</span>
<span class="fc" data-hits="3">    Hash = hash</span>
  })
end

--- Sends an action update admin notice
--- @param hash string The hash of the update
--- @param msg Message The message received
--- @return Message The action update admin notice
<span class="fc" data-hits="3">function ConfiguratorNotices.actionUpdateAdminNotice(hash, msg)</span>
<span class="fc" data-hits="6">  return msg.reply({</span>
<span class="fc" data-hits="3">    Action = &#39;Action-Update-Admin-Notice&#39;,</span>
<span class="fc" data-hits="3">    Hash = hash</span>
  })
end

--- Sends a stage update delay notice
--- @param delay number The delay time in seconds
--- @param hash string The hash of the update
--- @param msg Message The message received
--- @return Message The stage update delay notice
<span class="fc" data-hits="3">function ConfiguratorNotices.stageUpdateDelayNotice(delay, hash, msg)</span>
<span class="fc" data-hits="16">  return msg.reply({</span>
<span class="fc" data-hits="8">    Action = &#39;Stage-Update-Delay-Notice&#39;,</span>
<span class="fc" data-hits="8">    UpdateDelay = delay,</span>
<span class="fc" data-hits="8">    Hash = hash</span>
  })
end

--- Sends an unstage update delay notice
--- @param hash string The hash of the update
--- @param msg Message The message received
--- @return Message The unstage update delay notice
<span class="fc" data-hits="3">function ConfiguratorNotices.unstageUpdateDelayNotice(hash, msg)</span>
<span class="fc" data-hits="6">  return msg.reply({</span>
<span class="fc" data-hits="3">    Action = &#39;Unstage-Update-Delay-Notice&#39;,</span>
<span class="fc" data-hits="3">    Hash = hash</span>
  })
end

--- Sends an action update delay notice
--- @param hash string The hash of the update
--- @param msg Message The message received
--- @return Message The action update delay notice
<span class="fc" data-hits="3">function ConfiguratorNotices.actionUpdateDelayNotice(hash, msg)</span>
<span class="fc" data-hits="6">  return msg.reply({</span>
<span class="fc" data-hits="3">    Action = &#39;Action-Update-Delay-Notice&#39;,</span>
<span class="fc" data-hits="3">    Hash = hash</span>
  })
end

<span class="fc" data-hits="3">return ConfiguratorNotices</span>
</pre>
      </div>

      <div class="hidden file success-high" id="src-configuratormodules-configuratorvalidation">
         <h2 class="title">
            src/configuratorModules/configuratorValidation.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 97.37%"></span>
                  <span><strong>97.37%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>37</strong> Hits</span>
               <span class="miss"><strong>1</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums">--[[
=========================================================
Part of the Outcome codebase © 2025. All Rights Reserved.
See configurator.lua for full license details.
=========================================================
]]

<span class="fc" data-hits="2">local ConfiguratorValidation = {}</span>
<span class="fc" data-hits="2">local sharedUtils = require(&#39;configuratorModules.sharedUtils&#39;)</span>

--- Validates the updateProcess message
--- @param msg Message The message to be validated
--- @return boolean, string|nil Returns true on success, or false and an error message on failure
<span class="fc" data-hits="2">function ConfiguratorValidation.updateProcess(msg)</span>
<span class="fc" data-hits="23">  if msg.From ~= Configurator.admin then</span>
<span class="fc" data-hits="1">    return false, &#39;Sender must be admin!&#39;</span>
  end
<span class="fc" data-hits="22">  if type(msg.Tags.UpdateProcess) ~= &#39;string&#39; then</span>
<span class="fc" data-hits="1">    return false, &#39;UpdateProcess is required and must be a string!&#39;</span>
  end
<span class="fc" data-hits="21">  if not sharedUtils.isValidArweaveAddress(msg.Tags.UpdateProcess) then</span>
<span class="nc">    return false, &#39;UpdateProcess must be a valid Arweave address!&#39;</span>
  end
<span class="fc" data-hits="21">  if type(msg.Tags.UpdateAction) ~= &#39;string&#39; then</span>
<span class="fc" data-hits="1">    return false, &#39;UpdateAction is required and must be a string!&#39;</span>
  end
<span class="fc" data-hits="20">  if msg.Tags.UpdateTags ~= nil and not sharedUtils.isValidKeyValueJSON(msg.Tags.UpdateTags) then</span>
<span class="fc" data-hits="7">    return false, &#39;UpdateTags must be valid JSON!&#39;</span>
  end
<span class="fc" data-hits="13">  if msg.Tags.UpdateData ~= nil and not sharedUtils.isValidKeyValueJSON(msg.Tags.UpdateData) then</span>
<span class="fc" data-hits="1">    return false, &#39;UpdateData must be valid JSON!&#39;</span>
  end

<span class="fc" data-hits="12">  return true</span>
end

--- Validates the updateAdmin message
--- @param msg Message The message to be validated
--- @return boolean, string|nil Returns true on success, or false and an error message on failure
<span class="fc" data-hits="2">function ConfiguratorValidation.updateAdmin(msg)</span>
<span class="fc" data-hits="9">  if msg.From ~= Configurator.admin then</span>
<span class="fc" data-hits="1">    return false, &#39;Sender must be admin!&#39;</span>
  end
<span class="fc" data-hits="8">  if type(msg.Tags.UpdateAdmin) ~= &#39;string&#39; then</span>
<span class="fc" data-hits="1">    return false, &#39;UpdateAdmin is required and must be a string!&#39;</span>
  end
<span class="fc" data-hits="7">  if not sharedUtils.isValidArweaveAddress(msg.Tags.UpdateAdmin) then</span>
<span class="fc" data-hits="1">    return false, &#39;UpdateAdmin must be a valid Arweave address!&#39;</span>
  end

<span class="fc" data-hits="6">  return true</span>
end

--- Validates the updateDelay message
--- @param msg Message The message to be validated
--- @return boolean, string|nil Returns true on success, or false and an error message on failure
<span class="fc" data-hits="2">function ConfiguratorValidation.updateDelay(msg)</span>
<span class="fc" data-hits="12">  if msg.From ~= Configurator.admin then</span>
<span class="fc" data-hits="1">    return false, &#39;Sender must be admin!&#39;</span>
  end
<span class="fc" data-hits="11">  if not msg.Tags.UpdateDelay then</span>
<span class="fc" data-hits="1">    return false, &#39;UpdateDelay is required!&#39;</span>
  end

<span class="fc" data-hits="10">  local delay = tonumber(msg.Tags.UpdateDelay)</span>
<span class="fc" data-hits="10">  if not delay then</span>
<span class="fc" data-hits="1">    return false, &#39;UpdateDelay must be a valid number!&#39;</span>
  end
<span class="fc" data-hits="9">  if delay &lt;= 0 then</span>
<span class="fc" data-hits="2">    return false, &#39;UpdateDelay must be greater than zero!&#39;</span>
  end
<span class="fc" data-hits="7">  if delay % 1 ~= 0 then</span>
<span class="fc" data-hits="1">    return false, &#39;UpdateDelay must be an integer!&#39;</span>
  end

<span class="fc" data-hits="6">  return true</span>
end

<span class="fc" data-hits="2">return ConfiguratorValidation</span>
</pre>
      </div>

      <div class="hidden file success-low" id="src-configuratormodules-sharedutils">
         <h2 class="title">
            src/configuratorModules/sharedUtils.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 72.97%"></span>
                  <span><strong>72.97%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>27</strong> Hits</span>
               <span class="miss"><strong>10</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums">--[[
=========================================================
Part of the Outcome codebase © 2025. All Rights Reserved.
See market.lua for full license details.
=========================================================
]]

<span class="fc" data-hits="3">local sharedUtils = {}</span>

--- Verify if extracted value is a JSON simple value
--- @param value any
--- @return boolean
local function isSimpleValue(value)
  -- Trim whitespace
<span class="fc" data-hits="28">  value = value:match(&quot;^%s*(.-)%s*$&quot;) or value</span>
  -- Check for a quoted string: &quot;someValue&quot;
<span class="fc" data-hits="28">  if value:match(&#39;^&quot;[^&quot;]*&quot;$&#39;) then</span>
<span class="fc" data-hits="21">    return true</span>
  end
  -- Check for a number (integer or float, optional minus sign): 123, -123, 123.45
<span class="fc" data-hits="7">  if value:match(&#39;^[-]?%d+%.?%d*$&#39;) then</span>
<span class="fc" data-hits="3">    return true</span>
  end
  -- Check for boolean
<span class="fc" data-hits="4">  if string.lower(value) == &quot;true&quot; or string.lower(value) == &quot;false&quot; then</span>
<span class="fc" data-hits="1">    return true</span>
  end
<span class="fc" data-hits="3">  return false</span>
end

--- Verify if a valid JSON object
--- @param str any
--- @return boolean
<span class="fc" data-hits="3">function sharedUtils.isValidKeyValueJSON(str)</span>
<span class="fc" data-hits="33">  if type(str) ~= &quot;string&quot; then return false end</span>
  -- Trim whitespace
<span class="fc" data-hits="33">  str = str:match(&quot;^%s*(.-)%s*$&quot;)</span>
  -- Ensure it starts with `{` and ends with `}`
<span class="fc" data-hits="33">  local isObject = str:match(&quot;^%{%s*(.-)%s*%}$&quot;)</span>
<span class="fc" data-hits="33">  if not isObject then return false end</span>
  -- This pattern only extracts the key and the entire raw value
<span class="fc" data-hits="29">  local keyValuePattern = &#39;^%s*&quot;([^&quot;]+)&quot;%s*:%s*(.-)%s*$&#39;</span>
  -- Check all key-value pairs
<span class="fc" data-hits="54">  for keyValue in isObject:gmatch(&quot;[^,]+&quot;) do</span>
<span class="fc" data-hits="29">    local key, rawValue = keyValue:match(keyValuePattern)</span>
<span class="fc" data-hits="29">    if not key or not rawValue then</span>
<span class="fc" data-hits="1">      return false</span>
    end
    -- Now validate that rawValue is a valid JSON simple value
<span class="fc" data-hits="28">    if not isSimpleValue(rawValue) then</span>
<span class="fc" data-hits="3">      return false</span>
    end
  end
<span class="fc" data-hits="25">  return true</span>
end

--- Verify if a valid JSON array
--- @param str any
--- @return boolean
<span class="fc" data-hits="3">function sharedUtils.isJSONArray(str)</span>
<span class="nc">  if type(str) ~= &quot;string&quot; then return false end</span>
  -- Trim whitespace
<span class="nc">  str = str:match(&quot;^%s*(.-)%s*$&quot;)</span>
  -- Ensure it starts with `[` and ends with `]`
<span class="nc">  local isArray = str:match(&quot;^%[%s*(.-)%s*%]$&quot;)</span>
<span class="nc">  if not isArray then return false end</span>
  -- Split the array elements and validate each one
<span class="nc">  for value in isArray:gmatch(&quot;[^,]+&quot;) do</span>
<span class="nc">    value = value:match(&quot;^%s*(.-)%s*$&quot;) -- Trim whitespace around each value</span>
<span class="nc">    if not isSimpleValue(value) then</span>
<span class="nc">      return false</span>
    end
  end
<span class="nc">  return true</span>
end

--- Verify if a valid Arweave address
--- @param address any
--- @return boolean
<span class="fc" data-hits="3">function sharedUtils.isValidArweaveAddress(address)</span>
<span class="fc" data-hits="47">	return type(address) == &quot;string&quot; and #address == 43 and string.match(address, &quot;^[%w-_]+$&quot;) ~= nil</span>
end

--- Verify if a valid boolean string
--- @param value any
--- @return boolean
<span class="fc" data-hits="3">function sharedUtils.isValidBooleanString(value)</span>
<span class="nc">  return type(value) == &quot;string&quot; and (string.lower(value) == &quot;true&quot; or string.lower(value) == &quot;false&quot;)</span>
end

<span class="fc" data-hits="3">return sharedUtils</span>
</pre>
      </div>

      <div class="hidden file success-high" id="src-marketfactorymodules-constants">
         <h2 class="title">
            src/marketFactoryModules/constants.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 100.00%"></span>
                  <span><strong>100.00%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>20</strong> Hits</span>
               <span class="miss"><strong>0</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums">--[[
=========================================================
Part of the Outcome codebase © 2025. All Rights Reserved.
See market.lua for full license details.
=========================================================
]]

-- Market Factory
<span class="fc" data-hits="1">local constants = {</span>
<span class="fc" data-hits="1">  namePrefix = &quot;Outcome Market&quot;,</span>
<span class="fc" data-hits="1">  tickerPrefix = &quot;OUTCOME&quot;,</span>
<span class="fc" data-hits="1">  logo = &quot;https:&#47;&#47;test.com&#47;logo.png&quot;,</span>
<span class="fc" data-hits="1">  lpFee = 100,</span>
<span class="fc" data-hits="1">  protocolFee = 250,</span>
<span class="fc" data-hits="1">  maximumTakeFee = 500,</span>
}
<span class="fc" data-hits="1">constants.dev = {</span>
<span class="fc" data-hits="1">  configurator = &quot;XZrrfWA17ljL8msjXvG3kYx2mo5odhlgJJ8bWo6lxwo&quot;,</span>
<span class="fc" data-hits="1">  dataIndex = &quot;odLEQRm_H6ZqUejiTbkS1Zuq3YfCDz5dcYFLy0gm-eM&quot;, --&lt;-TEST_PLATFORM_DATA2 for work on the UI --&quot;rXSAUKwZhJkIBTIEyBl1rf8Gtk_88RKQFsx5JvDOwlE&quot;,</span>
<span class="fc" data-hits="1">  protocolFeeTarget = &quot;m6W6wreOSejTb2WRHoALM6M7mw3H8D2KmFVBYC1l0O0&quot;,</span>
<span class="fc" data-hits="1">  approvedCollateralTokens = {[&quot;jAyJBNpuSXmhn9lMMfwDR60TfIPANXI6r-f3n9zucYU&quot;] = true},</span>
<span class="fc" data-hits="1">}</span>
<span class="fc" data-hits="1">constants.prod = {</span>
<span class="fc" data-hits="1">  configurator = &quot;XkVOo16KMIHK-zqlR67cuNY0ayXIkPWODWw_HXAE20I&quot;,</span>
<span class="fc" data-hits="1">  dataIndex = &quot;odLEQRm_H6ZqUejiTbkS1Zuq3YfCDz5dcYFLy0gm-eM&quot;,</span>
<span class="fc" data-hits="1">  protocolFeeTarget = &quot;XkVOo16KMIHK-zqlR67cuNY0ayXIkPWODWw_HXAE20I&quot;,</span>
<span class="fc" data-hits="1">  approvedCollateralTokens = {[&quot;test-this-is-valid-arweave-wallet-address-5&quot;] = true},</span>
<span class="fc" data-hits="1">}</span>
<span class="fc" data-hits="1">return constants</span>
</pre>
      </div>

      <div class="hidden file danger" id="src-marketfactorymodules-marketfactory">
         <h2 class="title">
            src/marketFactoryModules/marketFactory.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 18.12%"></span>
                  <span><strong>18.12%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>25</strong> Hits</span>
               <span class="miss"><strong>113</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums">--[[
======================================================================================
Outcome © 2025. All Rights Reserved.
======================================================================================
This code is proprietary and owned by Outcome.

You are permitted to build applications, integrations, and extensions that interact
with the Outcome Protocol, provided such usage adheres to the official Outcome
terms of service and does not result in unauthorized forks or clones of this codebase.

Redistribution, modification, or unauthorized use of this code is strictly prohibited
without explicit written permission from Outcome.
======================================================================================
]]

<span class="fc" data-hits="1">local MarketFactory = {}</span>
<span class="fc" data-hits="1">local MarketFactoryMethods = {}</span>
<span class="fc" data-hits="1">local MarketFactoryNotices = require(&#39;marketFactoryModules.marketFactoryNotices&#39;)</span>
<span class="fc" data-hits="1">local marketProcessCode = require(&#39;marketFactoryModules.marketProcessCodeV2&#39;)</span>
<span class="fc" data-hits="1">local json = require(&#39;json&#39;)</span>

--- Represents a MarketFactory
--- @class MarketFactory
--- @field payoutNumerators table&lt;string, table&lt;number&gt;&gt; Payout Numerators for each outcomeSlot
--- @field payoutDenominator table&lt;string, number&gt; Payout Denominator
--- @field messageToProcessMapping table&lt;string, string&gt; Mapping of message IDs to process IDs
--- @field processToMessageMapping table&lt;string, string&gt; Mapping of process IDs to message IDs
--- @field marketsSpawnedByCreator table&lt;string, table&lt;string&gt;&gt; List of markets spawned by creator
--- @field marketsPendingInit table&lt;string&gt; List of markets pending initialization
--- @field marketsInit table&lt;string&gt; List of initialized markets
--- @field marketProcessCode table&lt;string, string&gt; Market process code
--- @field approvedCollateralTokens table&lt;string, boolean&gt; Approved collateral tokens

--- Create a new MarketFactory instance
--- @return MarketFactory marketFactory The new MarketFactory instance
<span class="fc" data-hits="1">function MarketFactory.new(</span>
  configurator,
  dataIndex,
  namePrefix,
  tickerPrefix,
  logo,
  lpFee,
  protocolFee,
  protocolFeeTarget,
  maximumTakeFee,
  approvedCollateralTokens
)
<span class="nc">  local marketFactory = {</span>
    configurator = configurator,
    dataIndex = dataIndex,
    namePrefix = namePrefix,
    tickerPrefix = tickerPrefix,
    logo = logo,
    lpFee = lpFee,
    protocolFee = protocolFee,
    protocolFeeTarget = protocolFeeTarget,
    maximumTakeFee = maximumTakeFee,
    approvedCollateralTokens = approvedCollateralTokens,
    messageToProcessMapping = {},
    processToMessageMapping = {},
    messageToMarketConfigMapping = {},
    marketsSpawnedByCreator = {},
    marketsPendingInit = {},
    marketsInit = {},
    marketGroupCollateralByCreator = {},
<span class="nc">    marketProcessCode = marketProcessCode</span>
  }
<span class="nc">  setmetatable(marketFactory, {</span>
    __index = function(_, k)
<span class="nc">      if MarketFactoryMethods[k] then</span>
<span class="nc">        return MarketFactoryMethods[k]</span>
<span class="nc">      elseif MarketFactoryNotices[k] then</span>
<span class="nc">        return MarketFactoryNotices[k]</span>
      else
<span class="nc">        return nil</span>
      end
    end
  })
<span class="nc">  return marketFactory</span>
end

--[[
===========
INFO METHOD
===========
]]

--- Info
--- @param msg Message The message received
--- @return Message The info message
<span class="fc" data-hits="1">function MarketFactoryMethods:info(msg)</span>
<span class="nc">  return msg.reply({</span>
    Configurator = self.configurator,
    DataIndex = self.dataIndex,
    LpFee = tostring(self.lpFee),
    ProtocolFee = tostring(self.protocolFee),
    ProtocolFeeTarget = self.protocolFeeTarget,
    MaximumTakeFee = tostring(self.maximumTakeFee),
    ApprovedCollateralTokens = json.encode(self.approvedCollateralTokens),
  })
end

--[[
================
INTERNAL METHODS
================
]]

--- Generate position IDs
--- @param outcomeSlotCount number The number of outcome slots
--- @return table&lt;string&gt; A basic partition based on outcomeSlotCount
local function getPositionIds(outcomeSlotCount)
<span class="nc">  local positionIds = {}</span>
<span class="nc">  for i = 1, outcomeSlotCount do</span>
<span class="nc">    table.insert(positionIds, tostring(i))</span>
  end
<span class="nc">  return positionIds</span>
end

--[[
=============
ACTIVITY LOGS
=============
]]

local function logMarket(
  dataIndex,
  market,
  creator,
  creatorFee,
  creatorFeeTarget,
  question,
  rules,
  outcomeSlotCount,
  collateralToken,
  resolutionAgent,
  category,
  subcategory,
  logo,
  groupId,
  msg
)
  -- create notice
<span class="nc">  local notice = {</span>
    Action = &quot;Log-Market-Notice&quot;,
    Market = market,
    Creator = creator,
    CreatorFee = tostring(creatorFee),
    CreatorFeeTarget = creatorFeeTarget,
    Question = question,
    Rules = rules,
    OutcomeSlotCount = tostring(outcomeSlotCount),
    Collateral = collateralToken,
    ResolutionAgent = resolutionAgent,
    Category = category,
    Subcategory = subcategory,
    Logo = logo,
<span class="nc">    GroupId = groupId</span>
  }
  -- log to data index
<span class="nc">  msg.forward(dataIndex, notice)</span>
  -- log to creator
<span class="nc">  msg.forward(creator, notice)</span>
end

local function logGroup(dataIndex, group, creator, collateral, question, rules, category, subcategory, logo, msg)
  -- create notice
<span class="nc">  local notice = {</span>
    Action = &quot;Log-Group-Notice&quot;,
    Group = group,
    Collateral = collateral,
    Question = question,
    Rules = rules,
    Category = category,
    Subcategory = subcategory,
    Logo = logo,
<span class="nc">    Creator = creator</span>
  }
  -- log to data index
<span class="nc">  msg.forward(dataIndex, notice)</span>
  -- log to creator
<span class="nc">  msg.forward(creator, notice)</span>
end

--[[
=============
WRITE METHODS
=============
]]

--- Create Market Group
--- @notice Market groups only support binary outcomes
--- @param msg Message The message received
--- @return Message The create group message
<span class="fc" data-hits="1">function MarketFactoryMethods:createMarketGroup(collateral, question, rules, category, subcategory, logo, msg)</span>
  -- set defaults
<span class="nc">  category = category or &quot;&quot;</span>
<span class="nc">  subcategory = subcategory or &quot;&quot;</span>
<span class="nc">  logo = logo or self.marketLogo</span>
  -- create group
<span class="nc">  if not self.marketGroupCollateralByCreator[msg.From] then self.marketGroupCollateralByCreator[msg.From] = {} end</span>
<span class="nc">  self.marketGroupCollateralByCreator[msg.From][msg.Id] = collateral</span>
  -- log group
<span class="nc">  logGroup(self.dataIndex, msg.Id, msg.From, collateral, question, rules, category, subcategory, logo, msg)</span>
  -- send notice
<span class="nc">  return self.createMarketGroupNotice(collateral, msg.From, question, rules, category, subcategory, logo, msg)</span>
end

--- Spawn market
--- @param collateralToken string The collateral token address
--- @param resolutionAgent string The process assigned to report the market result
--- @param question string The question to be answered by the resolutionAgent
--- @param rules string The rules of the market
--- @param outcomeSlotCount number The number of outcome slots which should be used for this condition
--- @param creator string The creator address
--- @param creatorFee number The creator fee
--- @param creatorFeeTarget string The creator fee target
--- @param category string|nil The category of the market
--- @param subcategory string|nil The subcategory of the market
--- @param logo string|nil The logo of the market
--- @param groupId string|nil The group ID or nil
--- @param msg Message The message received
--- @return Message marketSpawnedNotice The market spawned notice
<span class="fc" data-hits="1">function MarketFactoryMethods:spawnMarket(</span>
  collateralToken,
  resolutionAgent,
  question,
  rules,
  outcomeSlotCount,
  creator,
  creatorFee,
  creatorFeeTarget,
  category,
  subcategory,
  logo,
  groupId,
  msg
)
  -- set defaults
<span class="nc">  rules = rules or &quot;&quot;</span>
<span class="nc">  category = category or &quot;&quot;</span>
<span class="nc">  subcategory = subcategory or &quot;&quot;</span>
<span class="nc">  logo = logo or self.marketLogo</span>
<span class="nc">  groupId = groupId or &quot;&quot;</span>
  -- check if group exists, creator is the owner, collateral matches group, and outcomeSlotCount == 2
<span class="nc">  if groupId ~= &quot;&quot; then</span>
<span class="nc">    if not self.marketGroupCollateralByCreator[creator] then</span>
<span class="nc">      return msg.reply({Error = &quot;Group not found&quot;})</span>
    end
<span class="nc">    if not self.marketGroupCollateralByCreator[creator][groupId] then</span>
<span class="nc">      return msg.reply({Error = &quot;Group not found&quot;})</span>
    end
<span class="nc">    if self.marketGroupCollateralByCreator[msg.From][msg.Id] ~= collateralToken then</span>
<span class="nc">      return msg.reply({Error = &quot;Collateral token does not match group&quot;})</span>
    end
<span class="nc">    if outcomeSlotCount ~= 2 then</span>
<span class="nc">      return msg.reply({Error = &quot;Outcome slot count must be 2 for group markets&quot;})</span>
    end
  end
  -- spawn market
<span class="nc">  ao.spawn(ao.env.Module.Id, {</span>
    -- Factory parameters
    [&quot;Original-Msg-Id&quot;] = msg.Id,
    -- Configurator-controlled parameters
    [&quot;Authority&quot;] = ao.authorities[1],
    [&quot;Name&quot;] = self.namePrefix,
    [&quot;Ticker&quot;] = self.tickerPrefix,
    [&quot;Logo&quot;] = logo,
    [&quot;LpFee&quot;] = tostring(self.lpFee),
    [&quot;Configurator&quot;] = self.configurator,
    [&quot;DataIndex&quot;] = self.dataIndex,
    [&quot;ProtocolFee&quot;] = tostring(self.protocolFee),
    [&quot;ProtocolFeeTarget&quot;] = self.protocolFeeTarget,
    -- Creator-controlled parameters
    [&quot;ResolutionAgent&quot;] = resolutionAgent,
    [&quot;CollateralToken&quot;] = collateralToken,
    [&quot;Creator&quot;] = creator,
    [&quot;CreatorFee&quot;] = tostring(creatorFee),
    [&quot;CreatorFeeTarget&quot;] = creatorFeeTarget,
    [&quot;Question&quot;] = question,
    [&quot;Rules&quot;] = rules,
    [&quot;Category&quot;] = category,
    [&quot;Subcategory&quot;] = subcategory,
    [&quot;PositionIds&quot;] = json.encode(getPositionIds(outcomeSlotCount)),
    [&quot;GroupId&quot;] = groupId,
    -- Environment set to PROD to renounce process owner on eval
<span class="nc">    [&quot;Env&quot;] = &quot;PROD&quot;</span>
  })
  -- add mapping
<span class="nc">  local marketConfig = {</span>
    creator = creator,
    creatorFee = creatorFee,
    creatorFeeTarget = creatorFeeTarget,
    question = question,
    rules = rules,
    outcomeSlotCount = outcomeSlotCount,
    collateralToken = collateralToken,
    resolutionAgent = resolutionAgent,
    category = category,
    subcategory = subcategory,
    logo = logo,
<span class="nc">    groupId = groupId</span>
  }
<span class="nc">  self.messageToMarketConfigMapping[msg.Id] = marketConfig</span>
  -- send notice
<span class="nc">  return self.spawnMarketNotice(resolutionAgent, collateralToken, creator, creatorFee, creatorFeeTarget, question, rules, outcomeSlotCount, category, subcategory, logo, groupId, msg)</span>
end

<span class="fc" data-hits="1">function MarketFactoryMethods:initMarket(msg)</span>
<span class="nc">  local processIds = self.marketsPendingInit</span>
<span class="nc">  if #processIds == 0 then</span>
    -- send notice
<span class="nc">    return self.initMarketNotice(processIds, msg)</span>
   end
  -- init pending markets
<span class="nc">  for i = 1, #processIds do</span>
<span class="nc">    local processId = processIds[i]</span>
<span class="nc">    ao.send({</span>
      Target = processId,
      Action = &quot;Eval&quot;,
      Data = self.marketProcessCode,
    })
    -- add to markets init
<span class="nc">    table.insert(self.marketsInit, processId)</span>
    -- log market with data index and creator
<span class="nc">    local messageId = self.processToMessageMapping[processId]</span>
<span class="nc">    local marketConfig = self.messageToMarketConfigMapping[messageId]</span>
<span class="nc">    logMarket(</span>
<span class="nc">      self.dataIndex,</span>
      processId,
<span class="nc">      marketConfig.creator,</span>
<span class="nc">      marketConfig.creatorFee,</span>
<span class="nc">      marketConfig.creatorFeeTarget,</span>
<span class="nc">      marketConfig.question,</span>
<span class="nc">      marketConfig.rules,</span>
<span class="nc">      marketConfig.outcomeSlotCount,</span>
<span class="nc">      marketConfig.collateralToken,</span>
<span class="nc">      marketConfig.resolutionAgent,</span>
<span class="nc">      marketConfig.category,</span>
<span class="nc">      marketConfig.subcategory,</span>
<span class="nc">      marketConfig.logo,</span>
<span class="nc">      marketConfig.groupId,</span>
      msg
    )
  end
  -- reset pending init
<span class="nc">  self.marketsPendingInit = {}</span>
  -- send notice
<span class="nc">  return self.initMarketNotice(processIds, msg)</span>
end

--[[
============
READ METHODS
============
]]

<span class="fc" data-hits="1">function MarketFactoryMethods:marketsPending(msg)</span>
<span class="nc">  return msg.reply({Data = json.encode(self.marketsPendingInit)})</span>
end

<span class="fc" data-hits="1">function MarketFactoryMethods:marketsInitialized(msg)</span>
<span class="nc">  return msg.reply({Data = json.encode(self.marketsInit)})</span>
end

<span class="fc" data-hits="1">function MarketFactoryMethods:marketGroupsByCreator(msg)</span>
<span class="nc">  local creatorMarketGroups = self.marketGroupCollateralByCreator[msg.Tags.Creator] or {}</span>
<span class="nc">  return msg.reply({</span>
    Creator = msg.Tags.Creator or msg.From,
<span class="nc">    Data = json.encode(creatorMarketGroups)</span>
  })
end

<span class="fc" data-hits="1">function MarketFactoryMethods:marketsByCreator(msg)</span>
<span class="nc">  local creatorMarkets = self.marketsSpawnedByCreator[msg.Tags.Creator] or {}</span>
<span class="nc">  return msg.reply({</span>
    Creator = msg.Tags.Creator or msg.From,
<span class="nc">    Data = json.encode(creatorMarkets)</span>
  })
end

<span class="fc" data-hits="1">function MarketFactoryMethods:getProcessId(msg)</span>
<span class="nc">  local originalMsgId = msg.Tags[&quot;Original-Msg-Id&quot;]</span>
<span class="nc">  return msg.reply({</span>
    [&quot;Original-Msg-Id&quot;] = originalMsgId,
<span class="nc">    Data = self.messageToProcessMapping[originalMsgId]</span>
  })
end

<span class="fc" data-hits="1">function MarketFactoryMethods:getLatestProcessIdForCreator(creator, msg)</span>
<span class="nc">  local creatorMarkets = self.marketsSpawnedByCreator[creator] or {}</span>
<span class="nc">  return msg.reply({</span>
    Creator = creator,
<span class="nc">    Data = creatorMarkets[#creatorMarkets]</span>
  })
end

--[[ce
====================
CONFIGURATOR METHODS
====================
]]

--- Update configurator
--- @param configurator string The new configurator address
--- @param msg Message The message received
--- @return Message updateConfiguratorNotice The update configurator notice
<span class="fc" data-hits="1">function MarketFactoryMethods:updateConfigurator(configurator, msg)</span>
<span class="nc">  self.configurator = configurator</span>
<span class="nc">  return self.updateConfiguratorNotice(configurator, msg)</span>
end

--- Update lpFee
--- @param lpFee number The new lpFee
--- @param msg Message The message received
--- @return Message updateLpFeeNotice The update lpFee notice
<span class="fc" data-hits="1">function MarketFactoryMethods:updateLpFee(lpFee, msg)</span>
<span class="nc">  self.lpFee = lpFee</span>
<span class="nc">  return self.updateLpFeeNotice(lpFee, msg)</span>
end

--- Update protocolFee
--- @param protocolFee number The new protocolFee
--- @param msg Message The message received
--- @return Message updateProtocolFeeNotice The update protocolFee notice
<span class="fc" data-hits="1">function MarketFactoryMethods:updateProtocolFee(protocolFee, msg)</span>
<span class="nc">  self.protocolFee = protocolFee</span>
<span class="nc">  return self.updateProtocolFeeNotice(protocolFee, msg)</span>
end

--- Update protocolFeeTarget
--- @param protocolFeeTarget string The new protocolFeeTarget
--- @param msg Message The message received
--- @return Message updateProtocolFeeTargetNotice The update protocolFeeTarget notice
<span class="fc" data-hits="1">function MarketFactoryMethods:updateProtocolFeeTarget(protocolFeeTarget, msg)</span>
<span class="nc">  self.protocolFeeTarget = protocolFeeTarget</span>
<span class="nc">  return self.updateProtocolFeeTargetNotice(protocolFeeTarget, msg)</span>
end

--- Update maximumTakeFee
--- @param maximumTakeFee number The new maximumTakeFee
--- @param msg Message The message received
--- @return Message updateMaximumTakeFeeNotice The update maximumTakeFee notice
<span class="fc" data-hits="1">function MarketFactoryMethods:updateMaximumTakeFee(maximumTakeFee, msg)</span>
<span class="nc">  self.maximumTakeFee = maximumTakeFee</span>
<span class="nc">  return self.updateMaximumTakeFeeNotice(maximumTakeFee, msg)</span>
end

--- Approve collateralToken
--- @param collateralToken string The approved collateral token address
--- @param approved boolean True to approve, false to disapprove
--- @param msg Message The message received
--- @return Message approveCollateralTokenNotice The approveCollateralToken notice
<span class="fc" data-hits="1">function MarketFactoryMethods:approveCollateralToken(collateralToken, approved, msg)</span>
<span class="nc">  self.approvedCollateralTokens[collateralToken] = approved</span>
<span class="nc">  return self.approveCollateralTokenNotice(collateralToken, approved, msg)</span>
end

--- Transfer
--- @dev Acts as a fallback to recover tokens sent in error
--- @param token string The token address
--- @param recipient string The recipient address
--- @param quantity string The quantity to transfer
--- @param msg Message The message received
--- @return Message transferMessage The transfer message
<span class="fc" data-hits="1">function MarketFactoryMethods:transfer(token, recipient, quantity, msg)</span>
<span class="nc">  ao.send({</span>
    Target = token,
    Action = &quot;Transfer&quot;,
    Recipient = recipient,
    Quantity = quantity,
<span class="nc">    [&quot;X-Sender&quot;] = msg.From</span>
  })
<span class="nc">  return self.transferNotice(token, recipient, quantity, msg)</span>
end

--[[
================
CALLBACK METHODS
================
]]

--- Handle spawned market
--- Updates mappings and tables
--- @param msg Message The message received
--- @return boolean success True if successful, false otherwise
<span class="fc" data-hits="1">function MarketFactoryMethods:spawnedMarket(msg)</span>
<span class="nc">  local originalMsgId = msg.Tags[&quot;Original-Msg-Id&quot;]</span>
<span class="nc">  local processId = msg.Tags[&quot;Process&quot;]</span>
<span class="nc">  local creator = msg.Tags[&quot;Creator&quot;]</span>
  -- add mappings
<span class="nc">  self.messageToProcessMapping[originalMsgId] = processId</span>
<span class="nc">  self.processToMessageMapping[processId] = originalMsgId</span>
  -- add to pending init
<span class="nc">  table.insert(self.marketsPendingInit, processId)</span>
  -- add to spawned by creator
<span class="nc">  if not self.marketsSpawnedByCreator[creator] then</span>
<span class="nc">    self.marketsSpawnedByCreator[creator] = {}</span>
  end
<span class="nc">  table.insert(self.marketsSpawnedByCreator[creator], processId)</span>
<span class="nc">  return true</span>
end

<span class="fc" data-hits="1">return MarketFactory</span>
</pre>
      </div>

      <div class="hidden file warning" id="src-marketfactorymodules-marketfactorynotices">
         <h2 class="title">
            src/marketFactoryModules/marketFactoryNotices.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 40.62%"></span>
                  <span><strong>40.62%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>13</strong> Hits</span>
               <span class="miss"><strong>19</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums">--[[
=========================================================
Part of the Outcome codebase © 2025. All Rights Reserved.
See factory.lua for full license details.
=========================================================
]]

<span class="fc" data-hits="1">local MarketFactoryNotices = {}</span>
<span class="fc" data-hits="1">local json = require(&#39;json&#39;)</span>

--- Create market group notice
--- @param collateral string The collateral token address
--- @param creator string The creator address
--- @param question string The group title
--- @param rules string The group rules
--- @param category string The group category
--- @param subcategory string The group subcategory
--- @param logo string The group logo
--- @param msg Message The message received
--- @return Message createGroupNotice The create group notice
<span class="fc" data-hits="1">function MarketFactoryNotices.createMarketGroupNotice(collateral, creator, question, rules, category, subcategory, logo, msg)</span>
<span class="nc">  return msg.reply({</span>
    Action = &quot;Create-Market-Group-Notice&quot;,
    GroupId = msg.Id,
    Collateral = collateral,
    Creator = creator,
    Question = question,
    Rules = rules,
    Category = category,
    Subcategory = subcategory,
<span class="nc">    Logo = logo</span>
  })
end

--- Spawn market notice
--- @param resolutionAgent string The resolution agent address
--- @param collateralToken string The collateral token address
--- @param creator string The creator address
--- @param creatorFee number The creator fee
--- @param creatorFeeTarget string The creator fee target
--- @param question string The market question
--- @param rules string The market rules
--- @param outcomeSlotCount number The number of outcome slots
--- @param category string The market category
--- @param subcategory string The market subcategory
--- @param logo string The market logo
--- @param groupId string The group ID
--- @param msg Message The message received
--- @return Message spawnMarketNotice The spawn market notice
<span class="fc" data-hits="1">function MarketFactoryNotices.spawnMarketNotice(</span>
  resolutionAgent,
  collateralToken,
  creator,
  creatorFee,
  creatorFeeTarget,
  question,
  rules,
  outcomeSlotCount,
  category,
  subcategory,
  logo,
  groupId,
  msg
)
<span class="nc">  return msg.reply({</span>
    Action = &quot;Spawn-Market-Notice&quot;,
    ResolutionAgent = resolutionAgent,
    CollateralToken = collateralToken,
    Creator = creator,
    CreatorFee = tostring(creatorFee),
    CreatorFeeTarget = creatorFeeTarget,
    Question = question,
    Rules = rules,
    OutcomeSlotCount = tostring(outcomeSlotCount),
    Category = category,
    Subcategory = subcategory,
    Logo = logo,
    GroupId = groupId,
<span class="nc">    [&quot;Original-Msg-Id&quot;] = msg.Id</span>
  })
end

--- Init market notice
--- @param marketProcessIds table The market process IDs
--- @param msg Message The message received
--- @return Message initMarketNotice The init market notice
<span class="fc" data-hits="1">function MarketFactoryNotices.initMarketNotice(marketProcessIds, msg)</span>
<span class="nc">  return msg.reply({</span>
    Action = &quot;Init-Market-Notice&quot;,
<span class="nc">    Data = json.encode(marketProcessIds)</span>
  })
end

--- Update configurator notice
--- @param configurator string The new configurator address
--- @param msg Message The message received
--- @return Message updateConfiguratorNotice The update configurator notice
<span class="fc" data-hits="1">function MarketFactoryNotices.updateConfiguratorNotice(configurator, msg)</span>
<span class="nc">  return msg.reply({</span>
    Action = &quot;Update-Configurator-Notice&quot;,
<span class="nc">    Data = configurator</span>
  })
end

--- Update lpFee notice
--- @param lpFee number The new lp fee
--- @param msg Message The message received
--- @return Message updateLpFeeNotice The update lp fee notice
<span class="fc" data-hits="1">function MarketFactoryNotices.updateLpFeeNotice(lpFee, msg)</span>
<span class="nc">  return msg.reply({</span>
    Action = &quot;Update-Lp-Fee-Notice&quot;,
<span class="nc">    Data = tostring(lpFee)</span>
  })
end

--- Update protocolFee notice
--- @param protocolFee number The new protocol fee
--- @param msg Message The message received
--- @return Message updateProtocolFeeNotice The update protocol fee notice
<span class="fc" data-hits="1">function MarketFactoryNotices.updateProtocolFeeNotice(protocolFee, msg)</span>
<span class="nc">  return msg.reply({</span>
    Action = &quot;Update-Protocol-Fee-Notice&quot;,
<span class="nc">    Data = tostring(protocolFee)</span>
  })
end

--- Update protocolFeeTarget notice
--- @param protocolFeeTarget string The new protocol fee target
--- @param msg Message The message received
--- @return Message updateProtocolFeeTargetNotice The update protocol fee target notice
<span class="fc" data-hits="1">function MarketFactoryNotices.updateProtocolFeeTargetNotice(protocolFeeTarget, msg)</span>
<span class="nc">  return msg.reply({</span>
    Action = &quot;Update-Protocol-Fee-Target-Notice&quot;,
<span class="nc">    Data = protocolFeeTarget</span>
  })
end

--- Update maximumTakeFee notice
--- @param maximumTakeFee number The new maximum take fee
--- @param msg Message The message received
--- @return Message updateMaximumTakeFeeNotice The update maximum take fee notice
<span class="fc" data-hits="1">function MarketFactoryNotices.updateMaximumTakeFeeNotice(maximumTakeFee, msg)</span>
<span class="nc">  return msg.reply({</span>
    Action = &quot;Update-Maximum-Take-Fee-Notice&quot;,
<span class="nc">    Data = tostring(maximumTakeFee)</span>
  })
end

--- Approve collateral token notice
--- @param collateralToken string The collateral token address
--- @param approved boolean The approval status, true if approved, false otherwise
--- @param msg Message The message received
--- @return Message approveCollateralTokenNotice The approve collateral token notice
<span class="fc" data-hits="1">function MarketFactoryNotices.approveCollateralTokenNotice(collateralToken, approved, msg)</span>
<span class="nc">  return msg.reply({</span>
    Action = &quot;Approve-Collateral-Token-Notice&quot;,
    CollateralToken = collateralToken,
    Approved = tostring(approved),
  })
end

--- Transfer notice
--- @param token string The token address
--- @param recipient string The recipient address
--- @param quantity string The quantity to transfer
--- @param msg Message The message received
--- @return Message transferNotice The transfer notice
<span class="fc" data-hits="1">function MarketFactoryNotices.transferNotice(token, recipient, quantity, msg)</span>
<span class="nc">  return msg.reply({</span>
    Action = &quot;Transfer-Notice&quot;,
    Token = token,
    Recipient = recipient,
<span class="nc">    Quantity = quantity</span>
  })
end

<span class="fc" data-hits="1">return MarketFactoryNotices</span>
</pre>
      </div>

      <div class="hidden file warning" id="src-marketfactorymodules-marketprocesscodev2">
         <h2 class="title">
            src/marketFactoryModules/marketProcessCodeV2.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 50.00%"></span>
                  <span><strong>50.00%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>1</strong> Hits</span>
               <span class="miss"><strong>1</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums"><span class="nc">return [===[</span>

-- module: &quot;marketModules.marketNotices&quot;
local function _loaded_mod_marketModules_marketNotices()
--[[
=========================================================
Part of the Outcome codebase © 2025. All Rights Reserved.
See market.lua for full license details.
=========================================================
]]

local MarketNotices = {}

--- Sends a update data index notice
--- @param dataIndex string The updated data index
--- @param msg Message The message received
--- @return Message The data index updated notice
function MarketNotices.updateDataIndexNotice(dataIndex, msg)
  return msg.reply({
    Action = &quot;Update-Data-Index-Notice&quot;,
    Data = dataIndex
  })
end

return MarketNotices
end

_G.package.loaded[&quot;marketModules.marketNotices&quot;] = _loaded_mod_marketModules_marketNotices()

-- module: &quot;json&quot;
local function _loaded_mod_json()
--
-- json.lua
--
-- Copyright (c) 2020 rxi
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of
-- this software and associated documentation files (the &quot;Software&quot;), to deal in
-- the Software without restriction, including without limitation the rights to
-- use, copy, modify, merge, publish, distribute, sublicense, and&#47;or sell copies
-- of the Software, and to permit persons to whom the Software is furnished to do
-- so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.
--

local json = { _version = &quot;0.1.2&quot; }

-------------------------------------------------------------------------------
-- Encode
-------------------------------------------------------------------------------

local encode

local escape_char_map = {
	[&quot;\\&quot;] = &quot;\\&quot;,
	[&#39;&quot;&#39;] = &#39;&quot;&#39;,
	[&quot;\b&quot;] = &quot;b&quot;,
	[&quot;\f&quot;] = &quot;f&quot;,
	[&quot;\n&quot;] = &quot;n&quot;,
	[&quot;\r&quot;] = &quot;r&quot;,
	[&quot;\t&quot;] = &quot;t&quot;,
}

local escape_char_map_inv = { [&quot;&#47;&quot;] = &quot;&#47;&quot; }
for k, v in pairs(escape_char_map) do
	escape_char_map_inv[v] = k
end

local function escape_char(c)
	return &quot;\\&quot; .. (escape_char_map[c] or string.format(&quot;u%04x&quot;, c:byte()))
end

local function encode_nil()
	return &quot;null&quot;
end

local function encode_table(val, stack)
	local res = {}
	stack = stack or {}

	-- Circular reference?
	if stack[val] then
		error(&quot;circular reference&quot;)
	end

	stack[val] = true

	if rawget(val, 1) ~= nil or next(val) == nil then
		-- Treat as array -- check keys are valid and it is not sparse
		local n = 0
		for k in pairs(val) do
			if type(k) ~= &quot;number&quot; then
				error(&quot;invalid table: mixed or invalid key types&quot;)
			end
			n = n + 1
		end
		if n ~= #val then
			error(&quot;invalid table: sparse array&quot;)
		end
		-- Encode
		for _, v in ipairs(val) do
			table.insert(res, encode(v, stack))
		end
		stack[val] = nil
		return &quot;[&quot; .. table.concat(res, &quot;,&quot;) .. &quot;]&quot;
	else
		-- Treat as an object
		for k, v in pairs(val) do
			if type(k) ~= &quot;string&quot; then
				error(&quot;invalid table: mixed or invalid key types&quot;)
			end
			table.insert(res, encode(k, stack) .. &quot;:&quot; .. encode(v, stack))
		end
		stack[val] = nil
		return &quot;{&quot; .. table.concat(res, &quot;,&quot;) .. &quot;}&quot;
	end
end

local function encode_string(val)
	return &#39;&quot;&#39; .. val:gsub(&#39;[%z\1-\31\\&quot;]&#39;, escape_char) .. &#39;&quot;&#39;
end

local function encode_number(val)
	-- Check for NaN, -inf and inf
	if val ~= val or val &lt;= -math.huge or val &gt;= math.huge then
		error(&quot;unexpected number value &#39;&quot; .. tostring(val) .. &quot;&#39;&quot;)
	end
	-- Handle integer values separately to avoid floating-point conversion
	if math.type(val) == &quot;integer&quot; then
		return string.format(&quot;%d&quot;, val) -- Format as an integer
	else
		-- Use 20 significant digits for non-integer numbers
		return string.format(&quot;%.20g&quot;, val)
	end
end

local type_func_map = {
	[&quot;nil&quot;] = encode_nil,
	[&quot;table&quot;] = encode_table,
	[&quot;string&quot;] = encode_string,
	[&quot;number&quot;] = encode_number,
	[&quot;boolean&quot;] = tostring,
}

encode = function(val, stack)
	local t = type(val)
	local f = type_func_map[t]
	if f then
		return f(val, stack)
	end
	error(&quot;unexpected type &#39;&quot; .. t .. &quot;&#39;&quot;)
end

function json.encode(val)
	return (encode(val))
end

-------------------------------------------------------------------------------
-- Decode
-------------------------------------------------------------------------------

local parse

local function create_set(...)
	local res = {}
	for i = 1, select(&quot;#&quot;, ...) do
		res[select(i, ...)] = true
	end
	return res
end

local space_chars = create_set(&quot; &quot;, &quot;\t&quot;, &quot;\r&quot;, &quot;\n&quot;)
local delim_chars = create_set(&quot; &quot;, &quot;\t&quot;, &quot;\r&quot;, &quot;\n&quot;, &quot;]&quot;, &quot;}&quot;, &quot;,&quot;)
local escape_chars = create_set(&quot;\\&quot;, &quot;&#47;&quot;, &#39;&quot;&#39;, &quot;b&quot;, &quot;f&quot;, &quot;n&quot;, &quot;r&quot;, &quot;t&quot;, &quot;u&quot;)
local literals = create_set(&quot;true&quot;, &quot;false&quot;, &quot;null&quot;)

local literal_map = {
	[&quot;true&quot;] = true,
	[&quot;false&quot;] = false,
	[&quot;null&quot;] = nil,
}

local function next_char(str, idx, set, negate)
	for i = idx, #str do
		if set[str:sub(i, i)] ~= negate then
			return i
		end
	end
	return #str + 1
end

local function decode_error(str, idx, msg)
	local line_count = 1
	local col_count = 1
	for i = 1, idx - 1 do
		col_count = col_count + 1
		if str:sub(i, i) == &quot;\n&quot; then
			line_count = line_count + 1
			col_count = 1
		end
	end
	error(string.format(&quot;%s at line %d col %d&quot;, msg, line_count, col_count))
end

local function codepoint_to_utf8(n)
	-- http:&#47;&#47;scripts.sil.org&#47;cms&#47;scripts&#47;page.php?site_id=nrsi&amp;id=iws-appendixa
	local f = math.floor
	if n &lt;= 0x7f then
		return string.char(n)
	elseif n &lt;= 0x7ff then
		return string.char(f(n &#47; 64) + 192, n % 64 + 128)
	elseif n &lt;= 0xffff then
		return string.char(f(n &#47; 4096) + 224, f(n % 4096 &#47; 64) + 128, n % 64 + 128)
	elseif n &lt;= 0x10ffff then
		return string.char(f(n &#47; 262144) + 240, f(n % 262144 &#47; 4096) + 128, f(n % 4096 &#47; 64) + 128, n % 64 + 128)
	end
	error(string.format(&quot;invalid unicode codepoint &#39;%x&#39;&quot;, n))
end

local function parse_unicode_escape(s)
	local n1 = tonumber(s:sub(1, 4), 16)
	local n2 = tonumber(s:sub(7, 10), 16)
	-- Surrogate pair?
	if n2 then
		return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
	else
		return codepoint_to_utf8(n1)
	end
end

local function parse_string(str, i)
	local res = &quot;&quot;
	local j = i + 1
	local k = j

	while j &lt;= #str do
		local x = str:byte(j)

		if x &lt; 32 then
			decode_error(str, j, &quot;control character in string&quot;)
		elseif x == 92 then -- `\`: Escape
			res = res .. str:sub(k, j - 1)
			j = j + 1
			local c = str:sub(j, j)
			if c == &quot;u&quot; then
				local hex = str:match(&quot;^[dD][89aAbB]%x%x\\u%x%x%x%x&quot;, j + 1)
					or str:match(&quot;^%x%x%x%x&quot;, j + 1)
					or decode_error(str, j - 1, &quot;invalid unicode escape in string&quot;)
				res = res .. parse_unicode_escape(hex)
				j = j + #hex
			else
				if not escape_chars[c] then
					decode_error(str, j - 1, &quot;invalid escape char &#39;&quot; .. c .. &quot;&#39; in string&quot;)
				end
				res = res .. escape_char_map_inv[c]
			end
			k = j + 1
		elseif x == 34 then -- `&quot;`: End of string
			res = res .. str:sub(k, j - 1)
			return res, j + 1
		end

		j = j + 1
	end

	decode_error(str, i, &quot;expected closing quote for string&quot;)
end

local function parse_number(str, i)
	local x = next_char(str, i, delim_chars)
	local s = str:sub(i, x - 1)
	local n = tonumber(s)
	if not n then
		decode_error(str, i, &quot;invalid number &#39;&quot; .. s .. &quot;&#39;&quot;)
	end
	return n, x
end

local function parse_literal(str, i)
	local x = next_char(str, i, delim_chars)
	local word = str:sub(i, x - 1)
	if not literals[word] then
		decode_error(str, i, &quot;invalid literal &#39;&quot; .. word .. &quot;&#39;&quot;)
	end
	return literal_map[word], x
end

local function parse_array(str, i)
	local res = {}
	local n = 1
	i = i + 1
	while 1 do
		local x
		i = next_char(str, i, space_chars, true)
		-- Empty &#47; end of array?
		if str:sub(i, i) == &quot;]&quot; then
			i = i + 1
			break
		end
		-- Read token
		x, i = parse(str, i)
		res[n] = x
		n = n + 1
		-- Next token
		i = next_char(str, i, space_chars, true)
		local chr = str:sub(i, i)
		i = i + 1
		if chr == &quot;]&quot; then
			break
		end
		if chr ~= &quot;,&quot; then
			decode_error(str, i, &quot;expected &#39;]&#39; or &#39;,&#39;&quot;)
		end
	end
	return res, i
end

local function parse_object(str, i)
	local res = {}
	i = i + 1
	while 1 do
		local key, val
		i = next_char(str, i, space_chars, true)
		-- Empty &#47; end of object?
		if str:sub(i, i) == &quot;}&quot; then
			i = i + 1
			break
		end
		-- Read key
		if str:sub(i, i) ~= &#39;&quot;&#39; then
			decode_error(str, i, &quot;expected string for key&quot;)
		end
		key, i = parse(str, i)
		-- Read &#39;:&#39; delimiter
		i = next_char(str, i, space_chars, true)
		if str:sub(i, i) ~= &quot;:&quot; then
			decode_error(str, i, &quot;expected &#39;:&#39; after key&quot;)
		end
		i = next_char(str, i + 1, space_chars, true)
		-- Read value
		val, i = parse(str, i)
		-- Set
		res[key] = val
		-- Next token
		i = next_char(str, i, space_chars, true)
		local chr = str:sub(i, i)
		i = i + 1
		if chr == &quot;}&quot; then
			break
		end
		if chr ~= &quot;,&quot; then
			decode_error(str, i, &quot;expected &#39;}&#39; or &#39;,&#39;&quot;)
		end
	end
	return res, i
end

local char_func_map = {
	[&#39;&quot;&#39;] = parse_string,
	[&quot;0&quot;] = parse_number,
	[&quot;1&quot;] = parse_number,
	[&quot;2&quot;] = parse_number,
	[&quot;3&quot;] = parse_number,
	[&quot;4&quot;] = parse_number,
	[&quot;5&quot;] = parse_number,
	[&quot;6&quot;] = parse_number,
	[&quot;7&quot;] = parse_number,
	[&quot;8&quot;] = parse_number,
	[&quot;9&quot;] = parse_number,
	[&quot;-&quot;] = parse_number,
	[&quot;t&quot;] = parse_literal,
	[&quot;f&quot;] = parse_literal,
	[&quot;n&quot;] = parse_literal,
	[&quot;[&quot;] = parse_array,
	[&quot;{&quot;] = parse_object,
}

parse = function(str, idx)
	local chr = str:sub(idx, idx)
	local f = char_func_map[chr]
	if f then
		return f(str, idx)
	end
	decode_error(str, idx, &quot;unexpected character &#39;&quot; .. chr .. &quot;&#39;&quot;)
end

function json.decode(str)
	if type(str) ~= &quot;string&quot; then
		error(&quot;expected argument of type string, got &quot; .. type(str))
	end
	local res, idx = parse(str, next_char(str, 1, space_chars, true))
	idx = next_char(str, idx, space_chars, true)
	if idx &lt;= #str then
		decode_error(str, idx, &quot;trailing garbage&quot;)
	end
	return res
end

return json

end

_G.package.loaded[&quot;json&quot;] = _loaded_mod_json()

-- module: &quot;marketModules.cpmmHelpers&quot;
local function _loaded_mod_marketModules_cpmmHelpers()
--[[
=========================================================
Part of the Outcome codebase © 2025. All Rights Reserved.
See cpmm.lua for full license details.
=========================================================
]]

local CPMMHelpers = {}

--- Calculate the ceildiv of x &#47; y
--- @param x number The numerator
--- @param y number The denominator
--- @return number The ceil div of x &#47; y
function CPMMHelpers.ceildiv(x, y)
  if x &gt; 0 then
    return math.floor((x - 1) &#47; y) + 1
  end
  return math.floor(x &#47; y)
end

--- Generate position IDs
--- @param outcomeSlotCount number The number of outcome slots
--- @return table&lt;string&gt; A basic partition based on outcomeSlotCount
function CPMMHelpers.getPositionIds(outcomeSlotCount)
  local positionIds = {}
  for i = 1, outcomeSlotCount do
    table.insert(positionIds, tostring(i))
  end
  return positionIds
end

--- Gets pool balances
--- @return table&lt;string&gt; Pool balances for each ID
function CPMMHelpers:getPoolBalances()
  -- Get poolBalances
  local selves = {}
  for _ = 1, #self.tokens.positionIds do
    table.insert(selves, ao.id)
  end
  local poolBalances = self.tokens:getBatchBalance(selves, self.tokens.positionIds)
  return poolBalances
end

return CPMMHelpers
end

_G.package.loaded[&quot;marketModules.cpmmHelpers&quot;] = _loaded_mod_marketModules_cpmmHelpers()

-- module: &quot;marketModules.cpmmNotices&quot;
local function _loaded_mod_marketModules_cpmmNotices()
--[[
=========================================================
Part of the Outcome codebase © 2025. All Rights Reserved.
See cpmm.lua for full license details.
=========================================================
]]

-- local ao = require(&#39;.ao&#39;) @dev required for unit tests?
local json = require(&#39;json&#39;)

local CPMMNotices = {}

--- Sends an add funding notice
--- @param fundingAdded table The funding added
--- @param mintAmount number The mint amount
--- @param msg Message The message received
--- @return Message The funding added notice
function CPMMNotices.addFundingNotice(fundingAdded, mintAmount, msg)
  return msg.forward(msg.Tags.Sender, {
    Action = &quot;Add-Funding-Notice&quot;,
    FundingAdded = json.encode(fundingAdded),
    MintAmount = tostring(mintAmount),
    Data = &quot;Successfully added funding&quot;
  })
end

--- Sends a remove funding notice
--- @param sendAmounts table The send amounts
--- @param collateralRemovedFromFeePool string The collateral removed from the fee pool
--- @param sharesToBurn string The shares to burn
--- @param msg Message The message received
--- @return Message The funding removed notice
function CPMMNotices.removeFundingNotice(sendAmounts, collateralRemovedFromFeePool, sharesToBurn, msg)
  return msg.reply({
    Action = &quot;Remove-Funding-Notice&quot;,
    SendAmounts = json.encode(sendAmounts),
    CollateralRemovedFromFeePool = collateralRemovedFromFeePool,
    SharesToBurn = sharesToBurn,
    Data = &quot;Successfully removed funding&quot;
  })
end

--- Sends a buy notice
--- @param from string The address that bought
--- @param onBehalfOf string The address that receives the outcome tokens
--- @param investmentAmount number The investment amount
--- @param feeAmount number The fee amount
--- @param positionId string The position ID
--- @param positionTokensBought number The outcome position tokens bought
--- @param msg Message The message received
--- @return Message The buy notice
function CPMMNotices.buyNotice(from, onBehalfOf, investmentAmount, feeAmount, positionId, positionTokensBought, msg)
  return msg.forward(from, {
    Action = &quot;Buy-Notice&quot;,
    OnBehalfOf = onBehalfOf,
    InvestmentAmount = tostring(investmentAmount),
    FeeAmount = tostring(feeAmount),
    PositionId = positionId,
    PositionTokensBought = tostring(positionTokensBought),
    Data = &quot;Successful buy order&quot;
  })
end

--- Sends a sell notice
--- @param from string The address that sold
--- @param returnAmount number The return amount
--- @param feeAmount number The fee amount
--- @param positionId string The position ID
--- @param positionTokensSold number The outcome position tokens sold
--- @param msg Message The message received
--- @return Message The sell notice
function CPMMNotices.sellNotice(from, returnAmount, feeAmount, positionId, positionTokensSold, msg)
  return msg.forward(from, {
    Action = &quot;Sell-Notice&quot;,
    ReturnAmount = tostring(returnAmount),
    FeeAmount = tostring(feeAmount),
    PositionId = positionId,
    PositionTokensSold = tostring(positionTokensSold),
    Data = &quot;Successful sell order&quot;
  })
end

--- Sends a withdraw fees notice
--- @notice Returns notice with `msg.reply` if `useReply` is true, otherwise uses `ao.send`
--- @dev Ensures the final notice is sent to the user, preventing unintended message handling
--- @param feeAmount number The fee amount
--- @param msg Message The message received
--- @param useReply boolean Whether to use `msg.reply` or `ao.send`
--- @return Message The withdraw fees notice
function CPMMNotices.withdrawFeesNotice(feeAmount, msg, useReply)
  local notice = {
    Action = &quot;Withdraw-Fees-Notice&quot;,
    FeeAmount = tostring(feeAmount),
    Data = &quot;Successfully withdrew fees&quot;
  }
  if useReply then return msg.reply(notice) end
  notice.Target = msg.Sender and msg.Sender or msg.From
  return ao.send(notice)
end

--- Sends an update configurator notice
--- @param configurator string The updated configurator address
--- @param msg Message The message received
--- @return Message The configurator updated notice
function CPMMNotices.updateConfiguratorNotice(configurator, msg)
  return msg.reply({
    Action = &quot;Update-Configurator-Notice&quot;,
    Data = configurator
  })
end

--- Sends an update take fee notice
--- @param creatorFee string The updated creator fee
--- @param protocolFee string The updated protocol fee
--- @param takeFee string The updated take fee
--- @param msg Message The message received
function CPMMNotices.updateTakeFeeNotice(creatorFee, protocolFee, takeFee, msg)
  return msg.reply({
    Action = &quot;Update-Take-Fee-Notice&quot;,
    CreatorFee = tostring(creatorFee),
    ProtocolFee = tostring(protocolFee),
    Data = tostring(takeFee)
  })
end

--- Sends an update protocol fee target notice
--- @param protocolFeeTarget string The updated protocol fee target
--- @param msg Message The message received
--- @return Message The protocol fee target updated notice
function CPMMNotices.updateProtocolFeeTargetNotice(protocolFeeTarget, msg)
  return msg.reply({
    Action = &quot;Update-Protocol-Fee-Target-Notice&quot;,
    Data = protocolFeeTarget
  })
end

--- Sends an update logo notice
--- @param logo string The updated logo
--- @param msg Message The message received
--- @return Message The logo updated notice
function CPMMNotices.updateLogoNotice(logo, msg)
  return msg.reply({
    Action = &quot;Update-Logo-Notice&quot;,
    Data = logo
  })
end

return CPMMNotices
end

_G.package.loaded[&quot;marketModules.cpmmNotices&quot;] = _loaded_mod_marketModules_cpmmNotices()

-- module: &quot;.utils&quot;
local function _loaded_mod_utils()
--- The Utils module provides a collection of utility functions for functional programming in Lua. It includes functions for array manipulation such as concatenation, mapping, reduction, filtering, and finding elements, as well as a property equality checker.
-- @module utils

--- The utils table
-- @table utils
-- @field _version The version number of the utils module
-- @field matchesPattern The matchesPattern function
-- @field matchesSpec The matchesSpec function
-- @field curry The curry function
-- @field concat The concat function
-- @field reduce The reduce function
-- @field map The map function
-- @field filter The filter function
-- @field find The find function
-- @field propEq The propEq function
-- @field reverse The reverse function
-- @field compose The compose function
-- @field prop The prop function
-- @field includes The includes function
-- @field keys The keys function
-- @field values The values function
local utils = { _version = &quot;0.0.5&quot; }

--- Given a pattern, a value, and a message, returns whether there is a pattern match.
-- @usage utils.matchesPattern(pattern, value, msg)
-- @param pattern The pattern to match
-- @param value The value to check for in the pattern
-- @param msg The message to check for the pattern
-- @treturn {boolean} Whether there is a pattern match
function utils.matchesPattern(pattern, value, msg)
  -- If the key is not in the message, then it does not match
  if (not pattern) then
    return false
  end
  -- if the patternMatchSpec is a wildcard, then it always matches
  if pattern == &#39;_&#39; then
    return true
  end
  -- if the patternMatchSpec is a function, then it is executed on the tag value
  if type(pattern) == &quot;function&quot; then
    if pattern(value, msg) then
      return true
    else
      return false
    end
  end
  
  -- if the patternMatchSpec is a string, check it for special symbols (less `-` alone)
  -- and exact string match mode
  if (type(pattern) == &#39;string&#39;) then
    if string.match(pattern, &quot;[%^%$%(%)%%%.%[%]%*%+%?]&quot;) then
      if string.match(value, pattern) then
        return true
      end
    else
      if value == pattern then
        return true
      end
    end
  end

  -- if the pattern is a table, recursively check if any of its sub-patterns match
  if type(pattern) == &#39;table&#39; then
    for _, subPattern in pairs(pattern) do
      if utils.matchesPattern(subPattern, value, msg) then
        return true
      end
    end
  end

  return false
end

--- Given a message and a spec, returns whether there is a spec match.
-- @usage utils.matchesSpec(msg, spec)
-- @param msg The message to check for the spec
-- @param spec The spec to check for in the message
-- @treturn {boolean} Whether there is a spec match
function utils.matchesSpec(msg, spec)
  if type(spec) == &#39;function&#39; then
    return spec(msg)
  -- If the spec is a table, step through every key&#47;value pair in the pattern and check if the msg matches
  -- Supported pattern types:
  --   - Exact string match
  --   - Lua gmatch string
  --   - &#39;_&#39; (wildcard: Message has tag, but can be any value)
  --   - Function execution on the tag, optionally using the msg as the second argument
  --   - Table of patterns, where ANY of the sub-patterns matching the tag will result in a match
  end
  if type(spec) == &#39;table&#39; then
    for key, pattern in pairs(spec) do
      -- The key can either be in the top level of the &#39;msg&#39; object or within the &#39;Tags&#39; 

      local msgValue = msg[key]
      local msgTagValue = msg[&#39;Tags&#39;] and msg[&#39;Tags&#39;][key]
  
      if not msgValue and not msgTagValue then
        return false
      end
  
      local matchesMsgValue = utils.matchesPattern(pattern, msgValue, msg)
      local matchesMsgTagValue = utils.matchesPattern(pattern, msgTagValue, msg)
  
      if not matchesMsgValue and not matchesMsgTagValue then
        return false
      end
    end
    return true
  end
  
  if type(spec) == &#39;string&#39; and msg.Action and msg.Action == spec then
    return true
  end
  return false
end

--- Given a table, returns whether it is an array.
-- An &#39;array&#39; is defined as a table with integer keys starting from 1 and
-- having no gaps between the keys.
-- @lfunction isArray
-- @param table The table to check
-- @treturn {boolean} Whether the table is an array
local function isArray(table)
  if type(table) == &quot;table&quot; then
      local maxIndex = 0
      for k, v in pairs(table) do
          if type(k) ~= &quot;number&quot; or k &lt; 1 or math.floor(k) ~= k then
              return false -- If there&#39;s a non-integer key, it&#39;s not an array
          end
          maxIndex = math.max(maxIndex, k)
      end
      -- If the highest numeric index is equal to the number of elements, it&#39;s an array
      return maxIndex == #table
  end
  return false
end

--- Curries a function.
-- @tparam {function} fn The function to curry
-- @tparam {number} arity The arity of the function
-- @treturn {function} The curried function
utils.curry = function (fn, arity)
  assert(type(fn) == &quot;function&quot;, &quot;function is required as first argument&quot;)
  arity = arity or debug.getinfo(fn, &quot;u&quot;).nparams
  if arity &lt; 2 then return fn end

  return function (...)
    local args = {...}

    if #args &gt;= arity then
      return fn(table.unpack(args))
    else
      return utils.curry(function (...)
        return fn(table.unpack(args),  ...)
      end, arity - #args)
    end
  end
end

--- Concat two Array Tables
-- @function concat
-- @usage utils.concat(a)(b)
-- @usage utils.concat({1, 2})({3, 4}) --&gt; {1, 2, 3, 4}
-- @tparam {table&lt;Array&gt;} a The first array
-- @tparam {table&lt;Array&gt;} b The second array
-- @treturn {table&lt;Array&gt;} The concatenated array
utils.concat = utils.curry(function (a, b)
  assert(type(a) == &quot;table&quot;, &quot;first argument should be a table that is an array&quot;)
  assert(type(b) == &quot;table&quot;, &quot;second argument should be a table that is an array&quot;)
  assert(isArray(a), &quot;first argument should be a table&quot;)
  assert(isArray(b), &quot;second argument should be a table&quot;)

  local result = {}
  for i = 1, #a do
      result[#result + 1] = a[i]
  end
  for i = 1, #b do
      result[#result + 1] = b[i]
  end
  return result
end, 2)

--- Applies a function to each element of a table, reducing it to a single value.
-- @function utils.reduce
-- @usage utils.reduce(fn)(initial)(t)
-- @usage utils.reduce(function(acc, x) return acc + x end)(0)({1, 2, 3}) --&gt; 6
-- @tparam {function} fn The function to apply
-- @param initial The initial value
-- @tparam {table&lt;Array&gt;} t The table to reduce
-- @return The reduced value
utils.reduce = utils.curry(function (fn, initial, t)
  assert(type(fn) == &quot;function&quot;, &quot;first argument should be a function that accepts (result, value, key)&quot;)
  assert(type(t) == &quot;table&quot; and isArray(t), &quot;third argument should be a table that is an array&quot;)
  local result = initial
  for k, v in pairs(t) do
    if result == nil then
      result = v
    else
      result = fn(result, v, k)
    end
  end
  return result
end, 3)

--- Applies a function to each element of an array table, mapping it to a new value.
-- @function utils.map
-- @usage utils.map(fn)(t)
-- @usage utils.map(function(x) return x * 2 end)({1, 2, 3}) --&gt; {2, 4, 6}
-- @tparam {function} fn The function to apply to each element
-- @tparam {table&lt;Array&gt;} data The table to map over
-- @treturn {table&lt;Array&gt;} The mapped table
utils.map = utils.curry(function (fn, data)
  assert(type(fn) == &quot;function&quot;, &quot;first argument should be a unary function&quot;)
  assert(type(data) == &quot;table&quot; and isArray(data), &quot;second argument should be an Array&quot;)

  local function map (result, v, k)
    result[k] = fn(v, k)
    return result
  end

  return utils.reduce(map, {}, data)
end, 2)

--- Filters an array table based on a predicate function.
-- @function utils.filter
-- @usage utils.filter(fn)(t)
-- @usage utils.filter(function(x) return x &gt; 1 end)({1, 2, 3}) --&gt; {2,3}
-- @tparam {function} fn The predicate function to determine if an element should be included.
-- @tparam {table&lt;Array&gt;} data The array to filter
-- @treturn {table&lt;Array&gt;} The filtered table
utils.filter = utils.curry(function (fn, data)
  assert(type(fn) == &quot;function&quot;, &quot;first argument should be a unary function&quot;)
  assert(type(data) == &quot;table&quot; and isArray(data), &quot;second argument should be an Array&quot;)

  local function filter (result, v, _k)
    if fn(v) then
      table.insert(result, v)
    end
    return result
  end

  return utils.reduce(filter,{}, data)
end, 2)

--- Finds the first element in an array table that satisfies a predicate function.
-- @function utils.find
-- @usage utils.find(fn)(t)
-- @usage utils.find(function(x) return x &gt; 1 end)({1, 2, 3}) --&gt; 2
-- @tparam {function} fn The predicate function to determine if an element should be included.
-- @tparam {table&lt;Array&gt;} t The array table to search
-- @treturn The first element that satisfies the predicate function
utils.find = utils.curry(function (fn, t)
  assert(type(fn) == &quot;function&quot;, &quot;first argument should be a unary function&quot;)
  assert(type(t) == &quot;table&quot;, &quot;second argument should be a table that is an array&quot;)
  for _, v in pairs(t) do
    if fn(v) then
      return v
    end
  end
end, 2)

--- Checks if a property of an object is equal to a value.
-- @function utils.propEq
-- @usage utils.propEq(propName)(value)(object)
-- @usage utils.propEq(&quot;name&quot;)(&quot;Lua&quot;)({name = &quot;Lua&quot;}) --&gt; true
-- @tparam {string} propName The property name to check
-- @tparam {string} value The value to check against
-- @tparam {table} object The object to check
-- @treturn {boolean} Whether the property is equal to the value
utils.propEq = utils.curry(function (propName, value, object)
  assert(type(propName) == &quot;string&quot;, &quot;first argument should be a string&quot;)
  assert(type(value) == &quot;string&quot;, &quot;second argument should be a string&quot;)
  assert(type(object) == &quot;table&quot;, &quot;third argument should be a table&lt;object&gt;&quot;)
  
  return object[propName] == value
end, 3)

--- Reverses an array table.
-- @function utils.reverse
-- @usage utils.reverse(data)
-- @usage utils.reverse({1, 2, 3}) --&gt; {3, 2, 1}
-- @tparam {table&lt;Array&gt;} data The array table to reverse
-- @treturn {table&lt;Array&gt;} The reversed array table
utils.reverse = function (data)
  assert(type(data) == &quot;table&quot;, &quot;argument needs to be a table that is an array&quot;)
  return utils.reduce(
    function (result, v, i)
      result[#data - i + 1] = v
      return result
    end,
    {},
    data
  )
end

--- Composes a series of functions into a single function.
-- @function utils.compose
-- @usage utils.compose(fn1)(fn2)(fn3)(v)
-- @usage utils.compose(function(x) return x + 1 end)(function(x) return x * 2 end)(3) --&gt; 7
-- @tparam {function} ... The functions to compose
-- @treturn {function} The composed function
utils.compose = utils.curry(function (...)
  local mutations = utils.reverse({...})

  return function (v)
    local result = v
    for _, fn in pairs(mutations) do
      assert(type(fn) == &quot;function&quot;, &quot;each argument needs to be a function&quot;)
      result = fn(result)
    end
    return result
  end
end, 2)

--- Returns the value of a property of an object.
-- @function utils.prop
-- @usage utils.prop(propName)(object)
-- @usage utils.prop(&quot;name&quot;)({name = &quot;Lua&quot;}) --&gt; &quot;Lua&quot;
-- @tparam {string} propName The property name to get
-- @tparam {table} object The object to get the property from
-- @treturn The value of the property
utils.prop = utils.curry(function (propName, object) 
  return object[propName]
end, 2)

--- Checks if an array table includes a value.
-- @function utils.includes
-- @usage utils.includes(val)(t)
-- @usage utils.includes(2)({1, 2, 3}) --&gt; true
-- @param val The value to check for
-- @tparam {table&lt;Array&gt;} t The array table to check
-- @treturn {boolean} Whether the value is in the array table
utils.includes = utils.curry(function (val, t)
  assert(type(t) == &quot;table&quot;, &quot;argument needs to be a table&quot;)
  assert(isArray(t), &quot;argument should be a table that is an array&quot;)
  return utils.find(function (v) return v == val end, t) ~= nil
end, 2)

--- Returns the keys of a table.
-- @usage utils.keys(t)
-- @usage utils.keys({name = &quot;Lua&quot;, age = 25}) --&gt; {&quot;name&quot;, &quot;age&quot;}
-- @tparam {table} t The table to get the keys from
-- @treturn {table&lt;Array&gt;} The keys of the table
utils.keys = function (t)
  assert(type(t) == &quot;table&quot;, &quot;argument needs to be a table&quot;)
  local keys = {}
  for key in pairs(t) do
    table.insert(keys, key)
  end
  return keys
end

--- Returns the values of a table.
-- @usage utils.values(t)
-- @usage utils.values({name = &quot;Lua&quot;, age = 25}) --&gt; {&quot;Lua&quot;, 25}
-- @tparam {table} t The table to get the values from
-- @treturn {table&lt;Array&gt;} The values of the table
utils.values = function (t)
  assert(type(t) == &quot;table&quot;, &quot;argument needs to be a table&quot;)
  local values = {}
  for _, value in pairs(t) do
    table.insert(values, value)
  end
  return values
end

return utils
end

_G.package.loaded[&quot;.utils&quot;] = _loaded_mod_utils()

-- module: &quot;marketModules.tokenNotices&quot;
local function _loaded_mod_marketModules_tokenNotices()
--[[
=========================================================
Part of the Outcome codebase © 2025. All Rights Reserved.
See tokens.lua for full license details.
=========================================================
]]

-- local ao = require(&#39;.ao&#39;) @dev required for unit tests?
local TokenNotices = {}

--- Mint notice
--- @param recipient string The address that will own the minted tokens
--- @param quantity string The quantity of tokens to mint
--- @param msg Message The message received
--- @return Message The mint notice
function TokenNotices.mintNotice(recipient, quantity, msg)
  return msg.forward(recipient, {
    Recipient = recipient,
    Quantity = tostring(quantity),
    Action = &#39;Mint-Notice&#39;,
    Data = Colors.gray .. &quot;Successfully minted &quot; .. Colors.blue .. tostring(quantity) .. Colors.reset
  })
end

--- Burn notice
--- @param quantity string The quantity of tokens to burn
--- @param msg Message The message received
--- @return Message The burn notice
function TokenNotices.burnNotice(quantity, msg)
  return ao.send({
    Target = msg.Sender and msg.Sender or msg.From,
    Quantity = tostring(quantity),
    Action = &#39;Burn-Notice&#39;,
    Data = Colors.gray .. &quot;Successfully burned &quot; .. Colors.blue .. tostring(quantity) .. Colors.reset
  })
end

--- Transfer notices
--- @param debitNotice Message The notice to send the spender
--- @param creditNotice Message The notice to send the receiver
--- @param recipient string The address that will receive the tokens
--- @param msg Message The mesage received
--- @return table&lt;Message&gt; The transfer notices
function TokenNotices.transferNotices(debitNotice, creditNotice, recipient, msg)
  return { msg.reply(debitNotice), msg.forward(recipient, creditNotice) }
end

--- Transfer error notice
--- @param msg Message The mesage received
--- @return Message The transfer error notice
function TokenNotices.transferErrorNotice(msg)
  return msg.reply({
    Action = &#39;Transfer-Error&#39;,
    [&#39;Message-Id&#39;] = msg.Id,
    Error = &#39;Insufficient Balance!&#39;
  })
end

return TokenNotices
end

_G.package.loaded[&quot;marketModules.tokenNotices&quot;] = _loaded_mod_marketModules_tokenNotices()

-- module: &quot;marketModules.token&quot;
local function _loaded_mod_marketModules_token()
--[[
================================================================================
Module: token.lua
Adapted from the AO Cookbook Token Blueprint:
https:&#47;&#47;cookbook_ao.g8way.io&#47;guides&#47;aos&#47;blueprints&#47;token.html
Licensed under the Business Source License 1.1 (BSL 1.1)
================================================================================

Licensor:          Forward Research
Licensed Work:     aos codebase. The Licensed Work is (c) 2024 Forward Research
Official License:  https:&#47;&#47;github.com&#47;permaweb&#47;aos&#47;blob&#47;main&#47;LICENSE
Additional Use Grant:
  The aos codebases are offered under the BSL 1.1 license for the duration
  of the testnet period. After the testnet phase is over, the code will be
  made available under either a new evolutionary forking license or a
  traditional OSS license (GPLv3&#47;v2, MIT, etc).
  More info: https:&#47;&#47;arweave.medium.com&#47;arweave-is-an-evolutionary-protocol-e072f5e69eaa
Change Date:       Four years from the date the Licensed Work is published.
Change License:    MPL 2.0

Notice:
This code is provided under the Business Source License 1.1. Redistribution,
modification, or unauthorized use of this code must comply with the terms of
the Business Source License.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, AND NONINFRINGEMENT.
================================================================================
]]

local Token = {}
local TokenMethods = {}
local TokenNotices = require(&#39;marketModules.tokenNotices&#39;)
local bint = require(&#39;.bint&#39;)(256)

--- Represents a Token
--- @class Token
--- @field name string The token name
--- @field ticker string The token ticker
--- @field logo string The token logo Arweave TxID
--- @field balances table&lt;string, string&gt; The user token balances
--- @field totalSupply string The total supply of the token
--- @field denomination number The number of decimals

--- Creates a new Token instance
--- @param name string The token name
--- @param ticker string The token ticker
--- @param logo string The token logo Arweave TxID
--- @param balances table&lt;string, string&gt; The user token balances
--- @param totalSupply string The total supply of the token
--- @param denomination number The number of decimals
--- @return Token token The new Token instance
function Token.new(name, ticker, logo, balances, totalSupply, denomination)
  local token = {
    name = name,
    ticker = ticker,
    logo = logo,
    balances = balances,
    totalSupply = totalSupply,
    denomination = denomination
  }
  setmetatable(token, {
    __index = function(_, k)
      if TokenMethods[k] then
        return TokenMethods[k]
      elseif TokenNotices[k] then
        return TokenNotices[k]
      else
        return nil
      end
    end
  })
  return token
end

--- Mint a quantity of tokens
--- @param to string The address that will own the minted tokens
--- @param quantity string The quantity of tokens to mint
--- @param msg Message The message received
--- @return Message The mint notice
function TokenMethods:mint(to, quantity, msg)
  assert(quantity, &#39;Quantity is required!&#39;)
  assert(bint.__lt(0, bint(quantity)), &#39;Quantity must be greater than zero!&#39;)
  -- Mint tokens
  if not self.balances[to] then self.balances[to] = &#39;0&#39; end
  self.balances[to] = tostring(bint.__add(bint(self.balances[to]), bint(quantity)))
  self.totalSupply = tostring(bint.__add(bint(self.totalSupply), bint(quantity)))
  -- Send notice
  return self.mintNotice(to, quantity, msg)
end

--- Burn a quantity of tokens
--- @param from string The process ID that will no longer own the burned tokens
--- @param quantity string The quantity of tokens to burn
--- @param msg Message The message received
--- @return Message The burn notice
function TokenMethods:burn(from, quantity, msg)
  assert(bint.__lt(0, bint(quantity)), &#39;Quantity must be greater than zero!&#39;)
  assert(self.balances[from], &#39;Must have token balance!&#39;)
  assert(bint.__le(bint(quantity), self.balances[from]), &#39;Must have sufficient tokens!&#39;)
  -- Burn tokens
  self.balances[from] = tostring(bint.__sub(self.balances[from], bint(quantity)))
  self.totalSupply = tostring(bint.__sub(bint(self.totalSupply), bint(quantity)))
  -- Send notice
  return self.burnNotice(quantity, msg)
end

--- Transfer a quantity of tokens
--- @param from string The process ID that will send the token
--- @param recipient string The process ID that will receive the token
--- @param quantity string The quantity of tokens to transfer
--- @param cast boolean The cast is set to true to silence the transfer notice
--- @param msg Message The message received
--- @return table&lt;Message&gt;|Message|nil The transfer notices, error notice or nothing
function TokenMethods:transfer(from, recipient, quantity, cast, msg)
  if not self.balances[from] then self.balances[from] = &quot;0&quot; end
  if not self.balances[recipient] then self.balances[recipient] = &quot;0&quot; end

  local qty = bint(quantity)
  local balance = bint(self.balances[from])

  if bint.__le(qty, balance) then
    self.balances[from] = tostring(bint.__sub(balance, qty))
    self.balances[recipient] = tostring(bint.__add(self.balances[recipient], qty))

    -- Only send the notifications to the Sender and Recipient
    -- if the Cast tag is not set on the Transfer message
    if not cast then
      -- Debit-Notice message template, that is sent to the Sender of the transfer
      local debitNotice = {
        Action = &#39;Debit-Notice&#39;,
        Recipient = recipient,
        Quantity = quantity,
        Data = Colors.gray ..
            &quot;You transferred &quot; ..
            Colors.blue .. quantity .. Colors.gray .. &quot; to &quot; .. Colors.green .. recipient .. Colors.reset
      }
      -- Credit-Notice message template, that is sent to the Recipient of the transfer
      local creditNotice = {
        Action = &#39;Credit-Notice&#39;,
        Sender = from,
        Quantity = quantity,
        Data = Colors.gray ..
            &quot;You received &quot; ..
            Colors.blue .. quantity .. Colors.gray .. &quot; from &quot; .. Colors.green .. from .. Colors.reset
      }

      -- Add forwarded tags to the credit and debit notice messages
      for tagName, tagValue in pairs(msg.Tags) do
        -- Tags beginning with &quot;X-&quot; are forwarded
        if string.sub(tagName, 1, 2) == &quot;X-&quot; then
          debitNotice[tagName] = tagValue
          creditNotice[tagName] = tagValue
        end
      end

      -- Send Debit-Notice and Credit-Notice
      return self.transferNotices(debitNotice, creditNotice, recipient, msg)
    end
  else
    return self.transferErrorNotice(msg)
  end
end

return Token

end

_G.package.loaded[&quot;marketModules.token&quot;] = _loaded_mod_marketModules_token()

-- module: &quot;marketModules.constants&quot;
local function _loaded_mod_marketModules_constants()
--[[
=========================================================
Part of the Outcome codebase © 2025. All Rights Reserved.
See market.lua for full license details.
=========================================================
]]

local constants = {}
local json = require(&#39;json&#39;)
-- DB
constants.db = {
  intervals = {
    [&quot;1h&quot;] = &quot;1 minute&quot;,
    [&quot;6h&quot;] = &quot;1 minute&quot;,
    [&quot;1d&quot;] = &quot;5 minutes&quot;,
    [&quot;1w&quot;] = &quot;3 hours&quot;,
    [&quot;1M&quot;] = &quot;12 hours&quot;,
    [&quot;max&quot;] = &quot;1 day&quot;
  },
  rangeDurations = {
    [&quot;1h&quot;] = &quot;1 hour&quot;,
    [&quot;6h&quot;] = &quot;6 hours&quot;,
    [&quot;1d&quot;] = &quot;1 day&quot;,
    [&quot;1w&quot;] = &quot;7 days&quot;,
    [&quot;1M&quot;] = &quot;1 month&quot;
  },
  maxInterval = &quot;1 day&quot;,
  maxRangeDuration = &quot;100 years&quot;,
  defaultLimit = 50,
  defaultOffset = 0,
  defaultActivityWindow = 24,
  moderators = {},
}
-- Market Factory
constants.marketFactory = {
  configurator = &quot;test-this-is-valid-arweave-wallet-address-1&quot;,
  namePrefix = &quot;Outcome Market&quot;,
  tickerPrefix = &quot;OUTCOME&quot;,
  logo = &quot;https:&#47;&#47;test.com&#47;logo.png&quot;,
  lpFee = &quot;100&quot;,
  protocolFee = &quot;250&quot;,
  protocolFeeTarget = &quot;test-this-is-valid-arweave-wallet-address-3&quot;,
  maximumTakeFee = &quot;500&quot;,
  utilityToken = &quot;test-this-is-valid-arweave-wallet-address-4&quot;,
  minimumPayment = &quot;1000&quot;,
  collateralTokens = {&quot;test-this-is-valid-arweave-wallet-address-5&quot;}
}
-- Market
constants.testMarketConfig = {
  configurator = &quot;test-this-is-valid-arweave-wallet-address-6&quot;,
  collateralToken = &quot;test-this-is-valid-arweave-wallet-address-2&quot;,
  conditionId = &quot;c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470&quot;,
  positionIds = json.encode({&quot;1&quot;, &quot;2&quot;}),
  name = &quot;Test Market&quot;,
  ticker = &quot;TST&quot;,
  logo = &quot;https:&#47;&#47;test.com&#47;logo.png&quot;,
  lpFee = &quot;100&quot;,
  creatorFee = &quot;100&quot;,
  creatorFeeTarget = &quot;test-this-is-valid-arweave-wallet-address-3&quot;,
  protocolFee = &quot;100&quot;,
  protocolFeeTarget = &quot;test-this-is-valid-arweave-wallet-address-4&quot;
}
-- Activity
constants.activity = {
  configurator = &quot;test-this-is-valid-arweave-wallet-address-1&quot;,
}
-- CPMM
constants.denomination = 12
-- Market Config
constants.marketConfig = {
  configurator = &quot;b9hj1yVw3eWGIggQgJxRDj1t8SZFCezctYD-7U5nYFk&quot;,
  dataIndex = &quot;rXSAUKwZhJkIBTIEyBl1rf8Gtk_88RKQFsx5JvDOwlE&quot;,
  collateralToken = &quot;jAyJBNpuSXmhn9lMMfwDR60TfIPANXI6r-f3n9zucYU&quot;,
  resolutionAgent = &quot;ukmrCFkEWdFH_xS4UicCErwCqGT2RJjr1qlk4U720C8&quot;,
  creator = &quot;XkVOo16KMIHK-zqlR67cuNY0ayXIkPWODWw_HXAE20I&quot;,
  question = &quot;Liquid Ops oUSDC interest reaches 8% in March&quot;,
  rules = &quot;Where we&#39;re going, we don&#39;t need rules&quot;,
  category = &quot;Finance&quot;,
  sucategory = &quot;Interest Rates&quot;,
  positionIds = json.encode({&quot;1&quot;,&quot;2&quot;}),
  name = &quot;Mock Spawn Market&quot;,
  ticker = &#39;MSM&#39;,
  logo = &quot;https:&#47;&#47;test.com&#47;logo.png&quot;,
  lpFee = &quot;100&quot;,
  creatorFee = &quot;250&quot;,
  creatorFeeTarget = &quot;m6W6wreOSejTb2WRHoALM6M7mw3H8D2KmFVBYC1l0O0&quot;,
  protocolFee = &quot;250&quot;,
  protocolFeeTarget = &quot;m6W6wreOSejTb2WRHoALM6M7mw3H8D2KmFVBYC1l0O0&quot;
}

return constants
end

_G.package.loaded[&quot;marketModules.constants&quot;] = _loaded_mod_marketModules_constants()

-- module: &quot;.ao&quot;
local function _loaded_mod_ao()
--- The AO module provides functionality for managing the AO environment and handling messages. Returns the ao table.
-- @module ao

local oldao = ao or {}

--- The AO module
-- @table ao
-- @field _version The version number of the ao module
-- @field _module The module id of the process
-- @field id The id of the process
-- @field authorities A table of authorities of the process
-- @field reference The reference number of the process
-- @field outbox The outbox of the process
-- @field nonExtractableTags The non-extractable tags
-- @field nonForwardableTags The non-forwardable tags
-- @field clone The clone function
-- @field normalize The normalize function
-- @field sanitize The sanitize function
-- @field init The init function
-- @field log The log function
-- @field clearOutbox The clearOutbox function
-- @field send The send function
-- @field spawn The spawn function
-- @field assign The assign function
-- @field isTrusted The isTrusted function
-- @field result The result function
local ao = {
    _version = &quot;0.0.6&quot;,
    id = oldao.id or &quot;&quot;,
    _module = oldao._module or &quot;&quot;,
    authorities = oldao.authorities or {},
    reference = oldao.reference or 0,
    outbox = oldao.outbox or
        {Output = {}, Messages = {}, Spawns = {}, Assignments = {}},
    nonExtractableTags = {
        &#39;Data-Protocol&#39;, &#39;Variant&#39;, &#39;From-Process&#39;, &#39;From-Module&#39;, &#39;Type&#39;,
        &#39;From&#39;, &#39;Owner&#39;, &#39;Anchor&#39;, &#39;Target&#39;, &#39;Data&#39;, &#39;Tags&#39;, &#39;Read-Only&#39;
    },
    nonForwardableTags = {
        &#39;Data-Protocol&#39;, &#39;Variant&#39;, &#39;From-Process&#39;, &#39;From-Module&#39;, &#39;Type&#39;,
        &#39;From&#39;, &#39;Owner&#39;, &#39;Anchor&#39;, &#39;Target&#39;, &#39;Tags&#39;, &#39;TagArray&#39;, &#39;Hash-Chain&#39;,
        &#39;Timestamp&#39;, &#39;Nonce&#39;, &#39;Epoch&#39;, &#39;Signature&#39;, &#39;Forwarded-By&#39;,
        &#39;Pushed-For&#39;, &#39;Read-Only&#39;, &#39;Cron&#39;, &#39;Block-Height&#39;, &#39;Reference&#39;, &#39;Id&#39;,
        &#39;Reply-To&#39;
    }
}

--- Checks if a key exists in a list.
-- @lfunction _includes
-- @tparam {table} list The list to check against
-- @treturn {function} A function that takes a key and returns true if the key exists in the list
local function _includes(list)
    return function(key)
        local exists = false
        for _, listKey in ipairs(list) do
            if key == listKey then
                exists = true
                break
            end
        end
        if not exists then return false end
        return true
    end
end

--- Checks if a table is an array.
-- @lfunction isArray
-- @tparam {table} table The table to check
-- @treturn {boolean} True if the table is an array, false otherwise
local function isArray(table)
    if type(table) == &quot;table&quot; then
        local maxIndex = 0
        for k, v in pairs(table) do
            if type(k) ~= &quot;number&quot; or k &lt; 1 or math.floor(k) ~= k then
                return false -- If there&#39;s a non-integer key, it&#39;s not an array
            end
            maxIndex = math.max(maxIndex, k)
        end
        -- If the highest numeric index is equal to the number of elements, it&#39;s an array
        return maxIndex == #table
    end
    return false
end

--- Pads a number with leading zeros to 32 digits.
-- @lfunction padZero32
-- @tparam {number} num The number to pad
-- @treturn {string} The padded number as a string
local function padZero32(num) return string.format(&quot;%032d&quot;, num) end

--- Clones a table recursively.
-- @function clone
-- @tparam {any} obj The object to clone
-- @tparam {table} seen The table of seen objects (default is nil)
-- @treturn {any} The cloned object
function ao.clone(obj, seen)
    -- Handle non-tables and previously-seen tables.
    if type(obj) ~= &#39;table&#39; then return obj end
    if seen and seen[obj] then return seen[obj] end

    -- New table; mark it as seen and copy recursively.
    local s = seen or {}
    local res = {}
    s[obj] = res
    for k, v in pairs(obj) do res[ao.clone(k, s)] = ao.clone(v, s) end
    return setmetatable(res, getmetatable(obj))
end

--- Normalizes a message by extracting tags.
-- @function normalize
-- @tparam {table} msg The message to normalize
-- @treturn {table} The normalized message
function ao.normalize(msg)
    for _, o in ipairs(msg.Tags) do
        if not _includes(ao.nonExtractableTags)(o.name) then
            msg[o.name] = o.value
        end
    end
    return msg
end

--- Sanitizes a message by removing non-forwardable tags.
-- @function sanitize
-- @tparam {table} msg The message to sanitize
-- @treturn {table} The sanitized message
function ao.sanitize(msg)
    local newMsg = ao.clone(msg)

    for k, _ in pairs(newMsg) do
        if _includes(ao.nonForwardableTags)(k) then newMsg[k] = nil end
    end

    return newMsg
end

--- Initializes the AO environment, including ID, module, authorities, outbox, and environment.
-- @function init
-- @tparam {table} env The environment object
function ao.init(env)
    if ao.id == &quot;&quot; then ao.id = env.Process.Id end

    if ao._module == &quot;&quot; then
        for _, o in ipairs(env.Process.Tags) do
            if o.name == &quot;Module&quot; then ao._module = o.value end
        end
    end

    if #ao.authorities &lt; 1 then
        for _, o in ipairs(env.Process.Tags) do
            if o.name == &quot;Authority&quot; then
                table.insert(ao.authorities, o.value)
            end
        end
    end

    ao.outbox = {Output = {}, Messages = {}, Spawns = {}, Assignments = {}}
    ao.env = env

end

--- Logs a message to the output.
-- @function log
-- @tparam {string} txt The message to log
function ao.log(txt)
    if type(ao.outbox.Output) == &#39;string&#39; then
        ao.outbox.Output = {ao.outbox.Output}
    end
    table.insert(ao.outbox.Output, txt)
end

--- Clears the outbox.
-- @function clearOutbox
function ao.clearOutbox()
    ao.outbox = {Output = {}, Messages = {}, Spawns = {}, Assignments = {}}
end

--- Sends a message.
-- @function send
-- @tparam {table} msg The message to send
function ao.send(msg)
    assert(type(msg) == &#39;table&#39;, &#39;msg should be a table&#39;)
    ao.reference = ao.reference + 1
    local referenceString = tostring(ao.reference)

    local message = {
        Target = msg.Target,
        Data = msg.Data,
        Anchor = padZero32(ao.reference),
        Tags = {
            {name = &quot;Data-Protocol&quot;, value = &quot;ao&quot;},
            {name = &quot;Variant&quot;, value = &quot;ao.TN.1&quot;},
            {name = &quot;Type&quot;, value = &quot;Message&quot;},
            {name = &quot;Reference&quot;, value = referenceString}
        }
    }

    -- if custom tags in root move them to tags
    for k, v in pairs(msg) do
        if not _includes({&quot;Target&quot;, &quot;Data&quot;, &quot;Anchor&quot;, &quot;Tags&quot;, &quot;From&quot;})(k) then
            table.insert(message.Tags, {name = k, value = v})
        end
    end

    if msg.Tags then
        if isArray(msg.Tags) then
            for _, o in ipairs(msg.Tags) do
                table.insert(message.Tags, o)
            end
        else
            for k, v in pairs(msg.Tags) do
                table.insert(message.Tags, {name = k, value = v})
            end
        end
    end

    -- If running in an environment without the AOS Handlers module, do not add
    -- the onReply and receive functions to the message.
    if not Handlers then return message end

    -- clone message info and add to outbox
    local extMessage = {}
    for k, v in pairs(message) do extMessage[k] = v end

    -- add message to outbox
    table.insert(ao.outbox.Messages, extMessage)

    -- add callback for onReply handler(s)
    message.onReply =
        function(...) -- Takes either (AddressThatWillReply, handler(s)) or (handler(s))
            local from, resolver
            if select(&quot;#&quot;, ...) == 2 then
                from = select(1, ...)
                resolver = select(2, ...)
            else
                from = message.Target
                resolver = select(1, ...)
            end

            -- Add a one-time callback that runs the user&#39;s (matching) resolver on reply
            Handlers.once({From = from, [&quot;X-Reference&quot;] = referenceString},
                          resolver)
        end

    message.receive = function(...)
        local from = message.Target
        if select(&quot;#&quot;, ...) == 1 then from = select(1, ...) end
        return
            Handlers.receive({From = from, [&quot;X-Reference&quot;] = referenceString})
    end

    return message
end

--- Spawns a process.
-- @function spawn
-- @tparam {string} module The module source id
-- @tparam {table} msg The message to send
function ao.spawn(module, msg)
    assert(type(module) == &quot;string&quot;, &quot;Module source id is required!&quot;)
    assert(type(msg) == &#39;table&#39;, &#39;Message must be a table&#39;)
    -- inc spawn reference
    ao.reference = ao.reference + 1
    local spawnRef = tostring(ao.reference)

    local spawn = {
        Data = msg.Data or &quot;NODATA&quot;,
        Anchor = padZero32(ao.reference),
        Tags = {
            {name = &quot;Data-Protocol&quot;, value = &quot;ao&quot;},
            {name = &quot;Variant&quot;, value = &quot;ao.TN.1&quot;},
            {name = &quot;Type&quot;, value = &quot;Process&quot;},
            {name = &quot;From-Process&quot;, value = ao.id},
            {name = &quot;From-Module&quot;, value = ao._module},
            {name = &quot;Module&quot;, value = module},
            {name = &quot;Reference&quot;, value = spawnRef}
        }
    }

    -- if custom tags in root move them to tags
    for k, v in pairs(msg) do
        if not _includes({&quot;Target&quot;, &quot;Data&quot;, &quot;Anchor&quot;, &quot;Tags&quot;, &quot;From&quot;})(k) then
            table.insert(spawn.Tags, {name = k, value = v})
        end
    end

    if msg.Tags then
        if isArray(msg.Tags) then
            for _, o in ipairs(msg.Tags) do
                table.insert(spawn.Tags, o)
            end
        else
            for k, v in pairs(msg.Tags) do
                table.insert(spawn.Tags, {name = k, value = v})
            end
        end
    end

    -- If running in an environment without the AOS Handlers module, do not add
    -- the after and receive functions to the spawn.
    if not Handlers then return spawn end

    -- clone spawn info and add to outbox
    local extSpawn = {}
    for k, v in pairs(spawn) do extSpawn[k] = v end

    table.insert(ao.outbox.Spawns, extSpawn)

    -- add &#39;after&#39; callback to returned table
    -- local result = {}
    spawn.onReply = function(callback)
        Handlers.once({
            Action = &quot;Spawned&quot;,
            From = ao.id,
            [&quot;Reference&quot;] = spawnRef
        }, callback)
    end

    spawn.receive = function()
        return Handlers.receive({
            Action = &quot;Spawned&quot;,
            From = ao.id,
            [&quot;Reference&quot;] = spawnRef
        })

    end

    return spawn
end

--- Assigns a message to a process.
-- @function assign
-- @tparam {table} assignment The assignment to assign
function ao.assign(assignment)
    assert(type(assignment) == &#39;table&#39;, &#39;assignment should be a table&#39;)
    assert(type(assignment.Processes) == &#39;table&#39;, &#39;Processes should be a table&#39;)
    assert(type(assignment.Message) == &quot;string&quot;, &quot;Message should be a string&quot;)
    table.insert(ao.outbox.Assignments, assignment)
end

--- Checks if a message is trusted.
-- The default security model of AOS processes: Trust all and *only* those on the ao.authorities list.
-- @function isTrusted
-- @tparam {table} msg The message to check
-- @treturn {boolean} True if the message is trusted, false otherwise
function ao.isTrusted(msg)
    for _, authority in ipairs(ao.authorities) do
        if msg.From == authority then return true end
        if msg.Owner == authority then return true end
    end
    return false
end

--- Returns the result of the process.
-- @function result
-- @tparam {table} result The result of the process
-- @treturn {table} The result of the process, including Output, Messages, Spawns, and Assignments
function ao.result(result)
    -- if error then only send the Error to CU
    if ao.outbox.Error or result.Error then
        return {Error = result.Error or ao.outbox.Error}
    end
    return {
        Output = result.Output or ao.outbox.Output,
        Messages = ao.outbox.Messages,
        Spawns = ao.outbox.Spawns,
        Assignments = ao.outbox.Assignments
    }
end


--- Add the MatchSpec to the ao.assignables table. A optional name may be provided.
-- This implies that ao.assignables may have both number and string indices.
-- Added in the assignment module.
-- @function addAssignable
-- @tparam ?string|number|any nameOrMatchSpec The name of the MatchSpec
--        to be added to ao.assignables. if a MatchSpec is provided, then
--        no name is included
-- @tparam ?any matchSpec The MatchSpec to be added to ao.assignables. Only provided
--        if its name is passed as the first parameter
-- @treturn ?string|number name The name of the MatchSpec, either as provided
--          as an argument or as incremented
-- @see assignment

--- Remove the MatchSpec, either by name or by index
-- If the name is not found, or if the index does not exist, then do nothing.
-- Added in the assignment module.
-- @function removeAssignable
-- @tparam {string|number} name The name or index of the MatchSpec to be removed
-- @see assignment

--- Return whether the msg is an assignment or not. This can be determined by simply check whether the msg&#39;s Target is this process&#39; id
-- Added in the assignment module.
-- @function isAssignment
-- @param msg The msg to be checked
-- @treturn boolean isAssignment
-- @see assignment

--- Check whether the msg matches any assignable MatchSpec.
-- If not assignables are configured, the msg is deemed not assignable, by default.
-- Added in the assignment module.
-- @function isAssignable
-- @param msg The msg to be checked
-- @treturn boolean isAssignable
-- @see assignment

return ao
end

_G.package.loaded[&quot;.ao&quot;] = _loaded_mod_ao()

-- module: &quot;marketModules.conditionalTokensNotices&quot;
local function _loaded_mod_marketModules_conditionalTokensNotices()
--[[
=========================================================
Part of the Outcome codebase © 2025. All Rights Reserved.
See conditionalTokens.lua for full license details.
=========================================================
]]

local json = require(&#39;json&#39;)
local ao = ao or require(&#39;.ao&#39;)

local ConditionalTokensNotices = {}

--- Report payouts notice
--- @param resolutionAgent string The process assigned to report the result for the prepared condition
--- @param payoutNumerators table&lt;number&gt; The payout numerators for each outcome slot
--- @param msg Message The message received
--- @return Message reportPayoutsNotice The report payouts notice
function ConditionalTokensNotices.reportPayoutsNotice(resolutionAgent, payoutNumerators, msg)
  return msg.reply({
    Action = &quot;Report-Payouts-Notice&quot;,
    ResolutionAgent = resolutionAgent,
    PayoutNumerators = json.encode(payoutNumerators)
  })
end

--- Position split notice
--- @param from string The address of the account that split the position
--- @param collateralToken string The address of the collateral token
--- @param quantity string The quantity
--- @param msg Message The message received
--- @return Message The position split notice
function ConditionalTokensNotices.positionSplitNotice(from, collateralToken, quantity, msg)
  local notice = {
    Action = &quot;Split-Position-Notice&quot;,
    Process = ao.id,
    Stakeholder = from,
    CollateralToken = collateralToken,
    Quantity = quantity
  }
  -- Forward tags
  for tagName, tagValue in pairs(msg) do
    -- Tags beginning with &quot;X-&quot; are forwarded
    if string.sub(tagName, 1, 2) == &quot;X-&quot; then
      notice[tagName] = tagValue
    end
  end
  -- Send notice | @dev ao.send vs msg.reply to ensure message is sent to user (not collateralToken)
  return msg.forward(from, notice)
end

--- Positions merge notice
--- @param collateralToken string The address of the collateral token
--- @param quantity string The quantity
--- @param msg Message The message received
--- @param useReply boolean Whether to use `msg.reply` or `ao.send`
--- @return Message The positions merge notice
function ConditionalTokensNotices.positionsMergeNotice(collateralToken, quantity, msg, useReply)
  local notice = {
    Action = &quot;Merge-Positions-Notice&quot;,
    CollateralToken = collateralToken,
    Quantity = quantity
  }
  if useReply then return msg.reply(notice) end
  notice.Target = msg.Sender and msg.Sender or msg.From
  return ao.send(notice)
end

--- Redeem positions notice
--- @param collateralToken string The address of the collateral token
--- @param payout number The payout amount
--- @param netPayout string The net payout amount (after fees)
--- @param msg Message The message received
--- @return Message The payout redemption notice
function ConditionalTokensNotices.redeemPositionsNotice(collateralToken, payout, netPayout, msg)
  return msg.reply({
    Action = &quot;Redeem-Positions-Notice&quot;,
    CollateralToken = collateralToken,
    GrossPayout = tostring(payout),
    NetPayout = netPayout
  })
end

return ConditionalTokensNotices

end

_G.package.loaded[&quot;marketModules.conditionalTokensNotices&quot;] = _loaded_mod_marketModules_conditionalTokensNotices()

-- module: &quot;marketModules.semiFungibleTokensNotices&quot;
local function _loaded_mod_marketModules_semiFungibleTokensNotices()
--[[
=========================================================
Part of the Outcome codebase © 2025. All Rights Reserved.
See semiFungibleTokens.lua for full license details.
=========================================================
]]

-- local ao = require(&#39;.ao&#39;)
local json = require(&#39;json&#39;)

local SemiFungibleTokensNotices = {}

--- Mint single notice
--- @param to string The address that will own the minted token
--- @param id string The ID of the token to be minted
--- @param quantity string The quantity of the token to be minted
--- @param msg Message The message received
--- @return Message The mint notice
function SemiFungibleTokensNotices.mintSingleNotice(to, id, quantity, msg)
  return msg.reply({
    Recipient = to,
    PositionId = tostring(id),
    Quantity = tostring(quantity),
    Action = &#39;Mint-Single-Notice&#39;,
    Data = Colors.gray .. &quot;Successfully minted &quot; .. Colors.blue .. tostring(quantity) .. Colors.gray .. &quot; of id &quot; .. Colors.blue .. tostring(id) .. Colors.reset
  })
end

--- Mint batch notice
--- @param to string The address that will own the minted tokens
--- @param ids table&lt;string&gt; The IDs of the tokens to be minted
--- @param quantities table&lt;string&gt; The quantities of the tokens to be minted
--- @param msg Message The message received
--- @return Message The batch mint notice
function SemiFungibleTokensNotices.mintBatchNotice(to, ids, quantities, msg)
  return msg.forward(to, {
    Recipient = to,
    PositionIds = json.encode(ids),
    Quantities = json.encode(quantities),
    Action = &#39;Mint-Batch-Notice&#39;,
    Data = &quot;Successfully minted batch&quot;
  })
end

--- Burn single notice
--- @param from string The address that will burn the token
--- @param id string The ID of the token to be burned
--- @param quantity string The quantity of the token to be burned
--- @param msg Message The message received
--- @param useReply boolean Whether to use `msg.reply` or `ao.send`
--- @return Message The burn notice
function SemiFungibleTokensNotices.burnSingleNotice(from, id, quantity, msg, useReply)
  -- Prepare notice
  local notice = {
    Recipient = from,
    PositionId = tostring(id),
    Quantity = tostring(quantity),
    Action = &#39;Burn-Single-Notice&#39;,
    Data = Colors.gray .. &quot;Successfully burned &quot; .. Colors.blue .. tostring(quantity) .. Colors.gray .. &quot; of id &quot; .. Colors.blue .. tostring(id) .. Colors.reset
  }
  -- Forward X-Tags
  for tagName, tagValue in pairs(msg) do
    -- Tags beginning with &quot;X-&quot; are forwarded
    if string.sub(tagName, 1, 2) == &quot;X-&quot; then
      notice[tagName] = tagValue
    end
  end
  -- Send notice
  if useReply then return msg.reply(notice) end
  notice.Target = from
  return ao.send(notice)
end

--- Burn batch notice
--- @param from string The address that will burn the tokens
--- @param positionIds table&lt;string&gt; The IDs of the positions to be burned
--- @param quantities table&lt;string&gt; The quantities of the tokens to be burned
--- @param remainingBalances table&lt;string&gt; The remaining balances of unburned tokens
--- @param msg Message The message received
--- @param useReply boolean Whether to use `msg.reply` or `ao.send`
--- @return Message The burn notice
function SemiFungibleTokensNotices.burnBatchNotice(from, positionIds, quantities, remainingBalances, msg, useReply)
  -- Prepare notice
  local notice = {
    Recipient = from,
    PositionIds = json.encode(positionIds),
    Quantities = json.encode(quantities),
    RemainingBalances = json.encode(remainingBalances),
    Action = &#39;Burn-Batch-Notice&#39;,
    Data = &quot;Successfully burned batch&quot;
  }
  -- Forward X-Tags
  for tagName, tagValue in pairs(msg) do
    -- Tags beginning with &quot;X-&quot; are forwarded
    if string.sub(tagName, 1, 2) == &quot;X-&quot; then
      notice[tagName] = tagValue
    end
  end
  -- Send notice
  if useReply then return msg.reply(notice) end
  notice.Target = from
  return ao.send(notice)
end

--- Transfer single token notices
--- @param from string The address to be debited
--- @param to string The address to be credited
--- @param id string The ID of the token to be transferred
--- @param quantity string The quantity of the token to be transferred
--- @param msg Message The message received
--- @param useReply boolean Whether to use `msg.reply` or `ao.send`
--- @return table&lt;Message&gt; The debit and credit transfer notices
function SemiFungibleTokensNotices.transferSingleNotices(from, to, id, quantity, msg, useReply)
  -- Prepare debit notice
  local debitNotice = {
    Action = &#39;Debit-Single-Notice&#39;,
    Recipient = to,
    PositionId = tostring(id),
    Quantity = tostring(quantity),
    Data = Colors.gray .. &quot;You transferred &quot; .. Colors.blue .. tostring(quantity) .. Colors.gray .. &quot; of id &quot;
      .. Colors.blue .. tostring(id) .. Colors.gray .. &quot; to &quot; .. Colors.green .. to .. Colors.reset
  }
  -- Prepare credit notice
  local creditNotice = {
    Action = &#39;Credit-Single-Notice&#39;,
    Sender = from,
    PositionId = tostring(id),
    Quantity = tostring(quantity),
    Data = Colors.gray .. &quot;You received &quot; .. Colors.blue .. tostring(quantity) .. Colors.gray .. &quot; of id &quot;
      .. Colors.blue .. tostring(id) .. Colors.gray .. &quot; from &quot; .. Colors.green .. from .. Colors.reset
  }
  -- Forward X-Tags
  for tagName, tagValue in pairs(msg) do
    -- Tags beginning with &quot;X-&quot; are forwarded
    if string.sub(tagName, 1, 2) == &quot;X-&quot; then
      debitNotice[tagName] = tagValue
      creditNotice[tagName] = tagValue
    end
  end
  -- Send notices
  if useReply then return { msg.reply(debitNotice), msg.forward(to, creditNotice) } end
  debitNotice.Target = from
  creditNotice.Target = to
  return { ao.send(debitNotice), ao.send(creditNotice) }
end

--- Transfer batch tokens notices
--- @param from string The address to be debited
--- @param to string The address to be credited
--- @param ids table&lt;string&gt; The IDs of the tokens to be transferred
--- @param quantities table&lt;string&gt; The quantities of the tokens to be transferred
--- @param msg Message The message received
--- @param useReply boolean Whether to use `msg.reply` or `ao.send`
--- @return table&lt;Message&gt; The debit and credit batch transfer notices
function SemiFungibleTokensNotices.transferBatchNotices(from, to, ids, quantities, msg, useReply)
  -- Prepare debit notice
  local debitNotice = {
    Action = &#39;Debit-Batch-Notice&#39;,
    Recipient = to,
    PositionIds = json.encode(ids),
    Quantities = json.encode(quantities),
    Data = Colors.gray .. &quot;You transferred batch to &quot; .. Colors.green .. to .. Colors.reset
  }
  -- Prepare credit notice
  local creditNotice = {
    Action = &#39;Credit-Batch-Notice&#39;,
    Sender = from,
    PositionIds = json.encode(ids),
    Quantities = json.encode(quantities),
    Data = Colors.gray .. &quot;You received batch from &quot; .. Colors.green .. from .. Colors.reset
  }
  -- Forward X-Tags
  for tagName, tagValue in pairs(msg) do
    -- Tags beginning with &quot;X-&quot; are forwarded
    if string.sub(tagName, 1, 2) == &quot;X-&quot; then
      debitNotice[tagName] = tagValue
      creditNotice[tagName] = tagValue
    end
  end
  -- Send notice
  if useReply then return { msg.reply(debitNotice), msg.forward(to, creditNotice) } end
  debitNotice.Target = from
  creditNotice.Target = to
  return {ao.send(debitNotice), ao.send(creditNotice)}
end

--- Transfer error notice
--- @param id string The ID of the token to be transferred
--- @param msg Message The message received
--- @return Message The transfer error notice
function SemiFungibleTokensNotices.transferErrorNotice(id, msg)
  return msg.reply({
    Action = &#39;Transfer-Error&#39;,
    [&#39;Message-Id&#39;] = msg.Id,
    [&#39;PositionId&#39;] = id,
    Error = &#39;Insufficient Balance!&#39;
  })
end

return SemiFungibleTokensNotices

end

_G.package.loaded[&quot;marketModules.semiFungibleTokensNotices&quot;] = _loaded_mod_marketModules_semiFungibleTokensNotices()

-- module: &quot;marketModules.semiFungibleTokens&quot;
local function _loaded_mod_marketModules_semiFungibleTokens()
--[[
==============================================================================
Outcome © 2025. MIT License.
Module: semiFungibleTokens.lua
==============================================================================
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and&#47;or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
==============================================================================
]]

local SemiFungibleTokens = {}
local SemiFungibleTokensMethods = {}
local SemiFungibleTokensNotices = require(&#39;marketModules.semiFungibleTokensNotices&#39;)
local bint = require(&#39;.bint&#39;)(256)

-- Represents SemiFungibleTokens
--- @class SemiFungibleTokens
--- @field name string The token name
--- @field ticker string The token ticker
--- @field logo string The token logo Arweave TxID
--- @field balancesById table&lt;string, table&lt;string, string&gt;&gt; The account token balances by ID
--- @field totalSupplyById table&lt;string, string&gt; The total supply of the token by ID
--- @field denomination number The number of decimals

--- Creates a new SemiFungibleTokens instance
--- @param name string The token name
--- @param ticker string The token ticker
--- @param logo string The token logo Arweave TxID
--- @param balancesById table&lt;string, table&lt;string, string&gt;&gt; The account token balances by ID
--- @param totalSupplyById table&lt;string, string&gt; The total supply of the token by ID
--- @param denomination number The number of decimals
--- @return SemiFungibleTokens semiFungibleTokens The new SemiFungibleTokens instance
function SemiFungibleTokens.new(name, ticker, logo, balancesById, totalSupplyById, denomination)
  local semiFungibleTokens = {
    name = name,
    ticker = ticker,
    logo = logo,
    balancesById = balancesById,
    totalSupplyById = totalSupplyById,
    denomination = denomination
  }
  setmetatable(semiFungibleTokens, {
    __index = function(_, k)
      if SemiFungibleTokensMethods[k] then
        return SemiFungibleTokensMethods[k]
      elseif SemiFungibleTokensNotices[k] then
        return SemiFungibleTokensNotices[k]
      else
        return nil
      end
    end
  })
  return semiFungibleTokens
end

--- Mint a quantity of tokens with the given ID
--- @param to string The address that will own the minted tokens
--- @param id string The ID of the tokens to mint
--- @param quantity string The quantity of tokens to mint
--- @param msg Message The message received
--- @return Message The mint notice
function SemiFungibleTokensMethods:mint(to, id, quantity, msg)
  assert(quantity, &#39;Quantity is required!&#39;)
  assert(bint.__lt(0, bint(quantity)), &#39;Quantity must be greater than zero!&#39;)
  -- mint tokens
  if not self.balancesById[id] then self.balancesById[id] = {} end
  if not self.balancesById[id][to] then self.balancesById[id][to] = &quot;0&quot; end
  if not self.totalSupplyById[id] then self.totalSupplyById[id] = &quot;0&quot; end
  self.balancesById[id][to] = tostring(bint.__add(self.balancesById[id][to], bint(quantity)))
  self.totalSupplyById[id] = tostring(bint.__add(self.totalSupplyById[id], bint(quantity)))
  -- send notice
  return self.mintSingleNotice(to, id, quantity, msg)
end

--- Batch mint quantities of tokens with the given IDs
--- @param to string The address that will own the minted tokens
--- @param ids table&lt;string&gt; The IDs of the tokens to mint
--- @param quantities table&lt;string&gt; The quantities of tokens to mint
--- @param msg Message The message received
--- @return Message The batch mint notice
function SemiFungibleTokensMethods:batchMint(to, ids, quantities, msg)
  assert(#ids == #quantities, &#39;Ids and quantities must have the same lengths&#39;)
  -- mint tokens
  for i = 1, #ids do
    -- @dev spacing to resolve text to code eval issue
    if not self.balancesById[ ids[i] ] then self.balancesById[ ids[i] ] = {} end
    if not self.balancesById[ ids[i] ][to] then self.balancesById[ ids[i] ][to] = &quot;0&quot; end
    if not self.totalSupplyById[ ids[i] ] then self.totalSupplyById[ ids[i] ] = &quot;0&quot; end
    self.balancesById[ ids[i] ][to] = tostring(bint.__add(self.balancesById[ ids[i] ][to], quantities[i]))
    self.totalSupplyById[ ids[i] ] = tostring(bint.__add(self.totalSupplyById[ ids[i] ], quantities[i]))
  end
  -- send notice
  return self.mintBatchNotice(to, ids, quantities, msg)
end

--- Burn a quantity of tokens with a given ID
--- @param from string The process ID that will no longer own the burned tokens
--- @param id string The ID of the tokens to burn
--- @param quantity string The quantity of tokens to burn
--- @param msg Message The message received
--- @param useReply boolean Whether to use `msg.reply` or `ao.send`
--- @return Message The burn notice
function SemiFungibleTokensMethods:burn(from, id, quantity, msg, useReply)
  assert(bint.__lt(0, bint(quantity)), &#39;Quantity must be greater than zero!&#39;)
  assert(self.balancesById[id], &#39;Id must exist! &#39; .. id)
  assert(self.balancesById[id][from], &#39;Account must hold token! :: &#39; .. id)
  assert(bint.__le(bint(quantity), self.balancesById[id][from]), &#39;Account must have sufficient tokens! &#39; .. id)
  -- burn tokens
  self.balancesById[id][from] = tostring(bint.__sub(self.balancesById[id][from], bint(quantity)))
  self.totalSupplyById[id] = tostring(bint.__sub(self.totalSupplyById[id], bint(quantity)))
  -- send notice
  return self.burnSingleNotice(from, id, quantity, msg, useReply)
end

--- Batch burn a quantity of tokens with the given IDs
--- @param from string The process ID that will no longer own the burned tokens
--- @param ids table&lt;string&gt; The IDs of the tokens to burn
--- @param quantities table&lt;string&gt; The quantities of tokens to burn
--- @param msg Message The message received
--- @param useReply boolean Whether to use `msg.reply` or `ao.send`
--- @return Message The batch burn notice
function SemiFungibleTokensMethods:batchBurn(from, ids, quantities, msg, useReply)
  assert(#ids == #quantities, &#39;Ids and quantities must have the same lengths&#39;)
  for i = 1, #ids do
    assert(bint.__lt(0, quantities[i]), &#39;Quantity must be greater than zero!&#39;)
    assert(self.balancesById[ ids[i] ], &#39;Id must exist! &#39; .. ids[i])
    assert(self.balancesById[ ids[i] ][from], &#39;Account must hold token! &#39; .. ids[i])
    assert(bint.__le(quantities[i], self.balancesById[ ids[i] ][from]), &#39;Account must have sufficient tokens!&#39;)
  end
  -- burn tokens
  local remainingBalances = {}
  for i = 1, #ids do
    self.balancesById[ ids[i] ][from] = tostring(bint.__sub(self.balancesById[ ids[i] ][from], quantities[i]))
    self.totalSupplyById[ ids[i] ] = tostring(bint.__sub(self.totalSupplyById[ ids[i] ], quantities[i]))
    remainingBalances[i] = self.balancesById[ ids[i] ][from]
  end
  -- send notice
  return self.burnBatchNotice(from, ids, quantities, remainingBalances, msg, useReply)
end

--- Transfer a quantity of tokens with the given ID
--- @param from string The process ID that will send the token
--- @param recipient string The process ID that will receive the token
--- @param id string The ID of the tokens to transfer
--- @param quantity string The quantity of tokens to transfer
--- @param cast boolean The cast is set to true to silence the transfer notice
--- @param useReply boolean Whether to use `msg.reply` or `ao.send`
--- @param msg Message The message received
--- @return table&lt;Message&gt;|Message|nil The transfer notices, error notice or nothing
function SemiFungibleTokensMethods:transferSingle(from, recipient, id, quantity, cast, msg, useReply)
  if not self.balancesById[id] then self.balancesById[id] = {} end
  if not self.balancesById[id][from] then self.balancesById[id][from] = &quot;0&quot; end
  if not self.balancesById[id][recipient] then self.balancesById[id][recipient] = &quot;0&quot; end

  local qty = bint(quantity)
  local balance = bint(self.balancesById[id][from])
  if bint.__le(qty, balance) then
    self.balancesById[id][from] = tostring(bint.__sub(balance, qty))
    self.balancesById[id][recipient] = tostring(bint.__add(self.balancesById[id][recipient], qty))

    -- Only send the notifications if the cast tag is not set
    if not cast then
      return self.transferSingleNotices(from, recipient, id, quantity, msg, useReply)
    end
  else
    return self.transferErrorNotice(id, msg)
  end
end

--- Batch transfer quantities of tokens with the given IDs
--- @param from string The process ID that will send the token
--- @param recipient string The process ID that will receive the token
--- @param ids table&lt;string&gt; The IDs of the tokens to transfer
--- @param quantities table&lt;string&gt; The quantities of tokens to transfer
--- @param cast boolean The cast is set to true to silence the transfer notice
--- @param useReply boolean Whether to use `msg.reply` or `ao.send`
--- @param msg Message The message received
--- @return table&lt;Message&gt;|Message|nil The transfer notices, error notice or nothing
function SemiFungibleTokensMethods:transferBatch(from, recipient, ids, quantities, cast, msg, useReply)
  local ids_ = {}
  local quantities_ = {}

  for i = 1, #ids do
    if not self.balancesById[ ids[i] ] then self.balancesById[ ids[i] ] = {} end
    if not self.balancesById[ ids[i] ][from] then self.balancesById[ ids[i] ][from] = &quot;0&quot; end
    if not self.balancesById[ ids[i] ][recipient] then self.balancesById[ ids[i] ][recipient] = &quot;0&quot; end

    local qty = bint(quantities[i])
    local balance = bint(self.balancesById[ ids[i] ][from])

    if bint.__le(qty, balance) then
      self.balancesById[ ids[i] ][from] = tostring(bint.__sub(balance, qty))
      self.balancesById[ ids[i] ][recipient] = tostring(bint.__add(self.balancesById[ ids[i] ][recipient], qty))
      table.insert(ids_, ids[i])
      table.insert(quantities_, quantities[i])
    else
      return self.transferErrorNotice(ids[i], msg)
    end
  end

  -- Only send the notifications if the cast tag is not set
  if not cast and #ids_ &gt; 0 then
    return self.transferBatchNotices(from, recipient, ids_, quantities_, msg, useReply)
  end
end

--- Get account balance of tokens with the given ID
--- @param sender string The process ID of the sender
--- @param recipient string|nil The process ID of the recipient (optional)
--- @param id string The ID of the token
--- @return string The balance of the account for the given ID
function SemiFungibleTokensMethods:getBalance(sender, recipient, id)
  local bal = &#39;0&#39;
  -- If ID is found then continue
  if self.balancesById[id] then
    -- If recipient is not provided, return the senders balance
    if (recipient and self.balancesById[id][recipient]) then
      bal = self.balancesById[id][recipient]
    elseif self.balancesById[id][sender] then
      bal = self.balancesById[id][sender]
    end
  end
  -- return balance
  return bal
end

--- Get accounts&#39; balance of tokens with the given IDs
--- @param recipients table&lt;string&gt; The process IDs of the recipients
--- @param ids table&lt;string&gt; The IDs of the tokens
--- @return table&lt;string&gt; The balances of the recipients for each respective ID
function SemiFungibleTokensMethods:getBatchBalance(recipients, ids)
  assert(#recipients == #ids, &#39;Recipients and Ids must have same lengths&#39;)
  local bals = {}

  for i = 1, #recipients do
    table.insert(bals, &#39;0&#39;)
    if self.balancesById[ ids[i] ] then
      if self.balancesById[ ids[i] ][ recipients[i] ] then
        bals[i] = self.balancesById[ ids[i] ][ recipients[i] ]
      end
    end
  end

  return bals
end

--- Get account balances of tokens with the given ID
--- @param id string The ID of the token
--- @return table&lt;string, string&gt; The account balances for the given ID
function SemiFungibleTokensMethods:getBalances(id)
  local bals = {}
  if self.balancesById[id] then
    bals = self.balancesById[id]
  end
  -- return balances
  return bals
end

--- Get accounts&#39; balances of tokens with the given IDs
--- @param positionIds table&lt;string&gt; The IDs of the tokens
--- @return table&lt;string, table&lt;string, string&gt;&gt; The account balances for each respective ID
function SemiFungibleTokensMethods:getBatchBalances(positionIds)
  local bals = {}

  for i = 1, #positionIds do
    bals[ positionIds[i] ] = {}
    if self.balancesById[ positionIds[i] ] then
      bals[ positionIds[i] ] = self.balancesById[ positionIds[i] ]
    end
  end
  -- return balances
  return bals
end

return SemiFungibleTokens

end

_G.package.loaded[&quot;marketModules.semiFungibleTokens&quot;] = _loaded_mod_marketModules_semiFungibleTokens()

-- module: &quot;marketModules.conditionalTokens&quot;
local function _loaded_mod_marketModules_conditionalTokens()
--[[
======================================================================================
Outcome © 2025. All Rights Reserved.
======================================================================================
This code is proprietary and owned by Outcome.

You are permitted to build applications, integrations, and extensions that interact
with the Outcome Protocol, provided such usage adheres to the official Outcome
terms of service and does not result in unauthorized forks or clones of this codebase.

Redistribution, modification, or unauthorized use of this code is strictly prohibited
without explicit written permission from Outcome.
======================================================================================
]]

local ConditionalTokens = {}
local ConditionalTokensMethods = {}
local ConditionalTokensNotices = require(&#39;marketModules.conditionalTokensNotices&#39;)
local SemiFungibleTokens = require(&#39;marketModules.semiFungibleTokens&#39;)
local bint = require(&#39;.bint&#39;)(256)
local ao = ao or require(&#39;.ao&#39;)

--- Represents ConditionalTokens
--- @class ConditionalTokens
--- @field name string The token name
--- @field ticker string The token ticker
--- @field logo string The token logo Arweave TxID
--- @field balancesById table&lt;string, table&lt;string, string&gt;&gt; The account token balances by ID
--- @field totalSupplyById table&lt;string, string&gt; The total supply of the token by ID
--- @field denomination number The number of decimals
--- @field resolutionAgent string The process ID of the resolution agent
--- @field collateralToken string The process ID of the collateral token
--- @field positionIds table&lt;string&gt; The position IDs representing outcomes
--- @field payoutNumerators table&lt;number&gt; The relative payouts for each outcome slot
--- @field payoutDenominator number The sum of payout numerators, zero if unreported
--- @field creatorFee number The creator fee to be paid, in basis points
--- @field creatorFeeTarget string The process ID to receive the creator fee
--- @field protocolFee number The protocol fee to be paid, in basis points
--- @field protocolFeeTarget string The process ID to receive the protocol fee

--- Creates a new ConditionalTokens instance
--- @param name string The token name
--- @param ticker string The token ticker
--- @param logo string The token logo Arweave TxID
--- @param balancesById table&lt;string, table&lt;string, string&gt;&gt; The account token balances by ID
--- @param totalSupplyById table&lt;string, string&gt; The total supply of the token by ID
--- @param denomination number The number of decimals
--- @param resolutionAgent string The process ID of the resolution agent
--- @param collateralToken string The process ID of the collateral token
--- @param positionIds table&lt;string&gt; The position IDs representing outcomes
--- @param creatorFee number The creator fee to be paid, in basis points
--- @param creatorFeeTarget string The process ID to receive the creator fee
--- @param protocolFee number The protocol fee to be paid, in basis points
--- @param protocolFeeTarget string The process ID to receive the protocol fee
--- @return ConditionalTokens conditionalTokens The new ConditionalTokens instance
function ConditionalTokens.new(
  name,
  ticker,
  logo,
  balancesById,
  totalSupplyById,
  denomination,
  resolutionAgent,
  collateralToken,
  positionIds,
  creatorFee,
  creatorFeeTarget,
  protocolFee,
  protocolFeeTarget
)
  ---@class ConditionalTokens : SemiFungibleTokens
  local conditionalTokens = SemiFungibleTokens.new(name, ticker, logo, balancesById, totalSupplyById, denomination)
  conditionalTokens.resolutionAgent = resolutionAgent
  conditionalTokens.collateralToken = collateralToken
  conditionalTokens.positionIds = positionIds
  conditionalTokens.creatorFee = tonumber(creatorFee) or 0
  conditionalTokens.creatorFeeTarget = creatorFeeTarget
  conditionalTokens.protocolFee = tonumber(protocolFee) or 0
  conditionalTokens.protocolFeeTarget = protocolFeeTarget
  conditionalTokens.payoutDenominator = 0
  -- Initialize the payout vector as zeros.
  conditionalTokens.payoutNumerators = {}
  for _ = 1, #positionIds do
    table.insert(conditionalTokens.payoutNumerators, 0)
  end
  -- Initialize the denominator to zero to indicate that the condition has not been resolved.
  conditionalTokens.payoutDenominator = 0

  local semiFungibleTokensMetatable = getmetatable(conditionalTokens)
  setmetatable(conditionalTokens, {
    __index = function(_, k)
      if ConditionalTokensMethods[k] then
        return ConditionalTokensMethods[k]
      elseif ConditionalTokensNotices[k] then
        return ConditionalTokensNotices[k]
      else
        -- Fallback directly to the parent metatable
        return semiFungibleTokensMetatable.__index(_, k)
      end
    end
  })
  return conditionalTokens
end

--- Split position
--- @param from string The process ID of the account that split the position
--- @param collateralToken string The process ID of the collateral token
--- @param quantity string The quantity of collateral to split
--- @param msg Message The message received
--- @return Message The position split notice
function ConditionalTokensMethods:splitPosition(from, collateralToken, quantity, msg)
  assert(self.payoutNumerators and #self.payoutNumerators &gt; 0, &quot;Condition not prepared!&quot;)
  -- Create equal split positions.
  local quantities = {}
  for _ = 1, #self.positionIds do
    table.insert(quantities, quantity)
  end
  -- Mint the stake in the split target positions.
  self:batchMint(from, self.positionIds, quantities, msg)
  -- Send notice.
  return self.positionSplitNotice(from, collateralToken, quantity, msg)
end

--- Merge positions
--- @param from string The process ID of the account that merged the positions
--- @param onBehalfOf string The process ID of the account that will receive the collateral
--- @param quantity string The quantity of collateral to merge
--- @param isSell boolean True if the merge is a sell, false otherwise
--- @param msg Message The message received
--- @param useReply boolean Whether to use `msg.reply` or `ao.send`
--- @return Message The positions merge notice
function ConditionalTokensMethods:mergePositions(from, onBehalfOf, quantity, isSell, msg, useReply)
  assert(self.payoutNumerators and #self.payoutNumerators &gt; 0, &quot;Condition not prepared!&quot;)
  -- Create equal merge positions.
  local quantities = {}
  for _ = 1, #self.positionIds do
    table.insert(quantities, quantity)
  end
  -- Burn equal quantiies from user positions.
  self:batchBurn(from, self.positionIds, quantities, msg, false)
  -- @dev below already handled within the sell method.
  -- sell method w&#47; a different quantity and recipient.
  if not isSell then
    -- Return the collateral to the user.
    ao.send({
      Target = self.collateralToken,
      Action = &quot;Transfer&quot;,
      Quantity = quantity,
      Recipient = onBehalfOf
    })
  end
  -- Send notice.
  return self.positionsMergeNotice(self.collateralToken, quantity, msg, useReply)
end

--- Report payouts
--- @param payouts table&lt;number&gt; The resolution agent&#39;s answer
--- @param msg Message The message received
--- @return Message reportPayoutsNotice The report payouts notice
function ConditionalTokensMethods:reportPayouts(payouts, msg)
  assert(#payouts == #self.positionIds, &quot;Payouts must match outcome slot count!&quot;)
  assert(msg.From == self.resolutionAgent, &quot;Sender not resolution agent!&quot;)
  assert(self.payoutDenominator == 0, &quot;payout denominator already set&quot;)
  -- Set the payout vector for the condition.
  local den = 0
  for i = 1, #self.positionIds do
    local num = payouts[i]
    den = den + num
    assert(self.payoutNumerators[i] == 0, &quot;payout numerator already set&quot;)
    self.payoutNumerators[i] = num
  end
  assert(den &gt; 0, &quot;payout is all zeroes&quot;)
  self.payoutDenominator = den
  -- Send notice.
  return self.reportPayoutsNotice(msg.From, self.payoutNumerators, msg)
end

--- Redeem positions
--- Transfers any payout minus fees to the message sender
--- @param msg Message The message received
--- @return Message The payout redemption notice
function ConditionalTokensMethods:redeemPositions(msg)
  local den = self.payoutDenominator
  assert(den &gt; 0, &quot;market not resolved&quot;)
  assert(self.payoutNumerators and #self.payoutNumerators &gt; 0, &quot;market not initialized&quot;)
  local totalPayout = 0
  local totalPayoutMinusFee = &quot;0&quot;
  for i = 1, #self.positionIds do
    local positionId = self.positionIds[i]
    local payoutNumerator = self.payoutNumerators[tonumber(positionId)]
    -- Get the stake to redeem.
    if not self.balancesById[positionId] then self.balancesById[positionId] = {} end
    if not self.balancesById[positionId][msg.From] then self.balancesById[positionId][msg.From] = &quot;0&quot; end
    local payoutStake = self.balancesById[positionId][msg.From]
    if bint.__lt(0, bint(payoutStake)) then
      -- Calculate the payout and burn position.
      totalPayout = math.floor(totalPayout + (payoutStake * payoutNumerator) &#47; den)
      self:burn(msg.From, positionId, payoutStake, msg, false)
    end
  end
  -- Return total payout minus take fee.
  if totalPayout &gt; 0 then
    totalPayout = math.floor(totalPayout)
    totalPayoutMinusFee = self:returnTotalPayoutMinusTakeFee(self.collateralToken, msg.From, totalPayout)
  end
  -- Send notice.
  return self.redeemPositionsNotice(self.collateralToken, totalPayout, totalPayoutMinusFee, msg)
end

--- Return total payout minus take fee
--- Distributes payout and fees to the redeem account, creator and protocol
--- @param collateralToken string The collateral token
--- @param from string The account to receive the payout minus fees
--- @param totalPayout number The total payout assciated with the acount stake
--- @return string The total payout minus fee amount
function ConditionalTokensMethods:returnTotalPayoutMinusTakeFee(collateralToken, from, totalPayout)
  local protocolFee =  tostring(bint.ceil(bint.__div(bint.__mul(totalPayout, self.protocolFee), 1e4)))
  local creatorFee =  tostring(bint.ceil(bint.__div(bint.__mul(totalPayout, self.creatorFee), 1e4)))
  local takeFee = tostring(bint.__add(bint(creatorFee), bint(protocolFee)))
  local totalPayoutMinusFee = tostring(bint.__sub(totalPayout, bint(takeFee)))
  -- prepare txns
  local protocolFeeTxn = {
    Target = collateralToken,
    Action = &quot;Transfer&quot;,
    Recipient = self.protocolFeeTarget,
    Quantity = protocolFee,
  }
  local creatorFeeTxn = {
    Target = collateralToken,
    Action = &quot;Transfer&quot;,
    Recipient = self.creatorFeeTarget,
    Quantity = creatorFee,
  }
  local totalPayoutMinutTakeFeeTxn = {
    Target = collateralToken,
    Action = &quot;Transfer&quot;,
    Recipient = from,
    Quantity = totalPayoutMinusFee
  }
  -- send txns
  ao.send(protocolFeeTxn)
  ao.send(creatorFeeTxn)
  ao.send(totalPayoutMinutTakeFeeTxn)

  return totalPayoutMinusFee
end

return ConditionalTokens

end

_G.package.loaded[&quot;marketModules.conditionalTokens&quot;] = _loaded_mod_marketModules_conditionalTokens()

-- module: &quot;marketModules.cpmm&quot;
local function _loaded_mod_marketModules_cpmm()
--[[
======================================================================================
Outcome © 2025. All Rights Reserved.
======================================================================================
This code is proprietary and owned by Outcome.

You are permitted to build applications, integrations, and extensions that interact
with the Outcome Protocol, provided such usage adheres to the official Outcome
terms of service and does not result in unauthorized forks or clones of this codebase.

Redistribution, modification, or unauthorized use of this code is strictly prohibited
without explicit written permission from Outcome.
======================================================================================
]]

local CPMM = {}
local CPMMMethods = {}
local CPMMHelpers = require(&#39;marketModules.cpmmHelpers&#39;)
local CPMMNotices = require(&#39;marketModules.cpmmNotices&#39;)
local bint = require(&#39;.bint&#39;)(256)
local utils = require(&quot;.utils&quot;)
local token = require(&#39;marketModules.token&#39;)
local constants = require(&quot;marketModules.constants&quot;)
local conditionalTokens = require(&#39;marketModules.conditionalTokens&#39;)

--- Represents a CPMM (Constant Product Market Maker)
--- @class CPMM
--- @field configurator string The process ID of the configurator
--- @field poolBalances table&lt;string, ...&gt; The pool balance for each respective position ID
--- @field withdrawnFees table&lt;string, string&gt; The amount of fees withdrawn by an account
--- @field feePoolWeight string The total amount of fees collected
--- @field totalWithdrawnFees string The total amount of fees withdrawn

--- Creates a new CPMM instance
--- @param configurator string The process ID of the configurator
--- @param collateralToken string The process ID of the collateral token
--- @param resolutionAgent string The process ID of the resolution agent
--- @param positionIds table&lt;string, ...&gt; The position IDs
--- @param name string The CPMM token(s) name
--- @param ticker string The CPMM token(s) ticker
--- @param logo string The CPMM token(s) logo
--- @param lpFee number The liquidity provider fee
--- @param creatorFee number The market creator fee
--- @param creatorFeeTarget string The market creator fee target
--- @param protocolFee number The protocol fee
--- @param protocolFeeTarget string The protocol fee target
--- @return CPMM cpmm The new CPMM instance
function CPMM.new(configurator, collateralToken, resolutionAgent, positionIds, name, ticker, logo, lpFee, creatorFee, creatorFeeTarget, protocolFee, protocolFeeTarget)
  local cpmm = {
    configurator = configurator,
    poolBalances = {},
    withdrawnFees = {},
    feePoolWeight = &quot;0&quot;,
    totalWithdrawnFees = &quot;0&quot;,
    lpFee = tonumber(lpFee)
  }
  cpmm.token = token.new(
    name .. &quot; LP Token&quot;,
    ticker,
    logo,
    {}, -- balances
    &quot;0&quot;, -- totalSupply
    constants.denomination
  )
  cpmm.tokens = conditionalTokens.new(
    name .. &quot; Conditional Tokens&quot;,
    ticker,
    logo,
    {}, -- balancesById
    {}, -- totalSupplyById
    constants.denomination,
    resolutionAgent,
    collateralToken,
    positionIds,
    creatorFee,
    creatorFeeTarget,
    protocolFee,
    protocolFeeTarget
  )
  setmetatable(cpmm, {
    __index = function(_, k)
      if CPMMMethods[k] then
        return CPMMMethods[k]
      elseif CPMMHelpers[k] then
        return CPMMHelpers[k]
      elseif CPMMNotices[k] then
        return CPMMNotices[k]
      else
        return nil
      end
    end
  })
  return cpmm
end

--- Add funding
--- @param onBehalfOf string The process ID of the account to receive the LP tokens
--- @param addedFunds string The amount of funds to add
--- @param distributionHint table&lt;number&gt; The initial probability distribution
--- @param msg Message The message received
--- @return Message The funding added notice
function CPMMMethods:addFunding(onBehalfOf, addedFunds, distributionHint, msg)
  assert(bint.__lt(0, bint(addedFunds)), &quot;funding must be non-zero&quot;)
  local sendBackAmounts = {}
  local poolShareSupply = self.token.totalSupply
  local mintAmount

  if bint.iszero(bint(poolShareSupply)) then
    assert(distributionHint, &quot;must use distribution hint for initial funding&quot;)
    -- Initial Liquidity
    if #distributionHint &gt; 0 then
      local maxHint = 0
      for i = 1, #distributionHint do
        local hint = distributionHint[i]
        if maxHint &lt; hint then
          maxHint = hint
        end
      end
      -- Calculate sendBackAmounts
      for i = 1, #distributionHint do
        local remaining = math.floor((addedFunds * distributionHint[i]) &#47; maxHint)
        assert(remaining &gt; 0, &quot;must hint a valid distribution&quot;)
        sendBackAmounts[i] = addedFunds - remaining
      end
    end
    -- Calculate mintAmount
    mintAmount = tostring(addedFunds)
  else
    -- Additional Liquidity
    assert(not distributionHint, &quot;cannot use distribution hint after initial funding&quot;)
    -- Get poolBalances
    local poolBalances = self:getPoolBalances()
    -- Calculate poolWeight
    local poolWeight = 0
    for i = 1, #poolBalances do
      local balance = poolBalances[i]
      if bint.__lt(poolWeight, bint(balance)) then
        poolWeight = bint(balance)
      end
    end
    -- Calculate sendBackAmounts
    for i = 1, #poolBalances do
      local remaining = math.floor((addedFunds * poolBalances[i]) &#47; poolWeight)
      sendBackAmounts[i] = addedFunds - remaining
    end
    -- Calculate mintAmount
    ---@diagnostic disable-next-line: param-type-mismatch
    mintAmount = tostring(math.floor(tostring(bint.__div(bint.__mul(addedFunds, poolShareSupply), poolWeight))))
  end
  -- Mint Conditional Positions
  self.tokens:splitPosition(ao.id, self.tokens.collateralToken, addedFunds, msg)
  -- Mint LP Tokens
  self:mint(onBehalfOf, mintAmount, msg)
  -- Remove non-zero items before transfer-batch
  local nonZeroAmounts = {}
  local nonZeroPositionIds = {}
  for i = 1, #sendBackAmounts do
    if sendBackAmounts[i] &gt; 0 then
      table.insert(nonZeroAmounts, tostring(math.floor(sendBackAmounts[i])))
      table.insert(nonZeroPositionIds, self.tokens.positionIds[i])
    end
  end
  -- Send back conditional tokens should there be an uneven distribution
  if #nonZeroAmounts ~= 0 then
    self.tokens:transferBatch(ao.id, onBehalfOf, nonZeroPositionIds, nonZeroAmounts, true, msg)
  end
  -- Transform sendBackAmounts to array of amounts added
  for i = 1, #sendBackAmounts do
    sendBackAmounts[i] = addedFunds - sendBackAmounts[i]
  end
  -- Send notice with amounts added
  return self.addFundingNotice(sendBackAmounts, mintAmount, msg)
end

--- Remove funding
--- @param from string The process ID of the account that removed the funding
--- @param sharesToBurn string The amount of shares to burn
--- @param msg Message The message received
--- @return Message The funding removed notice
function CPMMMethods:removeFunding(from, sharesToBurn, msg)
  assert(bint.__lt(0, bint(sharesToBurn)), &quot;funding must be non-zero&quot;)
  -- Get poolBalances
  local poolBalances = self:getPoolBalances()
  -- Calculate sendAmounts
  local sendAmounts = {}
  for i = 1, #poolBalances do
    sendAmounts[i] = tostring(math.floor((poolBalances[i] * sharesToBurn) &#47; self.token.totalSupply))
  end
  -- Calculate collateralRemovedFromFeePool
  local collateralRemovedFromFeePool = ao.send({Target = self.tokens.collateralToken, Action = &#39;Balance&#39;}).receive().Data
  self:burn(from, sharesToBurn, msg)
  local poolFeeBalance = ao.send({Target = self.tokens.collateralToken, Action = &#39;Balance&#39;}).receive().Data
  collateralRemovedFromFeePool = tostring(math.floor(poolFeeBalance - collateralRemovedFromFeePool))
  -- Send conditionalTokens amounts
  self.tokens:transferBatch(ao.id, from, self.tokens.positionIds, sendAmounts, false, msg)
  -- Send notice
  return self.removeFundingNotice(sendAmounts, collateralRemovedFromFeePool, sharesToBurn, msg)
end

--- Calc buy amount
--- @param investmentAmount number The amount to stake on an outcome
--- @param positionId string The position ID of the outcome
--- @return string The amount of tokens to be purchased
function CPMMMethods:calcBuyAmount(investmentAmount, positionId)
  assert(bint.__lt(0, investmentAmount), &#39;InvestmentAmount must be greater than zero!&#39;)
  assert(utils.includes(positionId, self.tokens.positionIds), &#39;PositionId must be valid!&#39;)

  local poolBalances = self:getPoolBalances()
  local investmentAmountMinusFees = investmentAmount - ((investmentAmount * self.lpFee) &#47; 1e4) -- converts fee from basis points to decimal
  local buyTokenPoolBalance = poolBalances[tonumber(positionId)]
  local endingOutcomeBalance = buyTokenPoolBalance * 1e4

  for i = 1, #poolBalances do
    if not bint.__eq(bint(i), bint(positionId)) then
      local poolBalance = poolBalances[i]
      endingOutcomeBalance = CPMMHelpers.ceildiv(endingOutcomeBalance * poolBalance, poolBalance + investmentAmountMinusFees)
    end
  end

  assert(endingOutcomeBalance &gt; 0, &quot;must have non-zero balances&quot;)
  return tostring(bint.ceil(buyTokenPoolBalance + investmentAmountMinusFees - CPMMHelpers.ceildiv(endingOutcomeBalance, 1e4)))
end

--- Calc sell amount
--- @param returnAmount number The amount to unstake from an outcome
---@param positionId string The position ID of the outcome
---@return string The amount of tokens to be sold
function CPMMMethods:calcSellAmount(returnAmount, positionId)
  assert(bint.__lt(0, returnAmount), &#39;ReturnAmount must be greater than zero!&#39;)
  assert(utils.includes(positionId, self.tokens.positionIds), &#39;PositionId must be valid!&#39;)

  local poolBalances = self:getPoolBalances()
  local returnAmountPlusFees = CPMMHelpers.ceildiv(returnAmount * 1e4, 1e4 - self.lpFee)
  local sellTokenPoolBalance = poolBalances[tonumber(positionId)]
  local endingOutcomeBalance = sellTokenPoolBalance * 1e4

  for i = 1, #poolBalances do
    if not bint.__eq(bint(i), bint(positionId)) then
      local poolBalance = poolBalances[i]
      assert(poolBalance - returnAmountPlusFees &gt; 0, &quot;PoolBalance must be greater than return amount plus fees!&quot;)
      endingOutcomeBalance = CPMMHelpers.ceildiv(endingOutcomeBalance * poolBalance, poolBalance - returnAmountPlusFees)
    end
  end

  assert(endingOutcomeBalance &gt; 0, &quot;must have non-zero balances&quot;)
  return tostring(bint.ceil(returnAmountPlusFees + CPMMHelpers.ceildiv(endingOutcomeBalance, 1e4) - sellTokenPoolBalance))
end

--- Calc probabilities
--- @return table&lt;string, number&gt; probabilities A table mapping each positionId to its probability (as a decimal percentage)
function CPMMMethods:calcProbabilities()
  local poolBalances = self:getPoolBalances()
  local totalBalance = bint(0)
  local probabilities = {}
  -- Calculate total balance
  for i = 1, #self.tokens.positionIds do
    totalBalance = bint.__add(totalBalance, bint(poolBalances[i]))
  end
  assert(bint.__lt(bint(0), totalBalance), &#39;Total pool balance must be greater than zero!&#39;)
  -- Calculate probabilities for each positionId
  for i = 1, #self.tokens.positionIds do
    local positionId = self.tokens.positionIds[i]
    local balance = bint(poolBalances[i])
    local probability = tostring(bint.__div(balance, totalBalance))
    probabilities[positionId] = probability
  end
  return probabilities
end

--- Buy
--- @param from string The process ID of the account that initiates the buy
--- @param onBehalfOf string The process ID of the account to receive the tokens
--- @param investmentAmount number The amount to stake on an outcome
--- @param positionId string The position ID of the outcome
--- @param minPositionTokensToBuy number The minimum number of outcome tokens to buy
--- @param msg Message The message received
--- @return Message The buy notice
function CPMMMethods:buy(from, onBehalfOf, investmentAmount, positionId, minPositionTokensToBuy, msg)
  local positionTokensToBuy = self:calcBuyAmount(investmentAmount, positionId)
  assert(bint.__le(minPositionTokensToBuy, bint(positionTokensToBuy)), &quot;Minimum position tokens not reached!&quot;)
  -- Calculate investmentAmountMinusFees.
  local feeAmount = tostring(bint.ceil(bint.__div(bint.__mul(investmentAmount, self.lpFee), 1e4)))
  self.feePoolWeight = tostring(bint.__add(bint(self.feePoolWeight), bint(feeAmount)))
  local investmentAmountMinusFees = tostring(bint.__sub(investmentAmount, bint(feeAmount)))
  -- Split position through all conditions
  self.tokens:splitPosition(ao.id, self.tokens.collateralToken, investmentAmountMinusFees, msg)
  -- Transfer buy position to onBehalfOf
  self.tokens:transferSingle(ao.id, onBehalfOf, positionId, positionTokensToBuy, true, msg, false)
  -- Send notice.
  return self.buyNotice(from, onBehalfOf, investmentAmount, feeAmount, positionId, positionTokensToBuy, msg)
end

--- Sell
--- @param from string The process ID of the account that initiates the sell
--- @param returnAmount number The amount to unstake from an outcome
--- @param positionId string The position ID of the outcome
--- @param maxPositionTokensToSell number The max outcome tokens to sell
--- @return Message The sell notice
function CPMMMethods:sell(from, returnAmount, positionId, maxPositionTokensToSell, msg)
  -- Calculate outcome tokens to sell.
  local positionTokensToSell = self:calcSellAmount(returnAmount, positionId)
  assert(bint.__le(bint(positionTokensToSell), bint(maxPositionTokensToSell)), &quot;Maximum sell amount exceeded!&quot;)
  -- Calculate returnAmountPlusFees.
  local feeAmount = tostring(bint.ceil(bint.__div(bint.__mul(returnAmount, self.lpFee), bint.__sub(1e4, self.lpFee))))
  self.feePoolWeight = tostring(bint.__add(bint(self.feePoolWeight), bint(feeAmount)))
  local returnAmountPlusFees = tostring(bint.__add(returnAmount, bint(feeAmount)))
  -- Check sufficient liquidity within the process or revert.
  local collataralBalance = ao.send({Target = self.tokens.collateralToken, Action = &quot;Balance&quot;, [&quot;X-Action&quot;] = &quot;Check Liquidity&quot;}).receive().Data
  assert(bint.__le(bint(returnAmountPlusFees), bint(collataralBalance)), &quot;Insufficient liquidity!&quot;)
  -- Check user balance and transfer positionTokensToSell to process before merge.
  local balance = self.tokens:getBalance(from, nil, positionId)
  assert(bint.__le(bint(positionTokensToSell), bint(balance)), &#39;Insufficient balance!&#39;)
  self.tokens:transferSingle(from, ao.id, positionId, positionTokensToSell, true, msg, false)
  -- Merge positions through all conditions (burns returnAmountPlusFees).
  self.tokens:mergePositions(ao.id, &#39;&#39;, positionTokensToSell, true, msg, false)
  -- Returns collateral to the user
  msg.forward(self.tokens.collateralToken,{
    Action = &quot;Transfer&quot;,
    Quantity = tostring(returnAmount),
    Recipient = from
  })
  -- Send notice (Process continued via &quot;SellOrderCompletionCollateralToken&quot; and &quot;SellOrderCompletionConditionalTokens&quot; handlers)
  return self.sellNotice(from, returnAmount, feeAmount, positionId, positionTokensToSell, msg)
end

--- Colleced fees
--- @return string The total unwithdrawn fees collected by the CPMM
function CPMMMethods:collectedFees()
  return tostring(math.ceil(self.feePoolWeight - self.totalWithdrawnFees))
end

--- Fees withdrawable
--- @param account string The process ID of the account
--- @return string The fees withdrawable by the account
function CPMMMethods:feesWithdrawableBy(account)
  local balance = self.token.balances[account] or &#39;0&#39;
  local rawAmount = &#39;0&#39;
  if bint(self.token.totalSupply) &gt; 0 then
    rawAmount = string.format(&#39;%.0f&#39;, (bint.__div(bint.__mul(bint(self:collectedFees()), bint(balance)), self.token.totalSupply)))
  end
  return tostring(bint.max(bint(bint.__sub(bint(rawAmount), bint(self.withdrawnFees[account] or &#39;0&#39;))), 0))
end

--- Withdraw fees
--- @param sender string The process ID of the sender
--- @param msg Message The message received
--- @param useReply boolean Whether to use `msg.reply` or `ao.send`
--- @return Message The withdraw fees message
function CPMMMethods:withdrawFees(sender, msg, useReply)
  local feeAmount = self:feesWithdrawableBy(sender)
  if bint.__lt(0, bint(feeAmount)) then
    self.withdrawnFees[sender] = feeAmount
    self.totalWithdrawnFees = tostring(bint.__add(bint(self.totalWithdrawnFees), bint(feeAmount)))
    msg.forward(self.tokens.collateralToken, {Action = &#39;Transfer&#39;, Recipient = sender, Quantity = feeAmount})
  end
  return self.withdrawFeesNotice(feeAmount, msg, useReply)
end

--- Before token transfer
--- Updates fee accounting before token transfers
--- @param from string|nil The process ID of the account executing the transaction
--- @param to string|nil The process ID of the account receiving the transaction
--- @param amount string The amount transferred
--- @param msg Message The message received
function CPMMMethods:_beforeTokenTransfer(from, to, amount, msg)
  if from ~= nil and from ~= ao.id then
    self:withdrawFees(from, msg, false)
  end
  local totalSupply = self.token.totalSupply
  local withdrawnFeesTransfer = totalSupply == &#39;0&#39; and amount or tostring(bint(bint.__div(bint.__mul(bint(self:collectedFees()), bint(amount)), totalSupply)))

  if from ~= nil and to ~= nil and from ~= ao.id then
    self.withdrawnFees[from] = tostring(bint.__sub(bint(self.withdrawnFees[from] or &#39;0&#39;), bint(withdrawnFeesTransfer)))
    self.withdrawnFees[to] = tostring(bint.__add(bint(self.withdrawnFees[to] or &#39;0&#39;), bint(withdrawnFeesTransfer)))
  end
end

--- @dev See `Mint` in modules.token
function CPMMMethods:mint(to, quantity, msg)
  self:_beforeTokenTransfer(nil, to, quantity, msg)
  return self.token:mint(to, quantity, msg)
end

--- @dev See `Burn` in modules.token
-- @dev See tokenMethods:burn &amp; _beforeTokenTransfer
function CPMMMethods:burn(from, quantity, msg)
  self:_beforeTokenTransfer(from, nil, quantity, msg)
  return self.token:burn(from, quantity, msg)
end

--- @dev See `Transfer` in modules.token
-- @dev See tokenMethods:transfer &amp; _beforeTokenTransfer
function CPMMMethods:transfer(from, recipient, quantity, cast, msg)
  self:_beforeTokenTransfer(from, recipient, quantity, msg)
  return self.token:transfer(from, recipient, quantity, cast, msg)
end

--- Update configurator
--- @param configurator string The process ID of the new configurator
--- @param msg Message The message received
--- @return Message The update configurator notice
function CPMMMethods:updateConfigurator(configurator, msg)
  self.configurator = configurator
  return self.updateConfiguratorNotice(configurator, msg)
end

--- Update take fee
--- @param creatorFee string The new creator fee in basis points
--- @param protocolFee string The new protocol fee in basis points
--- @param msg Message The message received
--- @return Message The update take fee notice
function CPMMMethods:updateTakeFee(creatorFee, protocolFee, msg)
  self.tokens.creatorFee = creatorFee
  self.tokens.protocolFee = protocolFee
  return self.updateTakeFeeNotice(creatorFee, protocolFee, creatorFee + protocolFee, msg)
end

--- Update protocol fee targer
--- @param target string The process ID of the new protocol fee target
--- @param msg Message The message received
--- @return Message The update protocol fee target notice
function CPMMMethods:updateProtocolFeeTarget(target, msg)
  self.tokens.protocolFeeTarget = target
  return self.updateProtocolFeeTargetNotice(target, msg)
end

--- Update logo
--- @param logo string The Arweave transaction ID of the new logo
--- @param msg Message The message received
--- @return Message The update logo notice
function CPMMMethods:updateLogo(logo, msg)
  self.token.logo = logo
  self.tokens.logo = logo
  return self.updateLogoNotice(logo, msg)
end

return CPMM
end

_G.package.loaded[&quot;marketModules.cpmm&quot;] = _loaded_mod_marketModules_cpmm()

-- module: &quot;marketModules.market&quot;
local function _loaded_mod_marketModules_market()
--[[
======================================================================================
Outcome © 2025. All Rights Reserved.
======================================================================================
This code is proprietary and owned by Outcome.

You are permitted to build applications, integrations, and extensions that interact
with the Outcome Protocol, provided such usage adheres to the official Outcome
terms of service and does not result in unauthorized forks or clones of this codebase.

Redistribution, modification, or unauthorized use of this code is strictly prohibited
without explicit written permission from Outcome.
======================================================================================
]]

local Market = {}
local MarketMethods = {}
local MarketNotices = require(&#39;marketModules.marketNotices&#39;)
local json = require(&#39;json&#39;)
local bint = require(&#39;.bint&#39;)(256)
local cpmm = require(&#39;marketModules.cpmm&#39;)

--- Represents a Market
--- @class Market
--- @field cpmm CPMM The Constant Product Market Maker

--- Creates a new Market instance
--- @param configurator string The process ID of the configurator
--- @param dataIndex string The process ID of the data index process
--- @param collateralToken string The process ID of the collateral token
--- @param resolutionAgent string The process ID of the resolution agent
--- @param creator string The address of the market creator
--- @param question string The market question
--- @param rules string The market rules
--- @param category string The market category
--- @param subcategory string The market subcategory
--- @param positionIds table&lt;string, ...&gt; The position IDs
--- @param name string The CPMM token(s) name
--- @param ticker string The CPMM token(s) ticker
--- @param logo string The CPMM token(s) logo
--- @param lpFee number The liquidity provider fee
--- @param creatorFee number The market creator fee
--- @param creatorFeeTarget string The market creator fee target
--- @param protocolFee number The protocol fee
--- @param protocolFeeTarget string The protocol fee target
--- @return Market market The new Market instance
function Market.new(
  configurator,
  dataIndex,
  collateralToken,
  resolutionAgent,
  creator,
  question,
  rules,
  category,
  subcategory,
  positionIds,
  name,
  ticker,
  logo,
  lpFee,
  creatorFee,
  creatorFeeTarget,
  protocolFee,
  protocolFeeTarget
)
  local market = {
    cpmm = cpmm.new(
      configurator,
      collateralToken,
      resolutionAgent,
      positionIds,
      name,
      ticker,
      logo,
      lpFee,
      creatorFee,
      creatorFeeTarget,
      protocolFee,
      protocolFeeTarget
    ),
    question = question,
    rules = rules,
    category = category,
    subcategory = subcategory,
    creator = creator,
    dataIndex = dataIndex
  }
  setmetatable(market, {
    __index = function(_, k)
      if MarketMethods[k] then
        return MarketMethods[k]
      elseif MarketNotices[k] then
        return MarketNotices[k]
      else
        return nil
      end
    end
  })
  return market
end

--- Info
--- @param msg Message The message received
--- @return Message The info message
function MarketMethods:info(msg)
  return msg.reply({
    Name = self.cpmm.token.name,
    Ticker = self.cpmm.token.ticker,
    Logo = self.cpmm.token.logo,
    Denomination = tostring(self.cpmm.token.denomination),
    PositionIds = json.encode(self.cpmm.tokens.positionIds),
    CollateralToken = self.cpmm.tokens.collateralToken,
    Configurator = self.cpmm.configurator,
    DataIndex = self.dataIndex,
    ResolutionAgent = self.cpmm.tokens.resolutionAgent,
    Question = self.question,
    Rules = self.rules,
    Category = self.category,
    Subcategory = self.subcategory,
    Creator = self.creator,
    LpFee = tostring(self.cpmm.lpFee),
    LpFeePoolWeight = self.cpmm.feePoolWeight,
    LpFeeTotalWithdrawn = self.cpmm.totalWithdrawnFees,
    CreatorFee = tostring(self.cpmm.tokens.creatorFee),
    CreatorFeeTarget = self.cpmm.tokens.creatorFeeTarget,
    ProtocolFee = tostring(self.cpmm.tokens.protocolFee),
    ProtocolFeeTarget = self.cpmm.tokens.protocolFeeTarget,
    Owner = Owner
  })
end

--[[
=============
ACTIVITY LOGS
=============
]]

local function logFunding(dataIndex, user, operation, collateral, quantity, msg)
  return msg.forward(dataIndex, {
    Action = &quot;Log-Funding&quot;,
    User = user,
    Operation = operation,
    Collateral = collateral,
    Quantity = quantity,
  })
end

local function logPrediction(dataIndex, user, operation, collateral, quantity, outcome, shares, price, msg)
  return msg.forward(dataIndex, {
    Action = &quot;Log-Prediction&quot;,
    User = user,
    Operation = operation,
    Collateral = collateral,
    Quantity = quantity,
    Outcome = outcome,
    Shares = shares,
    Price = price
  })
end

local function logProbabilities(dataIndex, probabilities, msg)
  return msg.forward(dataIndex, {
    Action = &quot;Log-Probabilities&quot;,
    Probabilities = json.encode(probabilities)
  })
end

--[[
==================
CPMM WRITE METHODS
==================
]]

--- Add funding
--- Message forwarded from the collateral token
--- @param msg Message The message received
function MarketMethods:addFunding(msg)
  local distribution = msg.Tags[&#39;X-Distribution&#39;] and json.decode(msg.Tags[&#39;X-Distribution&#39;]) or nil
  local onBehalfOf = msg.Tags[&#39;X-OnBehalfOf&#39;] or msg.Tags.Sender
  -- Add funding to the CPMM
  self.cpmm:addFunding(onBehalfOf, msg.Tags.Quantity, distribution, msg)
  -- Log funding update to data index
  logFunding(self.dataIndex, msg.Tags.Sender, &#39;add&#39;, self.cpmm.tokens.collateralToken, msg.Tags.Quantity, msg)
end

--- Remove funding
--- Message forwarded from the LP token
--- @param msg Message The message received
function MarketMethods:removeFunding(msg)
  -- Remove funding from the CPMM
  self.cpmm:removeFunding(msg.From, msg.Tags.Quantity, msg)
  -- Log funding update to data index
  logFunding(self.dataIndex, msg.From, &#39;remove&#39;, self.cpmm.tokens.collateralToken, msg.Tags.Quantity, msg)
end

--- Buy
--- Message forwarded from the collateral token
--- @param msg Message The message received
function MarketMethods:buy(msg)
  local onBehalfOf = msg.Tags[&#39;X-OnBehalfOf&#39;] or msg.Tags.Sender
  local positionTokensToBuy = self.cpmm:calcBuyAmount(msg.Tags.Quantity, msg.Tags[&#39;X-PositionId&#39;])
  -- Buy position tokens from the CPMM
  self.cpmm:buy(msg.Tags.Sender, onBehalfOf, msg.Tags.Quantity, msg.Tags[&#39;X-PositionId&#39;], tonumber(msg.Tags[&#39;X-MinPositionTokensToBuy&#39;]), msg)
  -- Log prediction and probability update to data index
  local price = tostring(bint.__div(bint(positionTokensToBuy), bint(msg.Tags.Quantity)))
  logPrediction(self.dataIndex, onBehalfOf, &quot;buy&quot;, self.cpmm.tokens.collateralToken, msg.Tags.Quantity, msg.Tags[&#39;X-PositionId&#39;], positionTokensToBuy, price, msg)
  logProbabilities(self.dataIndex, self.cpmm:calcProbabilities(), msg)
end

--- Sell
--- @param msg Message The message received
function MarketMethods:sell(msg)
  local positionTokensToSell = self.cpmm:calcSellAmount(msg.Tags.ReturnAmount, msg.Tags.PositionId)
  -- Sell position tokens to the CPMM
  self.cpmm:sell(msg.From, msg.Tags.ReturnAmount, msg.Tags.PositionId, msg.Tags.MaxPositionTokensToSell, msg)
  -- Log prediction and probability update to data index
  local price = tostring(bint.__div(positionTokensToSell, bint(msg.Tags.ReturnAmount)))
  logPrediction(self.dataIndex, msg.From, &quot;sell&quot;, self.cpmm.tokens.collateralToken, msg.Tags.ReturnAmount, msg.Tags.PositionId, positionTokensToSell, price, msg)
  logProbabilities(self.dataIndex, self.cpmm:calcProbabilities(), msg)
end

--- Withdraw fees
--- @param msg Message The message received
function MarketMethods:withdrawFees(msg)
  self.cpmm:withdrawFees(msg.From, msg, true)
end

--[[
=================
CPMM READ METHODS
=================
]]

--- Calc buy amount
--- @param msg Message The message received
--- @return Message calcBuyAmountNotice The calc buy amount notice
function MarketMethods:calcBuyAmount(msg)
  local buyAmount = self.cpmm:calcBuyAmount(msg.Tags.InvestmentAmount, msg.Tags.PositionId)
  return msg.reply({
    BuyAmount = buyAmount,
    PositionId =  msg.Tags.PositionId,
    InvestmentAmount = msg.Tags.InvestmentAmount,
    Data = buyAmount
  })
end

--- Calc sell amount
--- @param msg Message The message received
--- @return Message calcSellAmountNotice The calc sell amount notice
function MarketMethods:calcSellAmount(msg)
  local sellAmount = self.cpmm:calcSellAmount(msg.Tags.ReturnAmount, msg.Tags.PositionId)
  return msg.reply({
    SellAmount = sellAmount,
    PositionId = msg.Tags.PositionId,
    ReturnAmount = msg.Tags.ReturnAmount,
    Data = sellAmount
  })
end

--- Colleced fees
--- @return Message collectedFees The total unwithdrawn fees collected by the CPMM
function MarketMethods:collectedFees(msg)
  local fees = self.cpmm:collectedFees()
  return msg.reply({
    CollectedFees = fees,
    Data = fees
  })
end

--- Fees withdrawable
--- @param msg Message The message received
--- @return Message feesWithdrawable The fees withdrawable by the account
function MarketMethods:feesWithdrawable(msg)
  local account = msg.Tags[&#39;Recipient&#39;] or msg.From
  local fees = self.cpmm:feesWithdrawableBy(account)
  return msg.reply({
    FeesWithdrawable = fees,
    Account = account,
    Data = fees
  })
end

--[[
======================
LP TOKEN WRITE METHODS
======================
]]

--- Transfer
--- @param msg Message The message received
function MarketMethods:transfer(msg)
  self.cpmm:transfer(msg.From, msg.Tags.Recipient, msg.Tags.Quantity, msg.Tags.Cast, msg)
end

--[[
=====================
LP TOKEN READ METHODS
=====================
]]

--- Balance
--- @param msg Message The message received
--- @return Message balance The balance of the account
function MarketMethods:balance(msg)
  local bal = &#39;0&#39;

  -- If not Recipient is provided, then return the Senders balance
  if (msg.Tags.Recipient) then
    if (self.cpmm.token.balances[msg.Tags.Recipient]) then
      bal = self.cpmm.token.balances[msg.Tags.Recipient]
    end
  elseif msg.Tags.Target and self.cpmm.token.balances[msg.Tags.Target] then
    bal = self.cpmm.token.balances[msg.Tags.Target]
  elseif self.cpmm.token.balances[msg.From] then
    bal = self.cpmm.token.balances[msg.From]
  end

  return msg.reply({
    Balance = bal,
    Ticker = self.cpmm.token.ticker,
    Account = msg.Tags.Recipient or msg.From,
    Data = bal
  })
end

--- Balances
--- @param msg Message The message received
--- @return Message balances The balances of all accounts
function MarketMethods:balances(msg)
  return msg.reply({ Data = json.encode(self.cpmm.token.balances) })
end

--- Total supply
--- @param msg Message The message received
--- @return Message totalSupply The total supply of the LP token
function MarketMethods:totalSupply(msg)
  return msg.reply({ Data = json.encode(self.cpmm.token.totalSupply) })
end

--[[
================================
CONDITIONAL TOKENS WRITE METHODS
================================
]]

--- Merge positions
--- @param msg Message The message received
function MarketMethods:mergePositions(msg)
  local onBehalfOf = msg.Tags[&#39;OnBehalfOf&#39;] or msg.From
  self.cpmm.tokens:mergePositions(msg.From, onBehalfOf, msg.Tags.Quantity, false, msg, true)
end

--- Report payouts
--- @param msg Message The message received
function MarketMethods:reportPayouts(msg)
  local payouts = json.decode(msg.Tags.Payouts)
  self.cpmm.tokens:reportPayouts(payouts, msg)
end

--- Redeem positions
--- @param msg Message The message received
function MarketMethods:redeemPositions(msg)
  self.cpmm.tokens:redeemPositions(msg)
end

--[[
===============================
CONDITIONAL TOKENS READ METHODS
===============================
]]

--- Get payout numerators
--- @param msg Message The message received
--- @return Message payoutNumerators payout numerators for the condition
function MarketMethods:getPayoutNumerators(msg)
  return msg.reply({ Data = json.encode(self.cpmm.tokens.payoutNumerators) })
end

--- Get payout denominator
--- @param msg Message The message received
--- @return Message payoutDenominator The payout denominator for the condition
function MarketMethods:getPayoutDenominator(msg)
  return msg.reply({ Data = tostring(self.cpmm.tokens.payoutDenominator) })
end

--[[
==================================
SEMI-FUNGIBLE TOKENS WRITE METHODS
==================================
]]

--- Transfer single
--- @param msg Message The message received
function MarketMethods:transferSingle(msg)
  self.cpmm.tokens:transferSingle(msg.From, msg.Tags.Recipient, msg.Tags.PositionId, msg.Tags.Quantity, msg.Tags.Cast, msg, true)
end

--- Transfer batch
--- @param msg Message The message received
--- @return table&lt;Message&gt;|Message|nil transferBatchNotices The transfer notices, error notice or nothing
function MarketMethods:transferBatch(msg)
  local positionIds = json.decode(msg.Tags.PositionIds)
  local quantities = json.decode(msg.Tags.Quantities)
  return self.cpmm.tokens:transferBatch(msg.From, msg.Tags.Recipient, positionIds, quantities, msg.Tags.Cast, msg, true)
end

--[[
=================================
SEMI-FUNGIBLE TOKENS READ METHODS
=================================
]]

--- Balance by ID
--- @param msg Message The message received
--- @return Message balanceById The balance of the account filtered by ID
function MarketMethods:balanceById(msg)
  local account = msg.Tags.Recipient or msg.From
  local bal = self.cpmm.tokens:getBalance(msg.From, account, msg.Tags.PositionId)
  return msg.reply({
    Balance = bal,
    PositionId = msg.Tags.PositionId,
    Account = account,
    Data = bal
  })
end

--- Balances by ID
--- @param msg Message The message received
--- @return Message balancesById The balances of all accounts filtered by ID
function MarketMethods:balancesById(msg)
  local bals = self.cpmm.tokens:getBalances(msg.Tags.PositionId)
  return msg.reply({
    PositionId = msg.Tags.PositionId,
    Data = json.encode(bals)
  })
end

--- Batch balance
--- @param msg Message The message received
--- @return Message batchBalance The balance accounts filtered by IDs
function MarketMethods:batchBalance(msg)
  local recipients = json.decode(msg.Tags.Recipients)
  local positionIds = json.decode(msg.Tags.PositionIds)
  local bals = self.cpmm.tokens:getBatchBalance(recipients, positionIds)
  return msg.reply({
    PositionIds = msg.Tags.PositionIds,
    Accounts = msg.Tags.Recipients,
    Data = json.encode(bals)
  })
end

--- Batch balances
--- @param msg Message The message received
--- @return Message batchBalances The balances of all accounts filtered by IDs
function MarketMethods:batchBalances(msg)
  local positionIds = json.decode(msg.Tags.PositionIds)
  local bals = self.cpmm.tokens:getBatchBalances(positionIds)
  return msg.reply({ Data = json.encode(bals) })
end

--- Balances all
--- @param msg Message The message received
--- @return Message balances The balances of all accounts
function MarketMethods:balancesAll(msg)
  return msg.reply({ Data = json.encode(self.cpmm.tokens.balancesById) })
end

--[[
==========================
CONFIGURATOR WRITE METHODS
==========================
]]

--- Update configurator
--- @param msg Message The message received
--- @return Message updateConfiguratorNotice The update configurator notice
function MarketMethods:updateConfigurator(msg)
  return self.cpmm:updateConfigurator(msg.Tags.Configurator, msg)
end

--- Update data index
--- @param msg Message The message received
--- @return Message updateDataIndexNotice The update data index notice
function MarketMethods:updateDataIndex(msg)
  self.dataIndex = msg.Tags.DataIndex
  return self.updateDataIndexNotice(msg.Tags.DataIndex, msg)
end

--- Update take fee
--- @param msg Message The message received
--- @return Message updateTakeFeeNotice The update take fee notice
function MarketMethods:updateTakeFee(msg)
  return self.cpmm:updateTakeFee(tonumber(msg.Tags.CreatorFee), tonumber(msg.Tags.ProtocolFee), msg)
end

--- Update protocol fee target
--- @param msg Message The message received
--- @return Message
function MarketMethods:updateProtocolFeeTarget(msg)
  return self.cpmm:updateProtocolFeeTarget(msg.Tags.ProtocolFeeTarget, msg)
end

--- Update logo
--- @param msg Message The message received
--- @return Message updateLogoNotice The update logo notice
function MarketMethods:updateLogo(msg)
  return self.cpmm:updateLogo(msg.Tags.Logo, msg)
end

return Market

end

_G.package.loaded[&quot;marketModules.market&quot;] = _loaded_mod_marketModules_market()

-- module: &quot;marketModules.sharedUtils&quot;
local function _loaded_mod_marketModules_sharedUtils()
--[[
=========================================================
Part of the Outcome codebase © 2025. All Rights Reserved.
See market.lua for full license details.
=========================================================
]]

local sharedUtils = {}

--- Verify if extracted value is a JSON simple value
--- @param value any
--- @return boolean
local function isSimpleValue(value)
  -- Trim whitespace
  value = value:match(&quot;^%s*(.-)%s*$&quot;) or value
  -- Check for a quoted string: &quot;someValue&quot;
  if value:match(&#39;^&quot;[^&quot;]*&quot;$&#39;) then
    return true
  end
  -- Check for a number (integer or float, optional minus sign): 123, -123, 123.45
  if value:match(&#39;^[-]?%d+%.?%d*$&#39;) then
    return true
  end
  -- Check for boolean
  if string.lower(value) == &quot;true&quot; or string.lower(value) == &quot;false&quot; then
    return true
  end
  return false
end

--- Verify if a valid JSON object
--- @param str any
--- @return boolean
function sharedUtils.isValidKeyValueJSON(str)
  if type(str) ~= &quot;string&quot; then return false end
  -- Trim whitespace
  str = str:match(&quot;^%s*(.-)%s*$&quot;)
  -- Ensure it starts with `{` and ends with `}`
  local isObject = str:match(&quot;^%{%s*(.-)%s*%}$&quot;)
  if not isObject then return false end
  -- This pattern only extracts the key and the entire raw value
  local keyValuePattern = &#39;^%s*&quot;([^&quot;]+)&quot;%s*:%s*(.-)%s*$&#39;
  -- Check all key-value pairs
  for keyValue in isObject:gmatch(&quot;[^,]+&quot;) do
    local key, rawValue = keyValue:match(keyValuePattern)
    if not key or not rawValue then
      return false
    end
    -- Now validate that rawValue is a valid JSON simple value
    if not isSimpleValue(rawValue) then
      return false
    end
  end
  return true
end

--- Verify if a valid JSON array
--- @param str any
--- @return boolean
function sharedUtils.isJSONArray(str)
  if type(str) ~= &quot;string&quot; then return false end
  -- Trim whitespace
  str = str:match(&quot;^%s*(.-)%s*$&quot;)
  -- Ensure it starts with `[` and ends with `]`
  local isArray = str:match(&quot;^%[%s*(.-)%s*%]$&quot;)
  if not isArray then return false end
  -- Split the array elements and validate each one
  for value in isArray:gmatch(&quot;[^,]+&quot;) do
    value = value:match(&quot;^%s*(.-)%s*$&quot;) -- Trim whitespace around each value
    if not isSimpleValue(value) then
      return false
    end
  end
  return true
end

--- Verify if a valid Arweave address
--- @param address any
--- @return boolean
function sharedUtils.isValidArweaveAddress(address)
	return type(address) == &quot;string&quot; and #address == 43 and string.match(address, &quot;^[%w-_]+$&quot;) ~= nil
end

--- Verify if a valid boolean string
--- @param value any
--- @return boolean
function sharedUtils.isValidBooleanString(value)
  return type(value) == &quot;string&quot; and (string.lower(value) == &quot;true&quot; or string.lower(value) == &quot;false&quot;)
end

return sharedUtils
end

_G.package.loaded[&quot;marketModules.sharedUtils&quot;] = _loaded_mod_marketModules_sharedUtils()

-- module: &quot;marketModules.sharedValidation&quot;
local function _loaded_mod_marketModules_sharedValidation()
--[[
=========================================================
Part of the Outcome codebase © 2025. All Rights Reserved.
See market.lua for full license details.
=========================================================
]]

local sharedValidation = {}
local sharedUtils = require(&#39;marketModules.sharedUtils&#39;)
local utils = require(&#39;.utils&#39;)

--- Validates address
--- @param address any The address to be validated
--- @param tagName string The name of the tag being validated
--- @return boolean, string|nil Returns true on success, or false and an error message on failure
function sharedValidation.validateAddress(address, tagName)
  if type(address) ~= &#39;string&#39; then
    return false, tagName .. &#39; is required and must be a string!&#39;
  end
  if not sharedUtils.isValidArweaveAddress(address) then
    return false, tagName .. &#39; must be a valid Arweave address!&#39;
  end
  return true
end

--- Validates array item
--- @param item any The item to be validated
--- @param validItems table&lt;string&gt; The array of valid items
--- @param tagName string The name of the tag being validated
--- @return boolean, string|nil Returns true on success, or false and an error message on failure
function sharedValidation.validateItem(item, validItems, tagName)
  if type(item) ~= &#39;string&#39; then
    return false, tagName .. &#39; is required and must be a string!&#39;
  end
  if not utils.includes(item, validItems) then
    return false, &#39;Invalid &#39; .. tagName .. &#39;!&#39;
  end
  return true
end

--- Validates positive integer
--- @param quantity any The quantity to be validated
--- @param tagName string The name of the tag being validated
--- @return boolean, string|nil Returns true on success, or false and an error message on failure
function sharedValidation.validatePositiveInteger(quantity, tagName)
  if type(quantity) ~= &#39;string&#39; then
    return false, tagName .. &#39; is required and must be a string!&#39;
  end

  local num = tonumber(quantity)
  if not num then
    return false, tagName .. &#39; must be a valid number!&#39;
  end
  if num &lt;= 0 then
    return false, tagName .. &#39; must be greater than zero!&#39;
  end
  if num % 1 ~= 0 then
    return false, tagName .. &#39; must be an integer!&#39;
  end

  return true
end

--- Validates positive integer or zero
--- @param quantity any The quantity to be validated
--- @param tagName string The name of the tag being validated
--- @return boolean, string|nil Returns true on success, or false and an error message on failure
function sharedValidation.validatePositiveIntegerOrZero(quantity, tagName)
  if type(quantity) ~= &#39;string&#39; then
    return false, tagName .. &#39; is required and must be a string!&#39;
  end

  local num = tonumber(quantity)
  if not num then
    return false, tagName .. &#39; must be a valid number!&#39;
  end
  if num &lt; 0 then
    return false, tagName .. &#39; must be greater than or equal to zero!&#39;
  end
  if num % 1 ~= 0 then
    return false, tagName .. &#39; must be an integer!&#39;
  end

  return true
end

return sharedValidation

end

_G.package.loaded[&quot;marketModules.sharedValidation&quot;] = _loaded_mod_marketModules_sharedValidation()

-- module: &quot;marketModules.cpmmValidation&quot;
local function _loaded_mod_marketModules_cpmmValidation()
--[[
=========================================================
Part of the Outcome codebase © 2025. All Rights Reserved.
See cpmm.lua for full license details.
=========================================================
]]

local cpmmValidation = {}
local sharedValidation = require(&#39;marketModules.sharedValidation&#39;)
local bint = require(&#39;.bint&#39;)(256)
local json = require(&quot;json&quot;)

--- Validates add funding
--- @param msg Message The message to be validated
--- @param totalSupply string The LP token total supply
--- @param positionIds table&lt;string&gt; The outcome position IDs
--- @return boolean, string|nil
function cpmmValidation.addFunding(msg, totalSupply, positionIds)
  local isValid, err = sharedValidation.validatePositiveInteger(msg.Tags.Quantity, &quot;Quantity&quot;)
  if not isValid then
    return false, err
  end

  -- Extract distribution
  local distribution = msg.Tags[&quot;X-Distribution&quot;] and json.decode(msg.Tags[&quot;X-Distribution&quot;]) or nil

  -- Check if distribution is required or must be omitted
  local isFirstFunding = bint.iszero(bint(totalSupply))
  if distribution then
    -- Ensure distribution is set only for initial funding
    if not isFirstFunding then
      return false, &quot;Cannot specify distribution after initial funding&quot;
    end

    -- Ensure distribution includes all position IDs
    if #distribution ~= #positionIds then
      return false, &quot;Distribution length mismatch&quot;
    end

    -- Validate distribution content
    local distributionSum = 0
    for i = 1, #distribution do
      if type(distribution[i]) ~= &quot;number&quot; then
        return false, &quot;Distribution item must be a number&quot;
      end
      distributionSum = distributionSum + distribution[i]
    end

    -- Ensure the distribution sum is greater than zero
    if distributionSum == 0 then
      return false, &quot;Distribution sum must be greater than zero&quot;
    end
  else
    -- Ensure distribution is provided for the first funding call
    if isFirstFunding then
      return false, &quot;Must specify distribution for initial funding&quot;
    end
  end

  return true
end

--- Validates remove funding
--- @param msg Message The message to be validated
--- @param balance string The balance of the sender&#39;s LP tokens
--- @return boolean, string|nil True if validation passes, otherwise false with an error message
function cpmmValidation.removeFunding(msg, balance)
  -- Validate that Quantity is a positive integer
  local isValid, err = sharedValidation.validatePositiveInteger(msg.Tags.Quantity, &quot;Quantity&quot;)
  if not isValid then
    return false, err
  end

  -- Ensure Quantity is within the sender&#39;s balance
  local quantity = bint(msg.Tags.Quantity)
  local userBalance = bint(balance or &quot;0&quot;) -- Default to &quot;0&quot; if balance is nil

  if quantity &gt; userBalance then
    return false, &quot;Quantity must be less than or equal to balance!&quot;
  end

  return true
end

--- Validates buy
--- @param msg Message The message to be validated
--- @param cpmm CPMM The CPMM instance for calculations
--- @return boolean, string|nil True if validation passes, otherwise false with an error message
function cpmmValidation.buy(msg, cpmm)
  local onBehalfOf = msg.Tags[&#39;X-OnBehalfOf&#39;] or msg.Tags.Sender
  local positionIds = cpmm.tokens.positionIds

  local success, err = sharedValidation.validateAddress(onBehalfOf, &#39;onBehalfOf&#39;)
  if not success then return false, err end

  success, err = sharedValidation.validateItem(msg.Tags[&#39;X-PositionId&#39;], positionIds, &quot;X-PositionId&quot;)
  if not success then return false, err end

  success, err = sharedValidation.validatePositiveInteger(msg.Tags.Quantity, &quot;Quantity&quot;)
  if not success then return false, err end

  success, err = sharedValidation.validatePositiveInteger(msg.Tags[&quot;X-MinPositionTokensToBuy&quot;], &quot;X-MinPositionTokensToBuy&quot;)
  if not success then return false, err end

  -- Calculate the actual buy amount
  local positionTokensToBuy = cpmm:calcBuyAmount(msg.Tags.Quantity, msg.Tags[&#39;X-PositionId&#39;])

  -- Ensure minimum buy amount is met
  if bint(msg.Tags[&#39;X-MinPositionTokensToBuy&#39;]) &gt; bint(positionTokensToBuy) then
    return false, &#39;Minimum buy amount not reached&#39;
  end

  return true
end

--- Validates sell
--- @param msg Message The message to be validated
--- @param cpmm CPMM The CPMM instance for calculations
--- @return boolean, string|nil
function cpmmValidation.sell(msg, cpmm)
  local positionIds = cpmm.tokens.positionIds

  local success, err = sharedValidation.validateItem(msg.Tags.PositionId, positionIds, &quot;PositionId&quot;)
  if not success then return false, err end

  success, err = sharedValidation.validatePositiveInteger(msg.Tags.MaxPositionTokensToSell, &quot;MaxPositionTokensToSell&quot;)
  if not success then return false, err end

  success, err = sharedValidation.validatePositiveInteger(msg.Tags.ReturnAmount, &quot;ReturnAmount&quot;)
  if not success then return false, err end

  -- Calculate the actual position tokens to sell
  local positionTokensToSell = cpmm:calcSellAmount(msg.Tags.ReturnAmount, msg.Tags.PositionId)

 -- Ensure the sell amount does not exceed the maximum allowed
 if bint(positionTokensToSell) &gt; bint(msg.Tags.MaxPositionTokensToSell) then
  return false, &quot;Max position tokens to sell not sufficient!&quot;
end

  return true
end

--- Validates calc buy amount
--- @param msg Message The message to be validated
--- @param validPositionIds table&lt;string&gt; The array of valid position IDs
--- @return boolean, string|nil
function cpmmValidation.calcBuyAmount(msg, validPositionIds)
  local success, err = sharedValidation.validateItem(msg.Tags.PositionId, validPositionIds, &quot;PositionId&quot;)
  if not success then return false, err end

  return sharedValidation.validatePositiveInteger(msg.Tags.InvestmentAmount, &quot;InvestmentAmount&quot;)
end

--- Validates calc sell amount
--- @param msg Message The message to be validated
--- @param validPositionIds table&lt;string&gt; The array of valid position IDs
--- @return boolean, string|nil
function cpmmValidation.calcSellAmount(msg, validPositionIds)
  local success, err = sharedValidation.validateItem(msg.Tags.PositionId, validPositionIds, &quot;PositionId&quot;)
  if not success then return false, err end

  return sharedValidation.validatePositiveInteger(msg.Tags.ReturnAmount, &quot;ReturnAmount&quot;)
end

--- Validates fees withdrawable
--- @param msg Message The message to be validated
--- @return boolean, string|nil
function cpmmValidation.feesWithdrawable(msg)
  if msg.Tags[&#39;Recipient&#39;] then
    return sharedValidation.validateAddress(msg.Tags[&#39;Recipient&#39;], &#39;Recipient&#39;)
  end

  return true
end

--- Validates update configurator
--- @param msg Message The message to be validated
--- @param configurator string The configurator address
--- @return boolean, string|nil
function cpmmValidation.updateConfigurator(msg, configurator)
  if msg.From ~= configurator then
    return false, &#39;Sender must be configurator!&#39;
  end

  return sharedValidation.validateAddress(msg.Tags.Configurator, &#39;Configurator&#39;)
end

--- Validates update take fee
--- @param msg Message The message to be validated
--- @param configurator string The configurator address
--- @return boolean, string|nil
function cpmmValidation.updateTakeFee(msg, configurator)
  if msg.From ~= configurator then
    return false, &#39;Sender must be configurator!&#39;
  end

  local success, err = sharedValidation.validatePositiveIntegerOrZero(msg.Tags.CreatorFee, &#39;CreatorFee&#39;)
  if not success then return false, err end

  success, err = sharedValidation.validatePositiveIntegerOrZero(msg.Tags.ProtocolFee, &#39;ProtocolFee&#39;)
  if not success then return false, err end

  local totalFee = bint.__add(bint(msg.Tags.CreatorFee), bint(msg.Tags.ProtocolFee))
  if not bint.__lt(totalFee, 1000) then
    return false, &#39;Net fee must be less than or equal to 1000 bps&#39;
  end

  return true
end

--- Validates update protocol fee target
--- @param msg Message The message to be validated
--- @param configurator string The configurator address
--- @return boolean, string|nil
function cpmmValidation.updateProtocolFeeTarget(msg, configurator)
  if msg.From ~= configurator then
    return false, &#39;Sender must be configurator!&#39;
  end

  if not msg.Tags.ProtocolFeeTarget then
    return false, &#39;ProtocolFeeTarget is required!&#39;
  end

  return true
end

--- Validates update logo
--- @param msg Message The message to be validated
--- @param configurator string The configurator address
--- @return boolean, string|nil
function cpmmValidation.updateLogo(msg, configurator)
  if msg.From ~= configurator then
    return false, &#39;Sender must be configurator!&#39;
  end

  if not msg.Tags.Logo then
    return false, &#39;Logo is required!&#39;
  end

  return true
end

return cpmmValidation
end

_G.package.loaded[&quot;marketModules.cpmmValidation&quot;] = _loaded_mod_marketModules_cpmmValidation()

-- module: &quot;marketModules.tokenValidation&quot;
local function _loaded_mod_marketModules_tokenValidation()
--[[
=========================================================
Part of the Outcome codebase © 2025. All Rights Reserved.
See tokens.lua for full license details.
=========================================================
]]

local tokenValidation = {}
local sharedValidation = require(&#39;marketModules.sharedValidation&#39;)

--- Validates a transfer message
--- @param msg Message The message received
--- @return boolean, string|nil Returns true on success, or false and an error message on failure
function tokenValidation.transfer(msg)
  local success, err = sharedValidation.validateAddress(msg.Tags.Recipient, &#39;Recipient&#39;)
  if not success then return false, err end

  success, err = sharedValidation.validatePositiveInteger(msg.Tags.Quantity, &quot;Quantity&quot;)
  if not success then return false, err end

  return true
end

--- Validates balance
--- @param msg Message The message to be validated
--- @return boolean, string|nil
function tokenValidation.balance(msg)
  if msg.Tags[&#39;Recipient&#39;] then
    return sharedValidation.validateAddress(msg.Tags[&#39;Recipient&#39;], &#39;Recipient&#39;)
  elseif msg.Tags[&#39;Target&#39;] then
    return sharedValidation.validateAddress(msg.Tags[&#39;Target&#39;], &#39;Target&#39;)
  end

  return true
end

return tokenValidation
end

_G.package.loaded[&quot;marketModules.tokenValidation&quot;] = _loaded_mod_marketModules_tokenValidation()

-- module: &quot;marketModules.marketValidation&quot;
local function _loaded_mod_marketModules_marketValidation()
local MarketValidation = {}
local sharedValidation = require(&#39;marketModules.sharedValidation&#39;)

--- Validates update data index
--- @param msg Message The message to be validated
--- @param configurator string The configurator address
--- @return boolean, string|nil Returns true on success, or false and an error message on failure
function MarketValidation.updateDataIndex(msg, configurator)
  if msg.From ~= configurator then
    return false, &#39;Sender must be configurator!&#39;
  end

  local success, err = sharedValidation.validateAddress(msg.Tags.DataIndex, &#39;DataIndex&#39;)
  if not success then return false, err end

  return true
end

return MarketValidation
end

_G.package.loaded[&quot;marketModules.marketValidation&quot;] = _loaded_mod_marketModules_marketValidation()

-- module: &quot;marketModules.semiFungibleTokensValidation&quot;
local function _loaded_mod_marketModules_semiFungibleTokensValidation()
--[[
=========================================================
Part of the Outcome codebase © 2025. All Rights Reserved.
See semiFungibleTokens.lua for full license details.
=========================================================
]]

local semiFungibleTokensValidation = {}
local sharedValidation = require(&#39;marketModules.sharedValidation&#39;)
local json = require(&quot;json&quot;)

--- Validates a transferSingle message
--- @param msg Message The message received
--- @param validPositionIds table&lt;string&gt; The array of valid token IDs
--- @return boolean, string|nil Returns true on success, or false and an error message on failure
function semiFungibleTokensValidation.transferSingle(msg, validPositionIds)
  local success, err = sharedValidation.validateAddress(msg.Tags.Recipient, &#39;Recipient&#39;)
  if not success then return false, err end

  success, err = sharedValidation.validateItem(msg.Tags.PositionId, validPositionIds, &quot;PositionId&quot;)
  if not success then return false, err end

  success, err = sharedValidation.validatePositiveInteger(msg.Tags.Quantity, &quot;Quantity&quot;)
  if not success then return false, err end

  return true
end

--- Validates a transferBatch message
--- @param msg Message The message received
--- @param validPositionIds table&lt;string&gt; The array of valid token IDs
--- @return boolean, string|nil Returns true on success, or false and an error message on failure
function semiFungibleTokensValidation.transferBatch(msg, validPositionIds)
  local success, err = sharedValidation.validateAddress(msg.Tags.Recipient, &#39;Recipient&#39;)
  if not success then return false, err end

  if type(msg.Tags.PositionIds) ~= &#39;string&#39; then
    return false, &#39;PositionIds is required!&#39;
  end
  local positionIds = json.decode(msg.Tags.PositionIds)

  if type(msg.Tags.Quantities) ~= &#39;string&#39; then
    return false, &#39;Quantities is required!&#39;
  end
  local quantities = json.decode(msg.Tags.Quantities)

  if #positionIds ~= #quantities then
    return false, &#39;Input array lengths must match!&#39;
  end
  if #positionIds == 0 then
    return false, &quot;Input array length must be greater than zero!&quot;
  end

  for i = 1, #positionIds do
    success, err = sharedValidation.validateItem(positionIds[i], validPositionIds, &quot;PositionId&quot;)
    if not success then return false, err end

    success, err = sharedValidation.validatePositiveInteger(quantities[i], &quot;Quantity&quot;)
    if not success then return false, err end
  end

  return true
end

--- Validates a balanceById message
--- @param msg Message The message received
--- @param validPositionIds table&lt;string&gt; The array of valid token IDs
--- @return boolean, string|nil Returns true on success, or false and an error message on failure
function semiFungibleTokensValidation.balanceById(msg, validPositionIds)
  if msg.Tags.Recipient then
    local success, err = sharedValidation.validateAddress(msg.Tags.Recipient, &#39;Recipient&#39;)
    if not success then return false, err end
  end
  return sharedValidation.validateItem(msg.Tags.PositionId, validPositionIds, &quot;PositionId&quot;)
end

--- Validates a balancesById message
--- @param msg Message The message received
--- @param validPositionIds table&lt;string&gt; The array of valid token IDs
--- @return boolean, string|nil Returns true on success, or false and an error message on failure
function semiFungibleTokensValidation.balancesById(msg, validPositionIds)
  if msg.Tags.Recipient then
    local success, err = sharedValidation.validateAddress(msg.Tags.Recipient, &#39;Recipient&#39;)
    if not success then return false, err end
  end
  return sharedValidation.validateItem(msg.Tags.PositionId, validPositionIds, &quot;PositionId&quot;)
end

--- Validates a batchBalance message
--- @param msg Message The message received
--- @param validPositionIds table&lt;string&gt; The array of valid token IDs
--- @return boolean, string|nil Returns true on success, or false and an error message on failure
function semiFungibleTokensValidation.batchBalance(msg, validPositionIds)
  if not msg.Tags.Recipients then
    return false, &quot;Recipients is required!&quot;
  end
  local recipients = json.decode(msg.Tags.Recipients)

  if not msg.Tags.PositionIds then
    return false, &quot;PositionIds is required!&quot;
  end
  local positionIds = json.decode(msg.Tags.PositionIds)

  if #recipients ~= #positionIds then
    return false, &quot;Input array lengths must match!&quot;
  end
  if #recipients == 0 then
    return false, &quot;Input array length must be greater than zero!&quot;
  end

  for i = 1, #positionIds do
    local success, err = sharedValidation.validateAddress(recipients[i], &#39;Recipient&#39;)
    if not success then return false, err end

    success, err = sharedValidation.validateItem(positionIds[i], validPositionIds, &quot;PositionId&quot;)
    if not success then return false, err end
  end

  return true
end

--- Validates a batchBalances message
--- @param msg Message The message received
--- @param validPositionIds table&lt;string&gt; The array of valid token IDs
--- @return boolean, string|nil Returns true on success, or false and an error message on failure
function semiFungibleTokensValidation.batchBalances(msg, validPositionIds)
  if not msg.Tags.PositionIds then
    return false, &quot;PositionIds is required!&quot;
  end
  local positionIds = json.decode(msg.Tags.PositionIds)

  if #positionIds == 0 then
    return false, &quot;Input array length must be greater than zero!&quot;
  end

  for i = 1, #positionIds do
    local success, err = sharedValidation.validateItem(positionIds[i], validPositionIds, &quot;PositionId&quot;)
    if not success then return false, err end
  end

  return true
end

return semiFungibleTokensValidation
end

_G.package.loaded[&quot;marketModules.semiFungibleTokensValidation&quot;] = _loaded_mod_marketModules_semiFungibleTokensValidation()

-- module: &quot;marketModules.conditionalTokensValidation&quot;
local function _loaded_mod_marketModules_conditionalTokensValidation()
--[[
=========================================================
Part of the Outcome codebase © 2025. All Rights Reserved.
See conditionalTokens.lua for full license details.
=========================================================
]]

local ConditionalTokensValidation = {}
local sharedValidation = require(&#39;marketModules.sharedValidation&#39;)
local sharedUtils = require(&#39;marketModules.sharedUtils&#39;)
local bint = require(&#39;.bint&#39;)(256)
local json = require(&#39;json&#39;)

--- Validates quantity
--- @param quantity any The quantity to be validated
--- @return boolean, string|nil Returns true on success, or false and an error message on failure
local function validateQuantity(quantity)
  if type(quantity) ~= &#39;string&#39; then
    return false, &#39;Quantity is required and must be a string!&#39;
  end

  local num = tonumber(quantity)
  if not num then
    return false, &#39;Quantity must be a valid number!&#39;
  end
  if num &lt;= 0 then
    return false, &#39;Quantity must be greater than zero!&#39;
  end
  if num % 1 ~= 0 then
    return false, &#39;Quantity must be an integer!&#39;
  end

  return true
end

--- Validates payouts
--- @param payouts any The payouts to be validated
--- @return boolean, string|nil Returns true on success, or false and an error message on failure
local function validatePayouts(payouts)
  if not payouts then
    return false, &quot;Payouts is required!&quot;
  end
  if not sharedUtils.isJSONArray(payouts) then
    return false, &quot;Payouts must be a valid JSON Array!&quot;
  end

  local decodedPayouts = json.decode(payouts)
  for _, payout in ipairs(decodedPayouts) do
    if not tonumber(payout) then
      return false, &quot;Payouts item must be a valid number!&quot;
    end
  end

  return true
end

--- Validates the mergePositions message.
--- @param msg Message The message to be validated
--- @param cpmm CPMM The CPMM instance for checking token balances
--- @return boolean, string|nil Returns true on success, or false and an error message on failure
function ConditionalTokensValidation.mergePositions(msg, cpmm)
  local onBehalfOf = msg.Tags[&#39;OnBehalfOf&#39;] or msg.From
  local success, err

  if not onBehalfOf then
    success, err = sharedValidation.validateAddress(onBehalfOf, &#39;onBehalfOf&#39;)
    if not success then return false, err end
  end

  success, err = validateQuantity(msg.Tags.Quantity)
  if not success then return false, err end

  -- Check user balances for each position
  for i = 1, #cpmm.tokens.positionIds do
    local positionId = cpmm.tokens.positionIds[i]

    if not cpmm.tokens.balancesById[positionId] then
      return false, &quot;Invalid position! PositionId: &quot; .. positionId
    end

    if not cpmm.tokens.balancesById[positionId][onBehalfOf] then
      return false, &quot;Invalid user position! PositionId: &quot; .. positionId
    end

    if bint(cpmm.tokens.balancesById[positionId][onBehalfOf]) &lt; bint(msg.Tags.Quantity) then
      return false, &quot;Insufficient tokens! PositionId: &quot; .. positionId
    end
  end

  return true
end


--- Validates the reportPayouts message
--- @param msg Message The message to be validated
--- @param resolutionAgent string The resolution agent process ID
--- @return boolean, string|nil Returns true on success, or false and an error message on failure
function ConditionalTokensValidation.reportPayouts(msg, resolutionAgent)
  if msg.From ~= resolutionAgent then
    return false, &quot;Sender must be the resolution agent!&quot;
  end

  return validatePayouts(msg.Tags.Payouts)
end

return ConditionalTokensValidation

end

_G.package.loaded[&quot;marketModules.conditionalTokensValidation&quot;] = _loaded_mod_marketModules_conditionalTokensValidation()

--[[
======================================================================================
Outcome © 2025. All Rights Reserved.
======================================================================================
This code is proprietary and owned by Outcome.

You are permitted to build applications, integrations, and extensions that interact
with the Outcome Protocol, provided such usage adheres to the official Outcome
terms of service and does not result in unauthorized forks or clones of this codebase.

Redistribution, modification, or unauthorized use of this code is strictly prohibited
without explicit written permission from Outcome.
======================================================================================
]]

local market = require(&#39;marketModules.market&#39;)
local constants = require(&#39;marketModules.constants&#39;)
local json = require(&#39;json&#39;)
local cpmmValidation = require(&#39;marketModules.cpmmValidation&#39;)
local tokenValidation = require(&#39;marketModules.tokenValidation&#39;)
local marketValidation = require(&#39;marketModules.marketValidation&#39;)
local semiFungibleTokensValidation = require(&#39;marketModules.semiFungibleTokensValidation&#39;)
local conditionalTokensValidation = require(&#39;marketModules.conditionalTokensValidation&#39;)

--[[
======
MARKET
======
]]

Env = ao.env.Process.Tags.Env or &quot;DEV&quot;

-- Revoke ownership if the Market is not in development mode
if Env ~= &#39;DEV&#39; then
  ---@diagnostic disable-next-line: assign-type-mismatch
  Owner = &quot;null&quot;
end

--- Represents the Market Configuration
--- @class MarketConfiguration
--- @field configurator string The Configurator process ID
--- @field dataIndex string The Data Index process ID
--- @field collateralToken string The Collateral Token process ID
--- @field resolutionAgent string The Resolution Agent process ID
--- @field creator string The Creator address
--- @field question string The Market question
--- @field rules string The Market rules
--- @field category string The Market category
--- @field subcategory string The Market subcategory
--- @field positionIds table&lt;string&gt; The Position process IDs
--- @field name string The Market name
--- @field ticker string The Market ticker
--- @field logo string The Market logo
--- @field lpFee number The LP fee
--- @field creatorFee number The Creator fee
--- @field creatorFeeTarget string The Creator fee target
--- @field protocolFee number The Protocol fee
--- @field protocolFeeTarget string The Protocol fee target

--- Retrieve Market Configuration
--- Fetches configuration parameters from the environment, set by the market factory
--- @return MarketConfiguration marketConfiguration The market configuration
local function retrieveMarketConfig()
  local config = {
    configurator = ao.env.Process.Tags.Configurator or constants.marketConfig.configurator,
    dataIndex = ao.env.Process.Tags.DataIndex or constants.marketConfig.dataIndex,
    collateralToken = ao.env.Process.Tags.CollateralToken or constants.marketConfig.collateralToken,
    resolutionAgent = ao.env.Process.Tags.ResolutionAgent or constants.marketConfig.resolutionAgent,
    creator = ao.env.Process.Tags.Creator or constants.marketConfig.creator,
    question = ao.env.Process.Tags.Question or constants.marketConfig.question,
    rules = ao.env.Process.Tags.Rules or constants.marketConfig.rules,
    category = ao.env.Process.Tags.Category or constants.marketConfig.category,
    subcategory = ao.env.Process.Tags.Subcategory or constants.marketConfig.subcategory,
    positionIds = json.decode(ao.env.Process.Tags.PositionIds or constants.marketConfig.positionIds),
    name = ao.env.Process.Tags.Name or constants.marketConfig.name,
    ticker = ao.env.Process.Tags.Ticker or constants.marketConfig.ticker,
    logo = ao.env.Process.Tags.Logo or constants.marketConfig.logo,
    lpFee = tonumber(ao.env.Process.Tags.LpFee or constants.marketConfig.lpFee),
    creatorFee = tonumber(ao.env.Process.Tags.CreatorFee or constants.marketConfig.creatorFee),
    creatorFeeTarget = ao.env.Process.Tags.CreatorFeeTarget or constants.marketConfig.creatorFeeTarget,
    protocolFee = tonumber(ao.env.Process.Tags.ProtocolFee or constants.marketConfig.protocolFee),
    protocolFeeTarget = ao.env.Process.Tags.ProtocolFeeTarget or constants.marketConfig.protocolFeeTarget
  }
  -- update name and ticker with a unique postfix
  local postfix = string.sub(ao.id, 1, 4) .. string.sub(ao.id, -4)
  -- shorten name to first word and append postfix
  config.name = string.match(config.name, &quot;^(%S+)&quot;) .. &quot;-&quot; .. postfix
  config.ticker = config.ticker .. &quot;-&quot; .. postfix
  return config
end

--- @dev Reset Market state during development mode or if uninitialized
if not Market or Env == &#39;DEV&#39; then
  local marketConfig = retrieveMarketConfig()
  Market = market.new(
    marketConfig.configurator,
    marketConfig.dataIndex,
    marketConfig.collateralToken,
    marketConfig.resolutionAgent,
    marketConfig.creator,
    marketConfig.question,
    marketConfig.rules,
    marketConfig.category,
    marketConfig.subcategory,
    marketConfig.positionIds,
    marketConfig.name,
    marketConfig.ticker,
    marketConfig.logo,
    marketConfig.lpFee,
    marketConfig.creatorFee,
    marketConfig.creatorFeeTarget,
    marketConfig.protocolFee,
    marketConfig.protocolFeeTarget
  )
end

-- Set LP Token namespace variables
Denomination = constants.denomination

--[[
========
MATCHING
========
]]

--- Match on add funding to CPMM
--- @param msg Message The message to match
--- @return boolean True if the message is to add funding, false otherwise
local function isAddFunding(msg)
  if (
    msg.From == Market.cpmm.tokens.collateralToken and
    msg.Action == &quot;Credit-Notice&quot; and
    msg[&quot;X-Action&quot;] == &quot;Add-Funding&quot;
  ) then
    return true
  else
    return false
  end
end

--- Match on buy from CPMM
--- @param msg Message The message to match
--- @return boolean True if the message is to buy, false otherwise
local function isBuy(msg)
  if (
    msg.From == Market.cpmm.tokens.collateralToken and
    msg.Action == &quot;Credit-Notice&quot; and
    msg[&quot;X-Action&quot;] == &quot;Buy&quot;
  ) then
    return true
  else
    return false
  end
end

--[[
============
INFO HANDLER
============
]]

--- Info handler
--- @param msg Message The message received
Handlers.add(&quot;Info&quot;, {Action = &quot;Info&quot;}, function(msg)
  Market:info(msg)
end)

--[[
===================
CPMM WRITE HANDLERS
===================
]]

--- Add funding handler
--- @param msg Message The message received, expected to contain:
---   - msg.Tags.Quantity (string): The amount of funding to add (numeric string).
---   - msg.Tags.Distribution (stringified table):
---     * JSON-encoded table specifying the initial distribution of funding.
---     * Required on the first call to `addFunding`.
---     * Must NOT be included in subsequent calls, or the operation will fail.
---   - msg.Tags.OnBehalfOf (string, optional): The address of the account to receive the LP tokens.
Handlers.add(&quot;Add-Funding&quot;, isAddFunding, function(msg)
  -- Validate input
  local success, err = cpmmValidation.addFunding(msg, Market.cpmm.token.totalSupply, Market.cpmm.tokens.positionIds)
  -- If validation fails, return funds to sender and provide error response.
  if not success then
    msg.reply({
      Action = &quot;Transfer&quot;,
      Recipient = msg.Tags.Sender,
      Quantity = msg.Tags.Quantity,
      [&quot;X-Action&quot;] = &quot;Add-Funding-Error&quot;,
      [&quot;X-Error&quot;] = err
    })
    return
  end
  -- If validation passes, add funding to the CPMM.
  Market:addFunding(msg)
end)

--- Remove funding handler
--- @param msg Message The message received
Handlers.add(&quot;Remove-Funding&quot;, {Action = &quot;Remove-Funding&quot;}, function(msg)
  -- Validate input
  local success, err = cpmmValidation.removeFunding(msg, Market.cpmm.token.balances[msg.From])
  -- If validation fails, provide error response.
  if not success then
    msg.reply({
      Action = &quot;Remove-Funding-Error&quot;,
      Error = err
    })
    return
  end
  -- If validation passes, remove funding from the CPMM.
  Market:removeFunding(msg)
end)

--- Buy handler
--- @param msg Message The message received
Handlers.add(&quot;Buy&quot;, isBuy, function(msg)
  -- Validate input
  local success, err = cpmmValidation.buy(msg, Market.cpmm)
  -- If validation fails, return funds to sender and provide error response.
  if not success then
    msg.reply({
      Action = &quot;Transfer&quot;,
      Recipient = msg.Tags.Sender,
      Quantity = msg.Tags.Quantity,
      [&quot;X-Action&quot;] = &quot;Buy-Error&quot;,
      [&quot;X-Error&quot;] = err
    })
    return
  end
  -- If validation passes, buy from the CPMM.
  Market:buy(msg)
end)

--- Sell handler
--- @param msg Message The message received
Handlers.add(&quot;Sell&quot;, {Action = &quot;Sell&quot;}, function(msg)
  -- Validate input
  local success, err = cpmmValidation.sell(msg, Market.cpmm)
  -- If validation fails, provide error response.
  if not success then
    msg.reply({
      Action = &quot;Sell-Error&quot;,
      Error = err
    })
    return
  end
  -- If validation passes, sell to the CPMM.
  Market:sell(msg)
end)

--- Withdraw fees handler
--- @param msg Message The message received
Handlers.add(&quot;Withdraw-Fees&quot;, {Action = &quot;Withdraw-Fees&quot;}, function(msg)
  Market:withdrawFees(msg)
end)

--[[
==================
CPMM READ HANDLERS
==================
]]

--- Calc buy amount handler
--- @param msg Message The message received
Handlers.add(&quot;Calc-Buy-Amount&quot;, {Action = &quot;Calc-Buy-Amount&quot;}, function(msg)
  -- Validate input
  local success, err = cpmmValidation.calcBuyAmount(msg, Market.cpmm.tokens.positionIds)
  -- If validation fails, provide error response.
  if not success then
    msg.reply({
      Action = &quot;Calc-Buy-Amount-Error&quot;,
      Error = err
    })
    return
  end
  -- If validation passes, calculate the buy amount.
  Market:calcBuyAmount(msg)
end)

--- Calc sell amount handler
--- @param msg Message The message received
Handlers.add(&quot;Calc-Sell-Amount&quot;, {Action = &quot;Calc-Sell-Amount&quot;}, function(msg)
  -- Validate input
  local success, err = cpmmValidation.calcSellAmount(msg, Market.cpmm.tokens.positionIds)
  -- If validation fails, provide error response.
  if not success then
    msg.reply({
      Action = &quot;Calc-Sell-Amount-Error&quot;,
      Error = err
    })
    return
  end
  -- If validation passes, calculate the sell amount.
  Market:calcSellAmount(msg)
end)

--- Colleced fees handler
--- @param msg Message The message received
Handlers.add(&quot;Collected-Fees&quot;, {Action = &quot;Collected-Fees&quot;}, function(msg)
  Market:collectedFees(msg)
end)

--- Fees withdrawable handler
--- @param msg Message The message received
Handlers.add(&quot;Fees-Withdrawable&quot;, {Action = &quot;Fees-Withdrawable&quot;}, function(msg)
  -- Validate input
  local success, err = cpmmValidation.feesWithdrawable(msg)
  -- If validation fails, provide error response.
  if not success then
    msg.reply({
      Action = &quot;Fees-Withdrawable-Error&quot;,
      Error = err
    })
    return
  end
  -- If validation passes, get fees withdrawable.
  Market:feesWithdrawable(msg)
end)

--[[
=======================
LP TOKEN WRITE HANDLERS
=======================
]]

--- Transfer handler
--- @param msg Message The message received
Handlers.add(&#39;Transfer&#39;, {Action = &quot;Transfer&quot;}, function(msg)
  -- Validate input
  local success, err = tokenValidation.transfer(msg)
  -- If validation fails, provide error response.
  if not success then
    msg.reply({
      Action = &quot;Transfer-Error&quot;,
      Error = err
    })
    return
  end
  -- If validation passes, transfer the LP tokens.
  Market:transfer(msg)
end)

--[[
======================
LP TOKEN READ HANDLERS
======================
]]

--- Balance handler
--- @param msg Message The message received
Handlers.add(&#39;Balance&#39;, {Action = &quot;Balance&quot;}, function(msg)
  -- Validate input
  local success, err = tokenValidation.balance(msg)
  -- If validation fails, provide error response.
  if not success then
    msg.reply({
      Action = &quot;Balance-Error&quot;,
      Error = err
    })
    return
  end
  -- If validation passes, get the LP token balance.
  Market:balance(msg)
end)

--- Balances handler
--- @param msg Message The message received
Handlers.add(&#39;Balances&#39;, {Action = &quot;Balances&quot;}, function(msg)
  Market:balances(msg)
end)

--- Total supply handler
--- @param msg Message The message received
Handlers.add(&#39;Total-Supply&#39;, {Action = &quot;Total-Supply&quot;}, function(msg)
  Market:totalSupply(msg)
end)

--[[
=================================
CONDITIONAL TOKENS WRITE HANDLERS
=================================
]]

--- Merge positions handler
--- @param msg Message The message received
Handlers.add(&quot;Merge-Positions&quot;, {Action = &quot;Merge-Positions&quot;}, function(msg)
  -- Validate input
  local success, err = conditionalTokensValidation.mergePositions(msg, Market.cpmm)
  -- If validation fails, provide error response.
  if not success then
    msg.reply({
      Action = &quot;Merge-Positions-Error&quot;,
      Error = err
    })
    return
  end
  -- If validation passes, merge the positions.
  Market:mergePositions(msg)
end)

--- Report payouts handler
--- @param msg Message The message received
Handlers.add(&quot;Report-Payouts&quot;, {Action = &quot;Report-Payouts&quot;}, function(msg)
  -- Validate input
  local success, err = conditionalTokensValidation.reportPayouts(msg, Market.cpmm.tokens.resolutionAgent)
  -- If validation fails, provide error response.
  if not success then
    msg.reply({
      Action = &quot;Report-Payouts-Error&quot;,
      Error = err
    })
    return
  end
  -- If validation passes, report the payouts.
  Market:reportPayouts(msg)
end)

--- Redeem positions handler
--- @param msg Message The message received
Handlers.add(&quot;Redeem-Positions&quot;, {Action = &quot;Redeem-Positions&quot;}, function(msg)
  Market:redeemPositions(msg)
end)

--[[
================================
CONDITIONAL TOKENS READ HANDLERS
================================
]]

--- Get payout numerators handler
--- @param msg Message The message received
Handlers.add(&quot;Get-Payout-Numerators&quot;, {Action = &quot;Get-Payout-Numerators&quot;}, function(msg)
  Market:getPayoutNumerators(msg)
end)

--- Get payout denominator handler
--- @param msg Message The message received
Handlers.add(&quot;Get-Payout-Denominator&quot;, {Action = &quot;Get-Payout-Denominator&quot;}, function(msg)
  Market:getPayoutDenominator(msg)
end)

--[[
===================================
SEMI-FUNGIBLE TOKENS WRITE HANDLERS
===================================
]]

--- Transfer single handler
--- @param msg Message The message received
Handlers.add(&quot;Transfer-Single&quot;, {Action = &quot;Transfer-Single&quot;}, function(msg)
  -- Validate input
  local success, err = semiFungibleTokensValidation.transferSingle(msg, Market.cpmm.tokens.positionIds)
  -- If validation fails, provide error response.
  if not success then
    msg.reply({
      Action = &quot;Transfer-Single-Error&quot;,
      Error = err
    })
    return
  end
  -- If validation passes, execute transfer single.
  Market:transferSingle(msg)
end)

--- Transfer batch handler
--- @param msg Message The message received
Handlers.add(&#39;Transfer-Batch&#39;, {Action = &quot;Transfer-Batch&quot;}, function(msg)
  -- Validate input
  local success, err = semiFungibleTokensValidation.transferBatch(msg, Market.cpmm.tokens.positionIds)
  -- If validation fails, provide error response.
  if not success then
    msg.reply({
      Action = &quot;Transfer-Batch-Error&quot;,
      Error = err
    })
    return
  end
  -- If validation passes, execute transfer batch.
  Market:transferBatch(msg)
end)

--[[
==================================
SEMI-FUNGIBLE TOKENS READ HANDLERS
==================================
]]

--- Balance by ID handler
--- @param msg Message The message received
Handlers.add(&quot;Balance-By-Id&quot;, {Action = &quot;Balance-By-Id&quot;}, function(msg)
  -- Validate input
  local success, err = semiFungibleTokensValidation.balanceById(msg, Market.cpmm.tokens.positionIds)
  -- If validation fails, provide error response.
  if not success then
    msg.reply({
      Action = &quot;Balance-By-Id-Error&quot;,
      Error = err
    })
    return
  end
  -- If validation passes, get the balance by ID.
  Market:balanceById(msg)
end)

--- Balances by ID handler
--- @param msg Message The message received
Handlers.add(&#39;Balances-By-Id&#39;, {Action = &quot;Balances-By-Id&quot;}, function(msg)
  -- Validate input
  local success, err = semiFungibleTokensValidation.balancesById(msg, Market.cpmm.tokens.positionIds)
  -- If validation fails, provide error response.
  if not success then
    msg.reply({
      Action = &quot;Balances-By-Id-Error&quot;,
      Error = err
    })
    return
  end
  -- If validation passes, get the balances by ID.
  Market:balancesById(msg)
end)

--- Batch balance handler
--- @param msg Message The message received
Handlers.add(&quot;Batch-Balance&quot;, {Action = &quot;Batch-Balance&quot;}, function(msg)
  -- Validate input
  local success, err = semiFungibleTokensValidation.batchBalance(msg, Market.cpmm.tokens.positionIds)
  -- If validation fails, provide error response.
  if not success then
    msg.reply({
      Action = &quot;Batch-Balance-Error&quot;,
      Error = err
    })
    return
  end
  -- If validation passes, get the batch balance.
  Market:batchBalance(msg)
end)

--- Batch balances hanlder
--- @param msg Message The message received
Handlers.add(&#39;Batch-Balances&#39;, {Action = &quot;Batch-Balances&quot;}, function(msg)
  -- Validate input
  local success, err = semiFungibleTokensValidation.batchBalances(msg, Market.cpmm.tokens.positionIds)
  -- If validation fails, provide error response.
  if not success then
    msg.reply({
      Action = &quot;Batch-Balances-Error&quot;,
      Error = err
    })
    return
  end
  -- If validation passes, get the batch balances.
  Market:batchBalances(msg)
end)

--- Balances all handler
--- @warning Not recommended for production use; returns an unbounded amount of data.
--- @param msg Message The message received
Handlers.add(&#39;Balances-All&#39;, {Action = &quot;Balances-All&quot;}, function(msg)
  Market:balancesAll(msg)
end)

--[[
===========================
CONFIGURATOR WRITE HANDLERS
===========================
]]

--- Update configurator handler
--- @param msg Message The message received
Handlers.add(&#39;Update-Configurator&#39;, {Action = &quot;Update-Configurator&quot;}, function(msg)
  -- Validate input
  local success, err = cpmmValidation.updateConfigurator(msg, Market.cpmm.configurator)
  -- If validation fails, provide error response.
  if not success then
    msg.reply({
      Action = &quot;Update-Configurator-Error&quot;,
      Error = err
    })
    return
  end
  -- If validation passes, update the configurator.
  Market:updateConfigurator(msg)
end)

--- Update data index handler
--- @param msg Message The message received
Handlers.add(&quot;Update-Data-Index&quot;, {Action = &quot;Update-Data-Index&quot;}, function(msg)
  -- Validate input
  local success, err = marketValidation.updateDataIndex(msg, Market.cpmm.configurator)
  -- If validation fails, provide error response.
  if not success then
    msg.reply({
      Action = &quot;Update-Data-Index-Error&quot;,
      Error = err
    })
    return
  end
  -- If validation passes, update the data index.
  Market:updateDataIndex(msg)
end)

--- Update take fee handler
--- @param msg Message The message received
Handlers.add(&#39;Update-Take-Fee&#39;, {Action = &quot;Update-Take-Fee&quot;}, function(msg)
  -- Validate input
  local success, err = cpmmValidation.updateTakeFee(msg, Market.cpmm.configurator)
  -- If validation fails, provide error response.
  if not success then
    msg.reply({
      Action = &quot;Update-Take-Fee-Error&quot;,
      Error = err
    })
    return
  end
  -- If validation passes, update the take fee.
  Market:updateTakeFee(msg)
end)

--- Update protocol fee target handler
--- @param msg Message The message received
Handlers.add(&#39;Update-Protocol-Fee-Target&#39;, {Action = &quot;Update-Protocol-Fee-Target&quot;}, function(msg)
  -- Validate input
  local success, err = cpmmValidation.updateProtocolFeeTarget(msg, Market.cpmm.configurator)
  -- If validation fails, provide error response.
  if not success then
    msg.reply({
      Action = &quot;Update-Protocol-Fee-Target-Error&quot;,
      Error = err
    })
    return
  end
  -- If validation passes, update the protocol fee target.
  Market:updateProtocolFeeTarget(msg)
end)

--- Update logo handler
--- @param msg Message The message received
Handlers.add(&#39;Update-Logo&#39;, {Action = &quot;Update-Logo&quot;}, function(msg)
  -- Validate input
  local success, err = cpmmValidation.updateLogo(msg, Market.cpmm.configurator)
  -- If validation fails, provide error response.
  if not success then
    msg.reply({
      Action = &quot;Update-Logo-Error&quot;,
      Error = err
    })
    return
  end
  -- If validation passes, update the logo.
  Market:updateLogo(msg)
end)

return &quot;ok&quot;

<span class="fc" data-hits="1">]===]</span>
</pre>
      </div>

      <div class="hidden file success-high" id="src-marketmodules-conditionaltokens">
         <h2 class="title">
            src/marketModules/conditionalTokens.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 100.00%"></span>
                  <span><strong>100.00%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>105</strong> Hits</span>
               <span class="miss"><strong>0</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums">--[[
======================================================================================
Outcome © 2025. All Rights Reserved.
======================================================================================
This code is proprietary and owned by Outcome.

You are permitted to build applications, integrations, and extensions that interact
with the Outcome Protocol, provided such usage adheres to the official Outcome
terms of service and does not result in unauthorized forks or clones of this codebase.

Redistribution, modification, or unauthorized use of this code is strictly prohibited
without explicit written permission from Outcome.
======================================================================================
]]

<span class="fc" data-hits="3">local ConditionalTokens = {}</span>
<span class="fc" data-hits="3">local ConditionalTokensMethods = {}</span>
<span class="fc" data-hits="3">local ConditionalTokensNotices = require(&#39;marketModules.conditionalTokensNotices&#39;)</span>
<span class="fc" data-hits="3">local SemiFungibleTokens = require(&#39;marketModules.semiFungibleTokens&#39;)</span>
<span class="fc" data-hits="3">local bint = require(&#39;.bint&#39;)(256)</span>
<span class="fc" data-hits="3">local ao = ao or require(&#39;.ao&#39;)</span>

--- Represents ConditionalTokens
--- @class ConditionalTokens
--- @field name string The token name
--- @field ticker string The token ticker
--- @field logo string The token logo Arweave TxID
--- @field balancesById table&lt;string, table&lt;string, string&gt;&gt; The account token balances by ID
--- @field totalSupplyById table&lt;string, string&gt; The total supply of the token by ID
--- @field denomination number The number of decimals
--- @field resolutionAgent string The process ID of the resolution agent
--- @field collateralToken string The process ID of the collateral token
--- @field positionIds table&lt;string&gt; The position IDs representing outcomes
--- @field payoutNumerators table&lt;number&gt; The relative payouts for each outcome slot
--- @field payoutDenominator number The sum of payout numerators, zero if unreported
--- @field creatorFee number The creator fee to be paid, in basis points
--- @field creatorFeeTarget string The process ID to receive the creator fee
--- @field protocolFee number The protocol fee to be paid, in basis points
--- @field protocolFeeTarget string The process ID to receive the protocol fee

--- Creates a new ConditionalTokens instance
--- @param name string The token name
--- @param ticker string The token ticker
--- @param logo string The token logo Arweave TxID
--- @param balancesById table&lt;string, table&lt;string, string&gt;&gt; The account token balances by ID
--- @param totalSupplyById table&lt;string, string&gt; The total supply of the token by ID
--- @param denomination number The number of decimals
--- @param resolutionAgent string The process ID of the resolution agent
--- @param collateralToken string The process ID of the collateral token
--- @param positionIds table&lt;string&gt; The position IDs representing outcomes
--- @param creatorFee number The creator fee to be paid, in basis points
--- @param creatorFeeTarget string The process ID to receive the creator fee
--- @param protocolFee number The protocol fee to be paid, in basis points
--- @param protocolFeeTarget string The process ID to receive the protocol fee
--- @return ConditionalTokens conditionalTokens The new ConditionalTokens instance
<span class="fc" data-hits="3">function ConditionalTokens.new(</span>
  name,
  ticker,
  logo,
  balancesById,
  totalSupplyById,
  denomination,
  resolutionAgent,
  collateralToken,
  positionIds,
  creatorFee,
  creatorFeeTarget,
  protocolFee,
  protocolFeeTarget
)
  ---@class ConditionalTokens : SemiFungibleTokens
<span class="fc" data-hits="31">  local conditionalTokens = SemiFungibleTokens.new(name, ticker, logo, balancesById, totalSupplyById, denomination)</span>
<span class="fc" data-hits="31">  conditionalTokens.resolutionAgent = resolutionAgent</span>
<span class="fc" data-hits="31">  conditionalTokens.collateralToken = collateralToken</span>
<span class="fc" data-hits="31">  conditionalTokens.positionIds = positionIds</span>
<span class="fc" data-hits="31">  conditionalTokens.creatorFee = tonumber(creatorFee) or 0</span>
<span class="fc" data-hits="31">  conditionalTokens.creatorFeeTarget = creatorFeeTarget</span>
<span class="fc" data-hits="31">  conditionalTokens.protocolFee = tonumber(protocolFee) or 0</span>
<span class="fc" data-hits="31">  conditionalTokens.protocolFeeTarget = protocolFeeTarget</span>
<span class="fc" data-hits="31">  conditionalTokens.payoutDenominator = 0</span>
  -- Initialize the payout vector as zeros.
<span class="fc" data-hits="31">  conditionalTokens.payoutNumerators = {}</span>
<span class="fc" data-hits="107">  for _ = 1, #positionIds do</span>
<span class="fc" data-hits="76">    table.insert(conditionalTokens.payoutNumerators, 0)</span>
  end
  -- Initialize the denominator to zero to indicate that the condition has not been resolved.
<span class="fc" data-hits="31">  conditionalTokens.payoutDenominator = 0</span>

<span class="fc" data-hits="31">  local semiFungibleTokensMetatable = getmetatable(conditionalTokens)</span>
<span class="fc" data-hits="62">  setmetatable(conditionalTokens, {</span>
    __index = function(_, k)
<span class="fc" data-hits="138">      if ConditionalTokensMethods[k] then</span>
<span class="fc" data-hits="37">        return ConditionalTokensMethods[k]</span>
<span class="fc" data-hits="101">      elseif ConditionalTokensNotices[k] then</span>
<span class="fc" data-hits="26">        return ConditionalTokensNotices[k]</span>
      else
        -- Fallback directly to the parent metatable
<span class="fc" data-hits="75">        return semiFungibleTokensMetatable.__index(_, k)</span>
      end
    end
  })
<span class="fc" data-hits="31">  return conditionalTokens</span>
end

--- Split position
--- @param from string The process ID of the account that split the position
--- @param collateralToken string The process ID of the collateral token
--- @param quantity string The quantity of collateral to split
--- @param msg Message The message received
--- @return Message The position split notice
<span class="fc" data-hits="3">function ConditionalTokensMethods:splitPosition(from, collateralToken, quantity, msg)</span>
<span class="fc" data-hits="22">  assert(self.payoutNumerators and #self.payoutNumerators &gt; 0, &quot;Condition not prepared!&quot;)</span>
  -- Create equal split positions.
<span class="fc" data-hits="22">  local quantities = {}</span>
<span class="fc" data-hits="77">  for _ = 1, #self.positionIds do</span>
<span class="fc" data-hits="55">    table.insert(quantities, quantity)</span>
  end
  -- Mint the stake in the split target positions.
<span class="fc" data-hits="22">  self:batchMint(from, self.positionIds, quantities, msg)</span>
  -- Send notice.
<span class="fc" data-hits="20">  return self.positionSplitNotice(from, collateralToken, quantity, msg)</span>
end

--- Merge positions
--- @param from string The process ID of the account that merged the positions
--- @param onBehalfOf string The process ID of the account that will receive the collateral
--- @param quantity string The quantity of collateral to merge
--- @param isSell boolean True if the merge is a sell, false otherwise
--- @param msg Message The message received
--- @param useReply boolean Whether to use `msg.reply` or `ao.send`
--- @return Message The positions merge notice
<span class="fc" data-hits="3">function ConditionalTokensMethods:mergePositions(from, onBehalfOf, quantity, isSell, msg, useReply)</span>
<span class="fc" data-hits="4">  assert(self.payoutNumerators and #self.payoutNumerators &gt; 0, &quot;Condition not prepared!&quot;)</span>
  -- Create equal merge positions.
<span class="fc" data-hits="4">  local quantities = {}</span>
<span class="fc" data-hits="16">  for _ = 1, #self.positionIds do</span>
<span class="fc" data-hits="12">    table.insert(quantities, quantity)</span>
  end
  -- Burn equal quantiies from user positions.
<span class="fc" data-hits="4">  self:batchBurn(from, self.positionIds, quantities, msg, false)</span>
  -- @dev below already handled within the sell method.
  -- sell method w&#47; a different quantity and recipient.
<span class="fc" data-hits="2">  if not isSell then</span>
    -- Return the collateral to the user.
<span class="fc" data-hits="2">    ao.send({</span>
<span class="fc" data-hits="1">      Target = self.collateralToken,</span>
<span class="fc" data-hits="1">      Action = &quot;Transfer&quot;,</span>
<span class="fc" data-hits="1">      Quantity = quantity,</span>
<span class="fc" data-hits="1">      Recipient = onBehalfOf</span>
    })
  end
  -- Send notice.
<span class="fc" data-hits="2">  return self.positionsMergeNotice(self.collateralToken, quantity, onBehalfOf, msg, useReply)</span>
end

--- Report payouts
--- @param payouts table&lt;number&gt; The resolution agent&#39;s answer
--- @param msg Message The message received
--- @return Message reportPayoutsNotice The report payouts notice
<span class="fc" data-hits="3">function ConditionalTokensMethods:reportPayouts(payouts, msg)</span>
<span class="fc" data-hits="7">  assert(#payouts == #self.positionIds, &quot;Payouts must match outcome slot count!&quot;)</span>
<span class="fc" data-hits="6">  assert(msg.From == self.resolutionAgent, &quot;Sender not resolution agent!&quot;)</span>
<span class="fc" data-hits="5">  assert(self.payoutDenominator == 0, &quot;payout denominator already set&quot;)</span>
  -- Set the payout vector for the condition.
<span class="fc" data-hits="4">  local den = 0</span>
<span class="fc" data-hits="16">  for i = 1, #self.positionIds do</span>
<span class="fc" data-hits="12">    local num = payouts[i]</span>
<span class="fc" data-hits="12">    den = den + num</span>
<span class="fc" data-hits="12">    assert(self.payoutNumerators[i] == 0, &quot;payout numerator already set&quot;)</span>
<span class="fc" data-hits="12">    self.payoutNumerators[i] = num</span>
  end
<span class="fc" data-hits="4">  assert(den &gt; 0, &quot;payout is all zeroes&quot;)</span>
<span class="fc" data-hits="3">  self.payoutDenominator = den</span>
  -- Send notice.
<span class="fc" data-hits="3">  return self.reportPayoutsNotice(msg.From, self.payoutNumerators, msg)</span>
end

--- Redeem positions
--- Transfers any payout minus fees to the message sender
--- @param onBehalfOf string The process ID of the account to receive the collateral
--- @param msg Message The message received
--- @return Message The payout redemption notice
<span class="fc" data-hits="3">function ConditionalTokensMethods:redeemPositions(onBehalfOf, msg)</span>
<span class="fc" data-hits="2">  local den = self.payoutDenominator</span>
<span class="fc" data-hits="2">  assert(den &gt; 0, &quot;market not resolved&quot;)</span>
<span class="fc" data-hits="1">  assert(self.payoutNumerators and #self.payoutNumerators &gt; 0, &quot;market not initialized&quot;)</span>
<span class="fc" data-hits="1">  local totalPayout = 0</span>
<span class="fc" data-hits="1">  local totalPayoutMinusFee = &quot;0&quot;</span>
<span class="fc" data-hits="4">  for i = 1, #self.positionIds do</span>
<span class="fc" data-hits="3">    local positionId = self.positionIds[i]</span>
<span class="fc" data-hits="3">    local payoutNumerator = self.payoutNumerators[tonumber(positionId)]</span>
    -- Get the stake to redeem.
<span class="fc" data-hits="3">    if not self.balancesById[positionId] then self.balancesById[positionId] = {} end</span>
<span class="fc" data-hits="3">    if not self.balancesById[positionId][msg.From] then self.balancesById[positionId][msg.From] = &quot;0&quot; end</span>
<span class="fc" data-hits="3">    local payoutStake = self.balancesById[positionId][msg.From]</span>
<span class="fc" data-hits="3">    if bint.__lt(0, bint(payoutStake)) then</span>
      -- Calculate the payout and burn position.
<span class="fc" data-hits="3">      totalPayout = math.floor(totalPayout + (payoutStake * payoutNumerator) &#47; den)</span>
<span class="fc" data-hits="3">      self:burn(msg.From, positionId, payoutStake, msg, false)</span>
    end
  end
  -- Return total payout minus take fee.
<span class="fc" data-hits="1">  if totalPayout &gt; 0 then</span>
<span class="fc" data-hits="1">    totalPayout = math.floor(totalPayout)</span>
<span class="fc" data-hits="1">    totalPayoutMinusFee = self:returnTotalPayoutMinusTakeFee(self.collateralToken, onBehalfOf, totalPayout)</span>
  end
  -- Send notice.
<span class="fc" data-hits="1">  return self.redeemPositionsNotice(self.collateralToken, totalPayout, totalPayoutMinusFee, onBehalfOf, msg)</span>
end

--- Return total payout minus take fee
--- Distributes payout and fees to the redeem account, creator and protocol
--- @param collateralToken string The collateral token
--- @param from string The account to receive the payout minus fees
--- @param totalPayout number The total payout assciated with the acount stake
--- @return string The total payout minus fee amount
<span class="fc" data-hits="3">function ConditionalTokensMethods:returnTotalPayoutMinusTakeFee(collateralToken, from, totalPayout)</span>
<span class="fc" data-hits="2">  local protocolFee =  tostring(bint.ceil(bint.__div(bint.__mul(totalPayout, self.protocolFee), 1e4)))</span>
<span class="fc" data-hits="2">  local creatorFee =  tostring(bint.ceil(bint.__div(bint.__mul(totalPayout, self.creatorFee), 1e4)))</span>
<span class="fc" data-hits="2">  local takeFee = tostring(bint.__add(bint(creatorFee), bint(protocolFee)))</span>
<span class="fc" data-hits="2">  local totalPayoutMinusFee = tostring(bint.__sub(totalPayout, bint(takeFee)))</span>
  -- prepare txns
<span class="fc" data-hits="2">  local protocolFeeTxn = {</span>
<span class="fc" data-hits="2">    Target = collateralToken,</span>
<span class="fc" data-hits="2">    Action = &quot;Transfer&quot;,</span>
<span class="fc" data-hits="2">    Recipient = self.protocolFeeTarget,</span>
<span class="fc" data-hits="2">    Quantity = protocolFee,</span>
  }
<span class="fc" data-hits="2">  local creatorFeeTxn = {</span>
<span class="fc" data-hits="2">    Target = collateralToken,</span>
<span class="fc" data-hits="2">    Action = &quot;Transfer&quot;,</span>
<span class="fc" data-hits="2">    Recipient = self.creatorFeeTarget,</span>
<span class="fc" data-hits="2">    Quantity = creatorFee,</span>
  }
<span class="fc" data-hits="2">  local totalPayoutMinutTakeFeeTxn = {</span>
<span class="fc" data-hits="2">    Target = collateralToken,</span>
<span class="fc" data-hits="2">    Action = &quot;Transfer&quot;,</span>
<span class="fc" data-hits="2">    Recipient = from,</span>
<span class="fc" data-hits="2">    Quantity = totalPayoutMinusFee</span>
  }
  -- send txns
<span class="fc" data-hits="2">  ao.send(protocolFeeTxn)</span>
<span class="fc" data-hits="2">  ao.send(creatorFeeTxn)</span>
<span class="fc" data-hits="2">  ao.send(totalPayoutMinutTakeFeeTxn)</span>

<span class="fc" data-hits="2">  return totalPayoutMinusFee</span>
end

<span class="fc" data-hits="3">return ConditionalTokens</span>
</pre>
      </div>

      <div class="hidden file success-high" id="src-marketmodules-conditionaltokensnotices">
         <h2 class="title">
            src/marketModules/conditionalTokensNotices.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 94.44%"></span>
                  <span><strong>94.44%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>34</strong> Hits</span>
               <span class="miss"><strong>2</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums">--[[
=========================================================
Part of the Outcome codebase © 2025. All Rights Reserved.
See conditionalTokens.lua for full license details.
=========================================================
]]

<span class="fc" data-hits="4">local json = require(&#39;json&#39;)</span>
<span class="fc" data-hits="4">local ao = ao or require(&#39;.ao&#39;)</span>

<span class="fc" data-hits="4">local ConditionalTokensNotices = {}</span>

--- Report payouts notice
--- @param resolutionAgent string The process assigned to report the result for the prepared condition
--- @param payoutNumerators table&lt;number&gt; The payout numerators for each outcome slot
--- @param msg Message The message received
--- @return Message reportPayoutsNotice The report payouts notice
<span class="fc" data-hits="4">function ConditionalTokensNotices.reportPayoutsNotice(resolutionAgent, payoutNumerators, msg)</span>
<span class="fc" data-hits="8">  return msg.reply({</span>
<span class="fc" data-hits="4">    Action = &quot;Report-Payouts-Notice&quot;,</span>
<span class="fc" data-hits="4">    ResolutionAgent = resolutionAgent,</span>
<span class="fc" data-hits="4">    PayoutNumerators = json.encode(payoutNumerators)</span>
  })
end

--- Position split notice
--- @param from string The address of the account that split the position
--- @param collateralToken string The address of the collateral token
--- @param quantity string The quantity
--- @param msg Message The message received
--- @return Message The position split notice
<span class="fc" data-hits="4">function ConditionalTokensNotices.positionSplitNotice(from, collateralToken, quantity, msg)</span>
<span class="fc" data-hits="21">  local notice = {</span>
<span class="fc" data-hits="21">    Action = &quot;Split-Position-Notice&quot;,</span>
<span class="fc" data-hits="21">    Process = ao.id,</span>
<span class="fc" data-hits="21">    Stakeholder = from,</span>
<span class="fc" data-hits="21">    CollateralToken = collateralToken,</span>
<span class="fc" data-hits="21">    Quantity = quantity</span>
  }
  -- Forward tags
<span class="fc" data-hits="116">  for tagName, tagValue in pairs(msg) do</span>
    -- Tags beginning with &quot;X-&quot; are forwarded
<span class="fc" data-hits="95">    if string.sub(tagName, 1, 2) == &quot;X-&quot; then</span>
<span class="fc" data-hits="12">      notice[tagName] = tagValue</span>
    end
  end
  -- Send notice | @dev ao.send vs msg.reply to ensure message is sent to user (not collateralToken)
<span class="fc" data-hits="21">  return msg.forward(from, notice)</span>
end

--- Positions merge notice
--- @param collateralToken string The address of the collateral token
--- @param quantity string The quantity
--- @param onBehalfOf string The address of the account to receive the collateral
--- @param msg Message The message received
--- @param useReply boolean Whether to use `msg.reply` or `ao.send`
--- @return Message The positions merge notice
<span class="fc" data-hits="4">function ConditionalTokensNotices.positionsMergeNotice(collateralToken, quantity, onBehalfOf, msg, useReply)</span>
<span class="fc" data-hits="3">  local notice = {</span>
<span class="fc" data-hits="3">    Action = &quot;Merge-Positions-Notice&quot;,</span>
<span class="fc" data-hits="3">    OnBehalfOf = onBehalfOf,</span>
<span class="fc" data-hits="3">    CollateralToken = collateralToken,</span>
<span class="fc" data-hits="3">    Quantity = quantity</span>
  }
<span class="fc" data-hits="3">  if useReply then return msg.reply(notice) end</span>
<span class="nc">  notice.Target = msg.Sender and msg.Sender or msg.From</span>
<span class="nc">  return ao.send(notice)</span>
end

--- Redeem positions notice
--- @param collateralToken string The address of the collateral token
--- @param payout number The payout amount
--- @param netPayout string The net payout amount (after fees)
--- @param onBehalfOf string The address of the account to receive the payout
--- @param msg Message The message received
--- @return Message The payout redemption notice
<span class="fc" data-hits="4">function ConditionalTokensNotices.redeemPositionsNotice(collateralToken, payout, netPayout, onBehalfOf, msg)</span>
<span class="fc" data-hits="4">  return msg.reply({</span>
<span class="fc" data-hits="2">    Action = &quot;Redeem-Positions-Notice&quot;,</span>
<span class="fc" data-hits="2">    CollateralToken = collateralToken,</span>
<span class="fc" data-hits="2">    GrossPayout = tostring(payout),</span>
<span class="fc" data-hits="2">    NetPayout = netPayout,</span>
<span class="fc" data-hits="2">    OnBehalfOf = onBehalfOf</span>
  })
end

<span class="fc" data-hits="4">return ConditionalTokensNotices</span>
</pre>
      </div>

      <div class="hidden file success-medium" id="src-marketmodules-conditionaltokensvalidation">
         <h2 class="title">
            src/marketModules/conditionalTokensValidation.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 88.89%"></span>
                  <span><strong>88.89%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>40</strong> Hits</span>
               <span class="miss"><strong>5</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums">--[[
=========================================================
Part of the Outcome codebase © 2025. All Rights Reserved.
See conditionalTokens.lua for full license details.
=========================================================
]]

<span class="fc" data-hits="1">local ConditionalTokensValidation = {}</span>
<span class="fc" data-hits="1">local sharedValidation = require(&#39;marketModules.sharedValidation&#39;)</span>
<span class="fc" data-hits="1">local sharedUtils = require(&#39;marketModules.sharedUtils&#39;)</span>
<span class="fc" data-hits="1">local bint = require(&#39;.bint&#39;)(256)</span>
<span class="fc" data-hits="1">local json = require(&#39;json&#39;)</span>

--- Validates quantity
--- @param quantity any The quantity to be validated
--- @return boolean, string|nil Returns true on success, or false and an error message on failure
local function validateQuantity(quantity)
<span class="fc" data-hits="6">  if type(quantity) ~= &#39;string&#39; then</span>
<span class="fc" data-hits="1">    return false, &#39;Quantity is required and must be a string!&#39;</span>
  end

<span class="fc" data-hits="5">  local num = tonumber(quantity)</span>
<span class="fc" data-hits="5">  if not num then</span>
<span class="fc" data-hits="1">    return false, &#39;Quantity must be a valid number!&#39;</span>
  end
<span class="fc" data-hits="4">  if num &lt;= 0 then</span>
<span class="fc" data-hits="2">    return false, &#39;Quantity must be greater than zero!&#39;</span>
  end
<span class="fc" data-hits="2">  if num % 1 ~= 0 then</span>
<span class="fc" data-hits="1">    return false, &#39;Quantity must be an integer!&#39;</span>
  end

<span class="fc" data-hits="1">  return true</span>
end

--- Validates payouts
--- @param payouts any The payouts to be validated
--- @return boolean, string|nil Returns true on success, or false and an error message on failure
local function validatePayouts(payouts)
<span class="fc" data-hits="4">  if not payouts then</span>
<span class="fc" data-hits="1">    return false, &quot;Payouts is required!&quot;</span>
  end
<span class="fc" data-hits="3">  if not sharedUtils.isJSONArray(payouts) then</span>
<span class="fc" data-hits="1">    return false, &quot;Payouts must be a valid JSON Array!&quot;</span>
  end

<span class="fc" data-hits="2">  local decodedPayouts = json.decode(payouts)</span>
<span class="fc" data-hits="6">  for _, payout in ipairs(decodedPayouts) do</span>
<span class="fc" data-hits="5">    if not tonumber(payout) then</span>
<span class="fc" data-hits="1">      return false, &quot;Payouts item must be a valid number!&quot;</span>
    end
  end

<span class="fc" data-hits="1">  return true</span>
end

--- Validates the mergePositions message.
--- @param msg Message The message to be validated
--- @param cpmm CPMM The CPMM instance for checking token balances
--- @return boolean, string|nil Returns true on success, or false and an error message on failure
<span class="fc" data-hits="1">function ConditionalTokensValidation.mergePositions(msg, cpmm)</span>
<span class="fc" data-hits="6">  local onBehalfOf = msg.Tags[&#39;OnBehalfOf&#39;] or msg.From</span>
  local success, err

<span class="fc" data-hits="6">  if not onBehalfOf then</span>
<span class="nc">    success, err = sharedValidation.validateAddress(onBehalfOf, &#39;onBehalfOf&#39;)</span>
<span class="nc">    if not success then return false, err end</span>
  end

<span class="fc" data-hits="6">  success, err = validateQuantity(msg.Tags.Quantity)</span>
<span class="fc" data-hits="6">  if not success then return false, err end</span>

  -- Check user balances for each position
<span class="fc" data-hits="4">  for i = 1, #cpmm.tokens.positionIds do</span>
<span class="fc" data-hits="3">    local positionId = cpmm.tokens.positionIds[i]</span>

<span class="fc" data-hits="3">    if not cpmm.tokens.balancesById[positionId] then</span>
<span class="nc">      return false, &quot;Invalid position! PositionId: &quot; .. positionId</span>
    end

<span class="fc" data-hits="3">    if not cpmm.tokens.balancesById[positionId][onBehalfOf] then</span>
<span class="nc">      return false, &quot;Invalid user position! PositionId: &quot; .. positionId</span>
    end

<span class="fc" data-hits="3">    if bint(cpmm.tokens.balancesById[positionId][onBehalfOf]) &lt; bint(msg.Tags.Quantity) then</span>
<span class="nc">      return false, &quot;Insufficient tokens! PositionId: &quot; .. positionId</span>
    end
  end

<span class="fc" data-hits="1">  return true</span>
end


--- Validates the reportPayouts message
--- @param msg Message The message to be validated
--- @param resolutionAgent string The resolution agent process ID
--- @return boolean, string|nil Returns true on success, or false and an error message on failure
<span class="fc" data-hits="1">function ConditionalTokensValidation.reportPayouts(msg, resolutionAgent)</span>
<span class="fc" data-hits="5">  if msg.From ~= resolutionAgent then</span>
<span class="fc" data-hits="1">    return false, &quot;Sender must be the resolution agent!&quot;</span>
  end

<span class="fc" data-hits="4">  return validatePayouts(msg.Tags.Payouts)</span>
end

<span class="fc" data-hits="1">return ConditionalTokensValidation</span>
</pre>
      </div>

      <div class="hidden file success-high" id="src-marketmodules-constants">
         <h2 class="title">
            src/marketModules/constants.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 100.00%"></span>
                  <span><strong>100.00%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>77</strong> Hits</span>
               <span class="miss"><strong>0</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums">--[[
=========================================================
Part of the Outcome codebase © 2025. All Rights Reserved.
See market.lua for full license details.
=========================================================
]]

<span class="fc" data-hits="2">local constants = {}</span>
<span class="fc" data-hits="2">local json = require(&#39;json&#39;)</span>
-- DB
<span class="fc" data-hits="2">constants.db = {</span>
<span class="fc" data-hits="2">  intervals = {</span>
<span class="fc" data-hits="2">    [&quot;1h&quot;] = &quot;1 minute&quot;,</span>
<span class="fc" data-hits="2">    [&quot;6h&quot;] = &quot;1 minute&quot;,</span>
<span class="fc" data-hits="2">    [&quot;1d&quot;] = &quot;5 minutes&quot;,</span>
<span class="fc" data-hits="2">    [&quot;1w&quot;] = &quot;3 hours&quot;,</span>
<span class="fc" data-hits="2">    [&quot;1M&quot;] = &quot;12 hours&quot;,</span>
<span class="fc" data-hits="2">    [&quot;max&quot;] = &quot;1 day&quot;</span>
<span class="fc" data-hits="2">  },</span>
<span class="fc" data-hits="2">  rangeDurations = {</span>
<span class="fc" data-hits="2">    [&quot;1h&quot;] = &quot;1 hour&quot;,</span>
<span class="fc" data-hits="2">    [&quot;6h&quot;] = &quot;6 hours&quot;,</span>
<span class="fc" data-hits="2">    [&quot;1d&quot;] = &quot;1 day&quot;,</span>
<span class="fc" data-hits="2">    [&quot;1w&quot;] = &quot;7 days&quot;,</span>
<span class="fc" data-hits="2">    [&quot;1M&quot;] = &quot;1 month&quot;</span>
<span class="fc" data-hits="2">  },</span>
<span class="fc" data-hits="2">  maxInterval = &quot;1 day&quot;,</span>
<span class="fc" data-hits="2">  maxRangeDuration = &quot;100 years&quot;,</span>
<span class="fc" data-hits="2">  defaultLimit = 50,</span>
<span class="fc" data-hits="2">  defaultOffset = 0,</span>
<span class="fc" data-hits="2">  defaultActivityWindow = 24,</span>
<span class="fc" data-hits="2">  moderators = {},</span>
<span class="fc" data-hits="2">}</span>
-- Market Factory
<span class="fc" data-hits="2">constants.marketFactory = {</span>
<span class="fc" data-hits="2">  configurator = &quot;test-this-is-valid-arweave-wallet-address-1&quot;,</span>
<span class="fc" data-hits="2">  namePrefix = &quot;Outcome Market&quot;,</span>
<span class="fc" data-hits="2">  tickerPrefix = &quot;OUTCOME&quot;,</span>
<span class="fc" data-hits="2">  logo = &quot;https:&#47;&#47;test.com&#47;logo.png&quot;,</span>
<span class="fc" data-hits="2">  lpFee = &quot;100&quot;,</span>
<span class="fc" data-hits="2">  protocolFee = &quot;250&quot;,</span>
<span class="fc" data-hits="2">  protocolFeeTarget = &quot;test-this-is-valid-arweave-wallet-address-3&quot;,</span>
<span class="fc" data-hits="2">  maximumTakeFee = &quot;500&quot;,</span>
<span class="fc" data-hits="2">  utilityToken = &quot;test-this-is-valid-arweave-wallet-address-4&quot;,</span>
<span class="fc" data-hits="2">  minimumPayment = &quot;1000&quot;,</span>
<span class="fc" data-hits="2">  collateralTokens = {&quot;test-this-is-valid-arweave-wallet-address-5&quot;}</span>
<span class="fc" data-hits="2">}</span>
-- Market
<span class="fc" data-hits="2">constants.testMarketConfig = {</span>
<span class="fc" data-hits="2">  configurator = &quot;test-this-is-valid-arweave-wallet-address-6&quot;,</span>
<span class="fc" data-hits="2">  collateralToken = &quot;test-this-is-valid-arweave-wallet-address-2&quot;,</span>
<span class="fc" data-hits="2">  conditionId = &quot;c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470&quot;,</span>
<span class="fc" data-hits="2">  positionIds = json.encode({&quot;1&quot;, &quot;2&quot;}),</span>
<span class="fc" data-hits="2">  name = &quot;Test Market&quot;,</span>
<span class="fc" data-hits="2">  ticker = &quot;TST&quot;,</span>
<span class="fc" data-hits="2">  logo = &quot;https:&#47;&#47;test.com&#47;logo.png&quot;,</span>
<span class="fc" data-hits="2">  lpFee = &quot;100&quot;,</span>
<span class="fc" data-hits="2">  creatorFee = &quot;100&quot;,</span>
<span class="fc" data-hits="2">  creatorFeeTarget = &quot;test-this-is-valid-arweave-wallet-address-3&quot;,</span>
<span class="fc" data-hits="2">  protocolFee = &quot;100&quot;,</span>
<span class="fc" data-hits="2">  protocolFeeTarget = &quot;test-this-is-valid-arweave-wallet-address-4&quot;</span>
<span class="fc" data-hits="2">}</span>
-- Activity
<span class="fc" data-hits="2">constants.activity = {</span>
<span class="fc" data-hits="2">  configurator = &quot;test-this-is-valid-arweave-wallet-address-1&quot;,</span>
<span class="fc" data-hits="2">}</span>
-- CPMM
<span class="fc" data-hits="2">constants.denomination = 12</span>
-- Market Config
<span class="fc" data-hits="2">constants.marketConfig = {</span>
<span class="fc" data-hits="2">  configurator = &quot;b9hj1yVw3eWGIggQgJxRDj1t8SZFCezctYD-7U5nYFk&quot;,</span>
<span class="fc" data-hits="2">  dataIndex = &quot;rXSAUKwZhJkIBTIEyBl1rf8Gtk_88RKQFsx5JvDOwlE&quot;,</span>
<span class="fc" data-hits="2">  collateralToken = &quot;jAyJBNpuSXmhn9lMMfwDR60TfIPANXI6r-f3n9zucYU&quot;,</span>
<span class="fc" data-hits="2">  resolutionAgent = &quot;ukmrCFkEWdFH_xS4UicCErwCqGT2RJjr1qlk4U720C8&quot;,</span>
<span class="fc" data-hits="2">  creator = &quot;XkVOo16KMIHK-zqlR67cuNY0ayXIkPWODWw_HXAE20I&quot;,</span>
<span class="fc" data-hits="2">  question = &quot;Liquid Ops oUSDC interest reaches 8% in March&quot;,</span>
<span class="fc" data-hits="2">  rules = &quot;Where we&#39;re going, we don&#39;t need rules&quot;,</span>
<span class="fc" data-hits="2">  category = &quot;Finance&quot;,</span>
<span class="fc" data-hits="2">  sucategory = &quot;Interest Rates&quot;,</span>
<span class="fc" data-hits="2">  positionIds = json.encode({&quot;1&quot;,&quot;2&quot;}),</span>
<span class="fc" data-hits="2">  name = &quot;Mock Spawn Market&quot;,</span>
<span class="fc" data-hits="2">  ticker = &#39;MSM&#39;,</span>
<span class="fc" data-hits="2">  logo = &quot;https:&#47;&#47;test.com&#47;logo.png&quot;,</span>
<span class="fc" data-hits="2">  lpFee = &quot;100&quot;,</span>
<span class="fc" data-hits="2">  creatorFee = &quot;250&quot;,</span>
<span class="fc" data-hits="2">  creatorFeeTarget = &quot;m6W6wreOSejTb2WRHoALM6M7mw3H8D2KmFVBYC1l0O0&quot;,</span>
<span class="fc" data-hits="2">  protocolFee = &quot;250&quot;,</span>
<span class="fc" data-hits="2">  protocolFeeTarget = &quot;m6W6wreOSejTb2WRHoALM6M7mw3H8D2KmFVBYC1l0O0&quot;</span>
<span class="fc" data-hits="2">}</span>

<span class="fc" data-hits="2">return constants</span>
</pre>
      </div>

      <div class="hidden file success-low" id="src-marketmodules-cpmm">
         <h2 class="title">
            src/marketModules/cpmm.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 68.90%"></span>
                  <span><strong>68.90%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>144</strong> Hits</span>
               <span class="miss"><strong>65</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums">--[[
======================================================================================
Outcome © 2025. All Rights Reserved.
======================================================================================
This code is proprietary and owned by Outcome.

You are permitted to build applications, integrations, and extensions that interact
with the Outcome Protocol, provided such usage adheres to the official Outcome
terms of service and does not result in unauthorized forks or clones of this codebase.

Redistribution, modification, or unauthorized use of this code is strictly prohibited
without explicit written permission from Outcome.
======================================================================================
]]

<span class="fc" data-hits="2">local CPMM = {}</span>
<span class="fc" data-hits="2">local CPMMMethods = {}</span>
<span class="fc" data-hits="2">local CPMMHelpers = require(&#39;marketModules.cpmmHelpers&#39;)</span>
<span class="fc" data-hits="2">local CPMMNotices = require(&#39;marketModules.cpmmNotices&#39;)</span>
<span class="fc" data-hits="2">local bint = require(&#39;.bint&#39;)(256)</span>
<span class="fc" data-hits="2">local utils = require(&quot;.utils&quot;)</span>
<span class="fc" data-hits="2">local token = require(&#39;marketModules.token&#39;)</span>
<span class="fc" data-hits="2">local constants = require(&quot;marketModules.constants&quot;)</span>
<span class="fc" data-hits="2">local conditionalTokens = require(&#39;marketModules.conditionalTokens&#39;)</span>

--- Represents a CPMM (Constant Product Market Maker)
--- @class CPMM
--- @field configurator string The process ID of the configurator
--- @field poolBalances table&lt;string, ...&gt; The pool balance for each respective position ID
--- @field withdrawnFees table&lt;string, string&gt; The amount of fees withdrawn by an account
--- @field feePoolWeight string The total amount of fees collected
--- @field totalWithdrawnFees string The total amount of fees withdrawn

--- Creates a new CPMM instance
--- @param configurator string The process ID of the configurator
--- @param collateralToken string The process ID of the collateral token
--- @param resolutionAgent string The process ID of the resolution agent
--- @param positionIds table&lt;string, ...&gt; The position IDs
--- @param name string The CPMM token(s) name
--- @param ticker string The CPMM token(s) ticker
--- @param logo string The CPMM token(s) logo
--- @param lpFee number The liquidity provider fee
--- @param creatorFee number The market creator fee
--- @param creatorFeeTarget string The market creator fee target
--- @param protocolFee number The protocol fee
--- @param protocolFeeTarget string The protocol fee target
--- @return CPMM cpmm The new CPMM instance
<span class="fc" data-hits="2">function CPMM.new(configurator, collateralToken, resolutionAgent, positionIds, name, ticker, logo, lpFee, creatorFee, creatorFeeTarget, protocolFee, protocolFeeTarget)</span>
<span class="fc" data-hits="15">  local cpmm = {</span>
<span class="fc" data-hits="15">    configurator = configurator,</span>
<span class="fc" data-hits="15">    poolBalances = {},</span>
<span class="fc" data-hits="15">    withdrawnFees = {},</span>
<span class="fc" data-hits="15">    feePoolWeight = &quot;0&quot;,</span>
<span class="fc" data-hits="15">    totalWithdrawnFees = &quot;0&quot;,</span>
<span class="fc" data-hits="15">    lpFee = tonumber(lpFee)</span>
  }
<span class="fc" data-hits="30">  cpmm.token = token.new(</span>
<span class="fc" data-hits="15">    name .. &quot; LP Token&quot;,</span>
<span class="fc" data-hits="15">    ticker,</span>
<span class="fc" data-hits="15">    logo,</span>
    {}, -- balances
<span class="fc" data-hits="15">    &quot;0&quot;, -- totalSupply</span>
    constants.denomination
<span class="fc" data-hits="30">  )</span>
<span class="fc" data-hits="30">  cpmm.tokens = conditionalTokens.new(</span>
<span class="fc" data-hits="15">    name .. &quot; Conditional Tokens&quot;,</span>
<span class="fc" data-hits="15">    ticker,</span>
<span class="fc" data-hits="15">    logo,</span>
<span class="fc" data-hits="15">    {}, -- balancesById</span>
    {}, -- totalSupplyById
<span class="fc" data-hits="15">    constants.denomination,</span>
<span class="fc" data-hits="15">    resolutionAgent,</span>
<span class="fc" data-hits="15">    collateralToken,</span>
<span class="fc" data-hits="15">    positionIds,</span>
<span class="fc" data-hits="15">    creatorFee,</span>
<span class="fc" data-hits="15">    creatorFeeTarget,</span>
<span class="fc" data-hits="15">    protocolFee,</span>
    protocolFeeTarget
<span class="fc" data-hits="30">  )</span>
<span class="fc" data-hits="30">  setmetatable(cpmm, {</span>
    __index = function(_, k)
<span class="fc" data-hits="78">      if CPMMMethods[k] then</span>
<span class="fc" data-hits="51">        return CPMMMethods[k]</span>
<span class="fc" data-hits="27">      elseif CPMMHelpers[k] then</span>
<span class="fc" data-hits="12">        return CPMMHelpers[k]</span>
<span class="fc" data-hits="15">      elseif CPMMNotices[k] then</span>
<span class="fc" data-hits="15">        return CPMMNotices[k]</span>
      else
<span class="nc">        return nil</span>
      end
    end
  })
<span class="fc" data-hits="15">  return cpmm</span>
end

--- Add funding
--- @param onBehalfOf string The process ID of the account to receive the LP tokens
--- @param addedFunds string The amount of funds to add
--- @param distributionHint table&lt;number&gt; The initial probability distribution
--- @param msg Message The message received
--- @return Message The funding added notice
<span class="fc" data-hits="2">function CPMMMethods:addFunding(onBehalfOf, addedFunds, distributionHint, msg)</span>
<span class="fc" data-hits="11">  assert(bint.__lt(0, bint(addedFunds)), &quot;funding must be non-zero&quot;)</span>
<span class="fc" data-hits="11">  local sendBackAmounts = {}</span>
<span class="fc" data-hits="11">  local poolShareSupply = self.token.totalSupply</span>
  local mintAmount

<span class="fc" data-hits="11">  if bint.iszero(bint(poolShareSupply)) then</span>
<span class="fc" data-hits="11">    assert(distributionHint, &quot;must use distribution hint for initial funding&quot;)</span>
    -- Initial Liquidity
<span class="fc" data-hits="11">    if #distributionHint &gt; 0 then</span>
<span class="fc" data-hits="11">      local maxHint = 0</span>
<span class="fc" data-hits="33">      for i = 1, #distributionHint do</span>
<span class="fc" data-hits="22">        local hint = distributionHint[i]</span>
<span class="fc" data-hits="22">        if maxHint &lt; hint then</span>
<span class="fc" data-hits="13">          maxHint = hint</span>
        end
      end
      -- Calculate sendBackAmounts
<span class="fc" data-hits="31">      for i = 1, #distributionHint do</span>
<span class="fc" data-hits="21">        local remaining = math.floor((addedFunds * distributionHint[i]) &#47; maxHint)</span>
<span class="fc" data-hits="21">        assert(remaining &gt; 0, &quot;must hint a valid distribution&quot;)</span>
<span class="fc" data-hits="20">        sendBackAmounts[i] = addedFunds - remaining</span>
      end
    end
    -- Calculate mintAmount
<span class="fc" data-hits="10">    mintAmount = tostring(addedFunds)</span>
  else
    -- Additional Liquidity
<span class="nc">    assert(not distributionHint, &quot;cannot use distribution hint after initial funding&quot;)</span>
    -- Get poolBalances
<span class="nc">    local poolBalances = self:getPoolBalances()</span>
    -- Calculate poolWeight
<span class="nc">    local poolWeight = 0</span>
<span class="nc">    for i = 1, #poolBalances do</span>
<span class="nc">      local balance = poolBalances[i]</span>
<span class="nc">      if bint.__lt(poolWeight, bint(balance)) then</span>
<span class="nc">        poolWeight = bint(balance)</span>
      end
    end
    -- Calculate sendBackAmounts
<span class="nc">    for i = 1, #poolBalances do</span>
<span class="nc">      local remaining = math.floor((addedFunds * poolBalances[i]) &#47; poolWeight)</span>
<span class="nc">      sendBackAmounts[i] = addedFunds - remaining</span>
    end
    -- Calculate mintAmount
    ---@diagnostic disable-next-line: param-type-mismatch
<span class="nc">    mintAmount = tostring(math.floor(tostring(bint.__div(bint.__mul(addedFunds, poolShareSupply), poolWeight))))</span>
  end
  -- Mint Conditional Positions
<span class="fc" data-hits="10">  self.tokens:splitPosition(ao.id, self.tokens.collateralToken, addedFunds, msg)</span>
  -- Mint LP Tokens
<span class="fc" data-hits="8">  self:mint(onBehalfOf, mintAmount, msg)</span>
  -- Remove non-zero items before transfer-batch
<span class="fc" data-hits="8">  local nonZeroAmounts = {}</span>
<span class="fc" data-hits="8">  local nonZeroPositionIds = {}</span>
<span class="fc" data-hits="24">  for i = 1, #sendBackAmounts do</span>
<span class="fc" data-hits="16">    if sendBackAmounts[i] &gt; 0 then</span>
<span class="fc" data-hits="2">      table.insert(nonZeroAmounts, tostring(math.floor(sendBackAmounts[i])))</span>
<span class="fc" data-hits="2">      table.insert(nonZeroPositionIds, self.tokens.positionIds[i])</span>
    end
  end
  -- Send back conditional tokens should there be an uneven distribution
<span class="fc" data-hits="8">  if #nonZeroAmounts ~= 0 then</span>
<span class="fc" data-hits="2">    self.tokens:transferBatch(ao.id, onBehalfOf, nonZeroPositionIds, nonZeroAmounts, true, msg)</span>
  end
  -- Transform sendBackAmounts to array of amounts added
<span class="fc" data-hits="24">  for i = 1, #sendBackAmounts do</span>
<span class="fc" data-hits="16">    sendBackAmounts[i] = addedFunds - sendBackAmounts[i]</span>
  end
  -- Send notice with amounts added
<span class="fc" data-hits="8">  return self.addFundingNotice(sendBackAmounts, mintAmount, onBehalfOf, msg)</span>
end

--- Remove funding
--- @param onBehalfOf string The process ID of the account to receive the position tokens
--- @param sharesToBurn string The amount of shares to burn
--- @param msg Message The message received
--- @return Message The funding removed notice
<span class="fc" data-hits="2">function CPMMMethods:removeFunding(onBehalfOf, sharesToBurn, msg)</span>
<span class="fc" data-hits="3">  assert(bint.__lt(0, bint(sharesToBurn)), &quot;funding must be non-zero&quot;)</span>
  -- Get poolBalances
<span class="fc" data-hits="3">  local poolBalances = self:getPoolBalances()</span>
  -- Calculate sendAmounts
<span class="fc" data-hits="3">  local sendAmounts = {}</span>
<span class="fc" data-hits="9">  for i = 1, #poolBalances do</span>
<span class="fc" data-hits="6">    sendAmounts[i] = tostring(math.floor((poolBalances[i] * sharesToBurn) &#47; self.token.totalSupply))</span>
  end
  -- Calculate collateralRemovedFromFeePool
<span class="fc" data-hits="3">  local collateralRemovedFromFeePool = ao.send({Target = self.tokens.collateralToken, Action = &#39;Balance&#39;}).receive().Data</span>
<span class="fc" data-hits="3">  self:burn(msg.From, sharesToBurn, msg)</span>
<span class="fc" data-hits="3">  local poolFeeBalance = ao.send({Target = self.tokens.collateralToken, Action = &#39;Balance&#39;}).receive().Data</span>
<span class="fc" data-hits="3">  collateralRemovedFromFeePool = tostring(math.floor(poolFeeBalance - collateralRemovedFromFeePool))</span>
  -- Send conditionalTokens amounts
<span class="fc" data-hits="3">  self.tokens:transferBatch(ao.id, onBehalfOf, self.tokens.positionIds, sendAmounts, false, msg)</span>
  -- Send notice
<span class="fc" data-hits="3">  return self.removeFundingNotice(sendAmounts, collateralRemovedFromFeePool, sharesToBurn, onBehalfOf, msg)</span>
end

--- Calc buy amount
--- @param investmentAmount number The amount to stake on an outcome
--- @param positionId string The position ID of the outcome
--- @return string The amount of tokens to be purchased
<span class="fc" data-hits="2">function CPMMMethods:calcBuyAmount(investmentAmount, positionId)</span>
<span class="fc" data-hits="2">  assert(bint.__lt(0, investmentAmount), &#39;InvestmentAmount must be greater than zero!&#39;)</span>
<span class="fc" data-hits="2">  assert(utils.includes(positionId, self.tokens.positionIds), &#39;PositionId must be valid!&#39;)</span>

<span class="fc" data-hits="2">  local poolBalances = self:getPoolBalances()</span>
<span class="fc" data-hits="2">  local investmentAmountMinusFees = investmentAmount - ((investmentAmount * self.lpFee) &#47; 1e4) -- converts fee from basis points to decimal</span>
<span class="fc" data-hits="2">  local buyTokenPoolBalance = poolBalances[tonumber(positionId)]</span>
<span class="fc" data-hits="2">  local endingOutcomeBalance = buyTokenPoolBalance * 1e4</span>

<span class="fc" data-hits="6">  for i = 1, #poolBalances do</span>
<span class="fc" data-hits="4">    if not bint.__eq(bint(i), bint(positionId)) then</span>
<span class="fc" data-hits="2">      local poolBalance = poolBalances[i]</span>
<span class="fc" data-hits="2">      endingOutcomeBalance = CPMMHelpers.ceildiv(endingOutcomeBalance * poolBalance, poolBalance + investmentAmountMinusFees)</span>
    end
  end

<span class="fc" data-hits="2">  assert(endingOutcomeBalance &gt; 0, &quot;must have non-zero balances&quot;)</span>
<span class="fc" data-hits="2">  return tostring(bint.ceil(buyTokenPoolBalance + investmentAmountMinusFees - CPMMHelpers.ceildiv(endingOutcomeBalance, 1e4)))</span>
end

--- Calc sell amount
--- @param returnAmount number The amount to unstake from an outcome
---@param positionId string The position ID of the outcome
---@return string The amount of tokens to be sold
<span class="fc" data-hits="2">function CPMMMethods:calcSellAmount(returnAmount, positionId)</span>
<span class="nc">  assert(bint.__lt(0, returnAmount), &#39;ReturnAmount must be greater than zero!&#39;)</span>
<span class="nc">  assert(utils.includes(positionId, self.tokens.positionIds), &#39;PositionId must be valid!&#39;)</span>

<span class="nc">  local poolBalances = self:getPoolBalances()</span>
<span class="nc">  local returnAmountPlusFees = CPMMHelpers.ceildiv(returnAmount * 1e4, 1e4 - self.lpFee)</span>
<span class="nc">  local sellTokenPoolBalance = poolBalances[tonumber(positionId)]</span>
<span class="nc">  local endingOutcomeBalance = sellTokenPoolBalance * 1e4</span>

<span class="nc">  for i = 1, #poolBalances do</span>
<span class="nc">    if not bint.__eq(bint(i), bint(positionId)) then</span>
<span class="nc">      local poolBalance = poolBalances[i]</span>
<span class="nc">      assert(poolBalance - returnAmountPlusFees &gt; 0, &quot;PoolBalance must be greater than return amount plus fees!&quot;)</span>
<span class="nc">      endingOutcomeBalance = CPMMHelpers.ceildiv(endingOutcomeBalance * poolBalance, poolBalance - returnAmountPlusFees)</span>
    end
  end

<span class="nc">  assert(endingOutcomeBalance &gt; 0, &quot;must have non-zero balances&quot;)</span>
<span class="nc">  return tostring(bint.ceil(returnAmountPlusFees + CPMMHelpers.ceildiv(endingOutcomeBalance, 1e4) - sellTokenPoolBalance))</span>
end

--- Calc probabilities
--- @return table&lt;string, number&gt; probabilities A table mapping each positionId to its probability (as a decimal percentage)
<span class="fc" data-hits="2">function CPMMMethods:calcProbabilities()</span>
<span class="nc">  local poolBalances = self:getPoolBalances()</span>
<span class="nc">  local totalBalance = bint(0)</span>
<span class="nc">  local probabilities = {}</span>
  -- Calculate total balance
<span class="nc">  for i = 1, #self.tokens.positionIds do</span>
<span class="nc">    totalBalance = bint.__add(totalBalance, bint(poolBalances[i]))</span>
  end
<span class="nc">  assert(bint.__lt(bint(0), totalBalance), &#39;Total pool balance must be greater than zero!&#39;)</span>
  -- Calculate probabilities for each positionId
<span class="nc">  for i = 1, #self.tokens.positionIds do</span>
<span class="nc">    local positionId = self.tokens.positionIds[i]</span>
<span class="nc">    local balance = bint(poolBalances[i])</span>
<span class="nc">    local probability = tostring(bint.__div(balance, totalBalance))</span>
<span class="nc">    probabilities[positionId] = probability</span>
  end
<span class="nc">  return probabilities</span>
end

--- Buy
--- @param from string The process ID of the account that initiates the buy
--- @param onBehalfOf string The process ID of the account to receive the tokens
--- @param investmentAmount number The amount to stake on an outcome
--- @param positionId string The position ID of the outcome
--- @param minPositionTokensToBuy number The minimum number of outcome tokens to buy
--- @param msg Message The message received
--- @return Message The buy notice
<span class="fc" data-hits="2">function CPMMMethods:buy(from, onBehalfOf, investmentAmount, positionId, minPositionTokensToBuy, msg)</span>
<span class="fc" data-hits="1">  local positionTokensToBuy = self:calcBuyAmount(investmentAmount, positionId)</span>
<span class="fc" data-hits="1">  assert(bint.__le(minPositionTokensToBuy, bint(positionTokensToBuy)), &quot;Minimum position tokens not reached!&quot;)</span>
  -- Calculate investmentAmountMinusFees.
<span class="fc" data-hits="1">  local feeAmount = tostring(bint.ceil(bint.__div(bint.__mul(investmentAmount, self.lpFee), 1e4)))</span>
<span class="fc" data-hits="1">  self.feePoolWeight = tostring(bint.__add(bint(self.feePoolWeight), bint(feeAmount)))</span>
<span class="fc" data-hits="1">  local investmentAmountMinusFees = tostring(bint.__sub(investmentAmount, bint(feeAmount)))</span>
  -- Split position through all conditions
<span class="fc" data-hits="1">  self.tokens:splitPosition(ao.id, self.tokens.collateralToken, investmentAmountMinusFees, msg)</span>
  -- Transfer buy position to onBehalfOf
<span class="fc" data-hits="1">  self.tokens:transferSingle(ao.id, onBehalfOf, positionId, positionTokensToBuy, true, msg, false)</span>
  -- Send notice.
<span class="fc" data-hits="1">  return self.buyNotice(from, onBehalfOf, investmentAmount, feeAmount, positionId, positionTokensToBuy, msg)</span>
end

--- Sell
--- @param from string The process ID of the account that initiates the sell
--- @param onBehalfOf string The process ID of the account to receive the tokens
--- @param returnAmount number The amount to unstake from an outcome
--- @param positionId string The position ID of the outcome
--- @param maxPositionTokensToSell number The max outcome tokens to sell
--- @return Message The sell notice
<span class="fc" data-hits="2">function CPMMMethods:sell(from, onBehalfOf, returnAmount, positionId, maxPositionTokensToSell, msg)</span>
  -- Calculate outcome tokens to sell.
<span class="nc">  local positionTokensToSell = self:calcSellAmount(returnAmount, positionId)</span>
<span class="nc">  assert(bint.__le(bint(positionTokensToSell), bint(maxPositionTokensToSell)), &quot;Maximum sell amount exceeded!&quot;)</span>
  -- Calculate returnAmountPlusFees.
<span class="nc">  local feeAmount = tostring(bint.ceil(bint.__div(bint.__mul(returnAmount, self.lpFee), bint.__sub(1e4, self.lpFee))))</span>
<span class="nc">  self.feePoolWeight = tostring(bint.__add(bint(self.feePoolWeight), bint(feeAmount)))</span>
<span class="nc">  local returnAmountPlusFees = tostring(bint.__add(returnAmount, bint(feeAmount)))</span>
  -- Check sufficient liquidity within the process or revert.
<span class="nc">  local collataralBalance = ao.send({Target = self.tokens.collateralToken, Action = &quot;Balance&quot;, [&quot;X-Action&quot;] = &quot;Check Liquidity&quot;}).receive().Data</span>
<span class="nc">  assert(bint.__le(bint(returnAmountPlusFees), bint(collataralBalance)), &quot;Insufficient liquidity!&quot;)</span>
  -- Check user balance and transfer positionTokensToSell to process before merge.
<span class="nc">  local balance = self.tokens:getBalance(from, nil, positionId)</span>
<span class="nc">  assert(bint.__le(bint(positionTokensToSell), bint(balance)), &#39;Insufficient balance!&#39;)</span>
<span class="nc">  self.tokens:transferSingle(from, ao.id, positionId, positionTokensToSell, true, msg, false)</span>
  -- Merge positions through all conditions (burns returnAmountPlusFees).
<span class="nc">  self.tokens:mergePositions(ao.id, &#39;&#39;, positionTokensToSell, true, msg, false)</span>
  -- Returns collateral to the user &#47; onBehalfOf address
<span class="nc">  msg.forward(self.tokens.collateralToken,{</span>
    Action = &quot;Transfer&quot;,
    Quantity = tostring(returnAmount),
<span class="nc">    Recipient = onBehalfOf</span>
  })
  -- Send notice (Process continued via &quot;SellOrderCompletionCollateralToken&quot; and &quot;SellOrderCompletionConditionalTokens&quot; handlers)
<span class="nc">  return self.sellNotice(from, onBehalfOf, returnAmount, feeAmount, positionId, positionTokensToSell, msg)</span>
end

--- Colleced fees
--- @return string The total unwithdrawn fees collected by the CPMM
<span class="fc" data-hits="2">function CPMMMethods:collectedFees()</span>
<span class="fc" data-hits="6">  return tostring(math.ceil(self.feePoolWeight - self.totalWithdrawnFees))</span>
end

--- Fees withdrawable
--- @param account string The process ID of the account
--- @return string The fees withdrawable by the account
<span class="fc" data-hits="2">function CPMMMethods:feesWithdrawableBy(account)</span>
<span class="fc" data-hits="3">  local balance = self.token.balances[account] or &#39;0&#39;</span>
<span class="fc" data-hits="3">  local rawAmount = &#39;0&#39;</span>
<span class="fc" data-hits="3">  if bint(self.token.totalSupply) &gt; 0 then</span>
<span class="fc" data-hits="3">    rawAmount = string.format(&#39;%.0f&#39;, (bint.__div(bint.__mul(bint(self:collectedFees()), bint(balance)), self.token.totalSupply)))</span>
  end
<span class="fc" data-hits="3">  return tostring(bint.max(bint(bint.__sub(bint(rawAmount), bint(self.withdrawnFees[account] or &#39;0&#39;))), 0))</span>
end

--- Withdraw fees
--- @param sender string The process ID of the sender
--- @param onBehalfOf string The process ID of the account to receive the fees
--- @param msg Message The message received
--- @param useReply boolean Whether to use `msg.reply` or `ao.send`
--- @return Message The withdraw fees message
<span class="fc" data-hits="2">function CPMMMethods:withdrawFees(sender, onBehalfOf, msg, useReply)</span>
<span class="fc" data-hits="3">  local feeAmount = self:feesWithdrawableBy(sender)</span>
<span class="fc" data-hits="3">  if bint.__lt(0, bint(feeAmount)) then</span>
<span class="fc" data-hits="1">    self.withdrawnFees[sender] = feeAmount</span>
<span class="fc" data-hits="1">    self.totalWithdrawnFees = tostring(bint.__add(bint(self.totalWithdrawnFees), bint(feeAmount)))</span>
<span class="fc" data-hits="1">    msg.forward(self.tokens.collateralToken, {Action = &#39;Transfer&#39;, Recipient = onBehalfOf, Quantity = feeAmount})</span>
  end
<span class="fc" data-hits="3">  return self.withdrawFeesNotice(feeAmount, onBehalfOf, msg, useReply)</span>
end

--- Before token transfer
--- Updates fee accounting before token transfers
--- @param from string|nil The process ID of the account executing the transaction
--- @param to string|nil The process ID of the account receiving the transaction
--- @param amount string The amount transferred
--- @param msg Message The message received
<span class="fc" data-hits="2">function CPMMMethods:_beforeTokenTransfer(from, to, amount, msg)</span>
<span class="fc" data-hits="11">  if from ~= nil and from ~= ao.id then</span>
<span class="fc" data-hits="3">    self:withdrawFees(from, from, msg, false)</span>
  end
<span class="fc" data-hits="11">  local totalSupply = self.token.totalSupply</span>
<span class="fc" data-hits="11">  local withdrawnFeesTransfer = totalSupply == &#39;0&#39; and amount or tostring(bint(bint.__div(bint.__mul(bint(self:collectedFees()), bint(amount)), totalSupply)))</span>

<span class="fc" data-hits="11">  if from ~= nil and to ~= nil and from ~= ao.id then</span>
<span class="nc">    self.withdrawnFees[from] = tostring(bint.__sub(bint(self.withdrawnFees[from] or &#39;0&#39;), bint(withdrawnFeesTransfer)))</span>
<span class="nc">    self.withdrawnFees[to] = tostring(bint.__add(bint(self.withdrawnFees[to] or &#39;0&#39;), bint(withdrawnFeesTransfer)))</span>
  end
end

--- @dev See `Mint` in modules.token
<span class="fc" data-hits="2">function CPMMMethods:mint(to, quantity, msg)</span>
<span class="fc" data-hits="8">  self:_beforeTokenTransfer(nil, to, quantity, msg)</span>
<span class="fc" data-hits="8">  return self.token:mint(to, quantity, msg)</span>
end

--- @dev See `Burn` in modules.token
-- @dev See tokenMethods:burn &amp; _beforeTokenTransfer
<span class="fc" data-hits="2">function CPMMMethods:burn(from, quantity, msg)</span>
<span class="fc" data-hits="3">  self:_beforeTokenTransfer(from, nil, quantity, msg)</span>
<span class="fc" data-hits="3">  return self.token:burn(from, quantity, msg)</span>
end

--- @dev See `Transfer` in modules.token
-- @dev See tokenMethods:transfer &amp; _beforeTokenTransfer
<span class="fc" data-hits="2">function CPMMMethods:transfer(from, recipient, quantity, cast, msg)</span>
<span class="nc">  self:_beforeTokenTransfer(from, recipient, quantity, msg)</span>
<span class="nc">  return self.token:transfer(from, recipient, quantity, cast, msg)</span>
end

--- Update configurator
--- @param configurator string The process ID of the new configurator
--- @param msg Message The message received
--- @return Message The update configurator notice
<span class="fc" data-hits="2">function CPMMMethods:updateConfigurator(configurator, msg)</span>
<span class="nc">  self.configurator = configurator</span>
<span class="nc">  return self.updateConfiguratorNotice(configurator, msg)</span>
end

--- Update take fee
--- @param creatorFee string The new creator fee in basis points
--- @param protocolFee string The new protocol fee in basis points
--- @param msg Message The message received
--- @return Message The update take fee notice
<span class="fc" data-hits="2">function CPMMMethods:updateTakeFee(creatorFee, protocolFee, msg)</span>
<span class="nc">  self.tokens.creatorFee = creatorFee</span>
<span class="nc">  self.tokens.protocolFee = protocolFee</span>
<span class="nc">  return self.updateTakeFeeNotice(creatorFee, protocolFee, creatorFee + protocolFee, msg)</span>
end

--- Update protocol fee targer
--- @param target string The process ID of the new protocol fee target
--- @param msg Message The message received
--- @return Message The update protocol fee target notice
<span class="fc" data-hits="2">function CPMMMethods:updateProtocolFeeTarget(target, msg)</span>
<span class="nc">  self.tokens.protocolFeeTarget = target</span>
<span class="nc">  return self.updateProtocolFeeTargetNotice(target, msg)</span>
end

--- Update logo
--- @param logo string The Arweave transaction ID of the new logo
--- @param msg Message The message received
--- @return Message The update logo notice
<span class="fc" data-hits="2">function CPMMMethods:updateLogo(logo, msg)</span>
<span class="nc">  self.token.logo = logo</span>
<span class="nc">  self.tokens.logo = logo</span>
<span class="nc">  return self.updateLogoNotice(logo, msg)</span>
end

<span class="fc" data-hits="2">return CPMM</span>
</pre>
      </div>

      <div class="hidden file success-high" id="src-marketmodules-cpmmhelpers">
         <h2 class="title">
            src/marketModules/cpmmHelpers.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 100.00%"></span>
                  <span><strong>100.00%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>17</strong> Hits</span>
               <span class="miss"><strong>0</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums">--[[
=========================================================
Part of the Outcome codebase © 2025. All Rights Reserved.
See cpmm.lua for full license details.
=========================================================
]]

<span class="fc" data-hits="3">local CPMMHelpers = {}</span>

--- Calculate the ceildiv of x &#47; y
--- @param x number The numerator
--- @param y number The denominator
--- @return number The ceil div of x &#47; y
<span class="fc" data-hits="3">function CPMMHelpers.ceildiv(x, y)</span>
<span class="fc" data-hits="7">  if x &gt; 0 then</span>
<span class="fc" data-hits="6">    return math.floor((x - 1) &#47; y) + 1</span>
  end
<span class="fc" data-hits="1">  return math.floor(x &#47; y)</span>
end

--- Generate position IDs
--- @param outcomeSlotCount number The number of outcome slots
--- @return table&lt;string&gt; A basic partition based on outcomeSlotCount
<span class="fc" data-hits="3">function CPMMHelpers.getPositionIds(outcomeSlotCount)</span>
<span class="fc" data-hits="1">  local positionIds = {}</span>
<span class="fc" data-hits="4">  for i = 1, outcomeSlotCount do</span>
<span class="fc" data-hits="3">    table.insert(positionIds, tostring(i))</span>
  end
<span class="fc" data-hits="1">  return positionIds</span>
end

--- Gets pool balances
--- @return table&lt;string&gt; Pool balances for each ID
<span class="fc" data-hits="3">function CPMMHelpers:getPoolBalances()</span>
  -- Get poolBalances
<span class="fc" data-hits="13">  local selves = {}</span>
<span class="fc" data-hits="40">  for _ = 1, #self.tokens.positionIds do</span>
<span class="fc" data-hits="27">    table.insert(selves, ao.id)</span>
  end
<span class="fc" data-hits="13">  local poolBalances = self.tokens:getBatchBalance(selves, self.tokens.positionIds)</span>
<span class="fc" data-hits="13">  return poolBalances</span>
end

<span class="fc" data-hits="3">return CPMMHelpers</span>
</pre>
      </div>

      <div class="hidden file success-high" id="src-marketmodules-cpmmnotices">
         <h2 class="title">
            src/marketModules/cpmmNotices.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 100.00%"></span>
                  <span><strong>100.00%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>63</strong> Hits</span>
               <span class="miss"><strong>0</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums">--[[
=========================================================
Part of the Outcome codebase © 2025. All Rights Reserved.
See cpmm.lua for full license details.
=========================================================
]]

-- local ao = require(&#39;.ao&#39;) @dev required for unit tests?
<span class="fc" data-hits="3">local json = require(&#39;json&#39;)</span>

<span class="fc" data-hits="3">local CPMMNotices = {}</span>

--- Sends an add funding notice
--- @param fundingAdded table The funding added
--- @param mintAmount number The mint amount
--- @param onBehalfOf string The address to receive the LP tokens
--- @param msg Message The message received
--- @return Message The funding added notice
<span class="fc" data-hits="3">function CPMMNotices.addFundingNotice(fundingAdded, mintAmount, onBehalfOf, msg)</span>
<span class="fc" data-hits="18">  return msg.forward(msg.Tags.Sender, {</span>
<span class="fc" data-hits="9">    Action = &quot;Add-Funding-Notice&quot;,</span>
<span class="fc" data-hits="9">    FundingAdded = json.encode(fundingAdded),</span>
<span class="fc" data-hits="9">    MintAmount = tostring(mintAmount),</span>
<span class="fc" data-hits="9">    OnBehalfOf = onBehalfOf,</span>
<span class="fc" data-hits="9">    Data = &quot;Successfully added funding&quot;</span>
  })
end

--- Sends a remove funding notice
--- @param sendAmounts table The send amounts
--- @param collateralRemovedFromFeePool string The collateral removed from the fee pool
--- @param sharesToBurn string The shares to burn
--- @param onBehalfOf string The address to receive the position tokens
--- @param msg Message The message received
--- @return Message The funding removed notice
<span class="fc" data-hits="3">function CPMMNotices.removeFundingNotice(sendAmounts, collateralRemovedFromFeePool, sharesToBurn, onBehalfOf, msg)</span>
<span class="fc" data-hits="8">  return msg.reply({</span>
<span class="fc" data-hits="4">    Action = &quot;Remove-Funding-Notice&quot;,</span>
<span class="fc" data-hits="4">    SendAmounts = json.encode(sendAmounts),</span>
<span class="fc" data-hits="4">    CollateralRemovedFromFeePool = collateralRemovedFromFeePool,</span>
<span class="fc" data-hits="4">    SharesToBurn = sharesToBurn,</span>
<span class="fc" data-hits="4">    OnBehalfOf = onBehalfOf,</span>
<span class="fc" data-hits="4">    Data = &quot;Successfully removed funding&quot;</span>
  })
end

--- Sends a buy notice
--- @param from string The address that bought
--- @param onBehalfOf string The address that receives the outcome tokens
--- @param investmentAmount number The investment amount
--- @param feeAmount number The fee amount
--- @param positionId string The position ID
--- @param positionTokensBought number The outcome position tokens bought
--- @param msg Message The message received
--- @return Message The buy notice
<span class="fc" data-hits="3">function CPMMNotices.buyNotice(from, onBehalfOf, investmentAmount, feeAmount, positionId, positionTokensBought, msg)</span>
<span class="fc" data-hits="4">  return msg.forward(from, {</span>
<span class="fc" data-hits="2">    Action = &quot;Buy-Notice&quot;,</span>
<span class="fc" data-hits="2">    OnBehalfOf = onBehalfOf,</span>
<span class="fc" data-hits="2">    InvestmentAmount = tostring(investmentAmount),</span>
<span class="fc" data-hits="2">    FeeAmount = tostring(feeAmount),</span>
<span class="fc" data-hits="2">    PositionId = positionId,</span>
<span class="fc" data-hits="2">    PositionTokensBought = tostring(positionTokensBought),</span>
<span class="fc" data-hits="2">    Data = &quot;Successful buy order&quot;</span>
  })
end

--- Sends a sell notice
--- @param from string The address that sold
--- @param onBehalfOf string The address that receives the collateral
--- @param returnAmount number The return amount
--- @param feeAmount number The fee amount
--- @param positionId string The position ID
--- @param positionTokensSold number The outcome position tokens sold
--- @param msg Message The message received
--- @return Message The sell notice
<span class="fc" data-hits="3">function CPMMNotices.sellNotice(from, onBehalfOf, returnAmount, feeAmount, positionId, positionTokensSold, msg)</span>
<span class="fc" data-hits="2">  return msg.forward(from, {</span>
<span class="fc" data-hits="1">    Action = &quot;Sell-Notice&quot;,</span>
<span class="fc" data-hits="1">    OnBehalfOf = onBehalfOf,</span>
<span class="fc" data-hits="1">    ReturnAmount = tostring(returnAmount),</span>
<span class="fc" data-hits="1">    FeeAmount = tostring(feeAmount),</span>
<span class="fc" data-hits="1">    PositionId = positionId,</span>
<span class="fc" data-hits="1">    PositionTokensSold = tostring(positionTokensSold),</span>
<span class="fc" data-hits="1">    Data = &quot;Successful sell order&quot;</span>
  })
end

--- Sends a withdraw fees notice
--- @notice Returns notice with `msg.reply` if `useReply` is true, otherwise uses `ao.send`
--- @dev Ensures the final notice is sent to the user, preventing unintended message handling
--- @param feeAmount number The fee amount
--- @param onBehalfOf string The address to receive the fees
--- @param msg Message The message received
--- @param useReply boolean Whether to use `msg.reply` or `ao.send`
--- @return Message The withdraw fees notice
<span class="fc" data-hits="3">function CPMMNotices.withdrawFeesNotice(feeAmount, onBehalfOf, msg, useReply)</span>
<span class="fc" data-hits="3">  local notice = {</span>
<span class="fc" data-hits="3">    Action = &quot;Withdraw-Fees-Notice&quot;,</span>
<span class="fc" data-hits="3">    OnBehalfOf = onBehalfOf,</span>
<span class="fc" data-hits="3">    FeeAmount = tostring(feeAmount),</span>
<span class="fc" data-hits="3">    Data = &quot;Successfully withdrew fees&quot;</span>
  }
<span class="fc" data-hits="3">  if useReply then return msg.reply(notice) end</span>
<span class="fc" data-hits="3">  notice.Target = msg.Sender and msg.Sender or msg.From</span>
<span class="fc" data-hits="3">  return ao.send(notice)</span>
end

--- Sends an update configurator notice
--- @param configurator string The updated configurator address
--- @param msg Message The message received
--- @return Message The configurator updated notice
<span class="fc" data-hits="3">function CPMMNotices.updateConfiguratorNotice(configurator, msg)</span>
<span class="fc" data-hits="2">  return msg.reply({</span>
<span class="fc" data-hits="1">    Action = &quot;Update-Configurator-Notice&quot;,</span>
<span class="fc" data-hits="1">    Data = configurator</span>
  })
end

--- Sends an update take fee notice
--- @param creatorFee string The updated creator fee
--- @param protocolFee string The updated protocol fee
--- @param takeFee string The updated take fee
--- @param msg Message The message received
<span class="fc" data-hits="3">function CPMMNotices.updateTakeFeeNotice(creatorFee, protocolFee, takeFee, msg)</span>
<span class="fc" data-hits="2">  return msg.reply({</span>
<span class="fc" data-hits="1">    Action = &quot;Update-Take-Fee-Notice&quot;,</span>
<span class="fc" data-hits="1">    CreatorFee = tostring(creatorFee),</span>
<span class="fc" data-hits="1">    ProtocolFee = tostring(protocolFee),</span>
<span class="fc" data-hits="1">    Data = tostring(takeFee)</span>
  })
end

--- Sends an update protocol fee target notice
--- @param protocolFeeTarget string The updated protocol fee target
--- @param msg Message The message received
--- @return Message The protocol fee target updated notice
<span class="fc" data-hits="3">function CPMMNotices.updateProtocolFeeTargetNotice(protocolFeeTarget, msg)</span>
<span class="fc" data-hits="2">  return msg.reply({</span>
<span class="fc" data-hits="1">    Action = &quot;Update-Protocol-Fee-Target-Notice&quot;,</span>
<span class="fc" data-hits="1">    Data = protocolFeeTarget</span>
  })
end

--- Sends an update logo notice
--- @param logo string The updated logo
--- @param msg Message The message received
--- @return Message The logo updated notice
<span class="fc" data-hits="3">function CPMMNotices.updateLogoNotice(logo, msg)</span>
<span class="fc" data-hits="2">  return msg.reply({</span>
<span class="fc" data-hits="1">    Action = &quot;Update-Logo-Notice&quot;,</span>
<span class="fc" data-hits="1">    Data = logo</span>
  })
end

<span class="fc" data-hits="3">return CPMMNotices</span>
</pre>
      </div>

      <div class="hidden file success-low" id="src-marketmodules-cpmmvalidation">
         <h2 class="title">
            src/marketModules/cpmmValidation.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 67.59%"></span>
                  <span><strong>67.59%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>73</strong> Hits</span>
               <span class="miss"><strong>35</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums">--[[
=========================================================
Part of the Outcome codebase © 2025. All Rights Reserved.
See cpmm.lua for full license details.
=========================================================
]]

<span class="fc" data-hits="1">local cpmmValidation = {}</span>
<span class="fc" data-hits="1">local sharedValidation = require(&#39;marketModules.sharedValidation&#39;)</span>
<span class="fc" data-hits="1">local bint = require(&#39;.bint&#39;)(256)</span>
<span class="fc" data-hits="1">local json = require(&quot;json&quot;)</span>

--- Validates add funding
--- @param msg Message The message to be validated
--- @param totalSupply string The LP token total supply
--- @param positionIds table&lt;string&gt; The outcome position IDs
--- @return boolean, string|nil
<span class="fc" data-hits="1">function cpmmValidation.addFunding(msg, totalSupply, positionIds)</span>
<span class="fc" data-hits="9">  local isValid, err = sharedValidation.validatePositiveInteger(msg.Tags.Quantity, &quot;Quantity&quot;)</span>
<span class="fc" data-hits="9">  if not isValid then</span>
<span class="fc" data-hits="3">    return false, err</span>
  end

  -- Extract distribution
<span class="fc" data-hits="6">  local distribution = msg.Tags[&quot;X-Distribution&quot;] and json.decode(msg.Tags[&quot;X-Distribution&quot;]) or nil</span>

  -- Check if distribution is required or must be omitted
<span class="fc" data-hits="6">  local isFirstFunding = bint.iszero(bint(totalSupply))</span>
<span class="fc" data-hits="6">  if distribution then</span>
    -- Ensure distribution is set only for initial funding
<span class="fc" data-hits="5">    if not isFirstFunding then</span>
<span class="fc" data-hits="1">      return false, &quot;Cannot specify distribution after initial funding&quot;</span>
    end

    -- Ensure distribution includes all position IDs
<span class="fc" data-hits="4">    if #distribution ~= #positionIds then</span>
<span class="fc" data-hits="1">      return false, &quot;Distribution length mismatch&quot;</span>
    end

    -- Validate distribution content
<span class="fc" data-hits="3">    local distributionSum = 0</span>
<span class="fc" data-hits="10">    for i = 1, #distribution do</span>
<span class="fc" data-hits="8">      if type(distribution[i]) ~= &quot;number&quot; then</span>
<span class="fc" data-hits="1">        return false, &quot;Distribution item must be a number&quot;</span>
      end
<span class="fc" data-hits="7">      distributionSum = distributionSum + distribution[i]</span>
    end

    -- Ensure the distribution sum is greater than zero
<span class="fc" data-hits="2">    if distributionSum == 0 then</span>
<span class="fc" data-hits="1">      return false, &quot;Distribution sum must be greater than zero&quot;</span>
    end
  else
    -- Ensure distribution is provided for the first funding call
<span class="fc" data-hits="1">    if isFirstFunding then</span>
<span class="nc">      return false, &quot;Must specify distribution for initial funding&quot;</span>
    end
  end

<span class="fc" data-hits="2">  return true</span>
end

--- Validates remove funding
--- @param msg Message The message to be validated
--- @param balance string The balance of the sender&#39;s LP tokens
--- @return boolean, string|nil True if validation passes, otherwise false with an error message
<span class="fc" data-hits="1">function cpmmValidation.removeFunding(msg, balance)</span>
  -- Validate that Quantity is a positive integer
<span class="fc" data-hits="4">  local isValid, err = sharedValidation.validatePositiveInteger(msg.Tags.Quantity, &quot;Quantity&quot;)</span>
<span class="fc" data-hits="4">  if not isValid then</span>
<span class="fc" data-hits="2">    return false, err</span>
  end

  -- Ensure Quantity is within the sender&#39;s balance
<span class="fc" data-hits="2">  local quantity = bint(msg.Tags.Quantity)</span>
<span class="fc" data-hits="2">  local userBalance = bint(balance or &quot;0&quot;) -- Default to &quot;0&quot; if balance is nil</span>

<span class="fc" data-hits="2">  if quantity &gt; userBalance then</span>
<span class="fc" data-hits="1">    return false, &quot;Quantity must be less than or equal to balance!&quot;</span>
  end

<span class="fc" data-hits="1">  return true</span>
end

--- Validates buy
--- @param msg Message The message to be validated
--- @param cpmm CPMM The CPMM instance for calculations
--- @return boolean, string|nil True if validation passes, otherwise false with an error message
<span class="fc" data-hits="1">function cpmmValidation.buy(msg, cpmm)</span>
<span class="fc" data-hits="5">  local onBehalfOf = msg.Tags[&#39;X-OnBehalfOf&#39;] or msg.Tags.Sender</span>
<span class="fc" data-hits="5">  local positionIds = cpmm.tokens.positionIds</span>

<span class="fc" data-hits="5">  local success, err = sharedValidation.validateAddress(onBehalfOf, &#39;onBehalfOf&#39;)</span>
<span class="fc" data-hits="5">  if not success then return false, err end</span>

<span class="fc" data-hits="5">  success, err = sharedValidation.validateItem(msg.Tags[&#39;X-PositionId&#39;], positionIds, &quot;X-PositionId&quot;)</span>
<span class="fc" data-hits="5">  if not success then return false, err end</span>

<span class="fc" data-hits="3">  success, err = sharedValidation.validatePositiveInteger(msg.Tags.Quantity, &quot;Quantity&quot;)</span>
<span class="fc" data-hits="3">  if not success then return false, err end</span>

<span class="fc" data-hits="3">  success, err = sharedValidation.validatePositiveInteger(msg.Tags[&quot;X-MinPositionTokensToBuy&quot;], &quot;X-MinPositionTokensToBuy&quot;)</span>
<span class="fc" data-hits="3">  if not success then return false, err end</span>

  -- Calculate the actual buy amount
<span class="fc" data-hits="1">  local positionTokensToBuy = cpmm:calcBuyAmount(msg.Tags.Quantity, msg.Tags[&#39;X-PositionId&#39;])</span>

  -- Ensure minimum buy amount is met
<span class="fc" data-hits="1">  if bint(msg.Tags[&#39;X-MinPositionTokensToBuy&#39;]) &gt; bint(positionTokensToBuy) then</span>
<span class="nc">    return false, &#39;Minimum buy amount not reached&#39;</span>
  end

<span class="fc" data-hits="1">  return true</span>
end

--- Validates sell
--- @param msg Message The message to be validated
--- @param cpmm CPMM The CPMM instance for calculations
--- @return boolean, string|nil
<span class="fc" data-hits="1">function cpmmValidation.sell(msg, cpmm)</span>
<span class="fc" data-hits="7">  local onBehalfOf = msg.Tags[&#39;X-OnBehalfOf&#39;] or msg.From</span>
<span class="fc" data-hits="7">  local positionIds = cpmm.tokens.positionIds</span>

<span class="fc" data-hits="7">  local success, err = sharedValidation.validateAddress(onBehalfOf, &#39;onBehalfOf&#39;)</span>
<span class="fc" data-hits="7">  if not success then return false, err end</span>

<span class="fc" data-hits="7">  success, err = sharedValidation.validateItem(msg.Tags.PositionId, positionIds, &quot;PositionId&quot;)</span>
<span class="fc" data-hits="7">  if not success then return false, err end</span>

<span class="fc" data-hits="5">  success, err = sharedValidation.validatePositiveInteger(msg.Tags.MaxPositionTokensToSell, &quot;MaxPositionTokensToSell&quot;)</span>
<span class="fc" data-hits="5">  if not success then return false, err end</span>

<span class="fc" data-hits="3">  success, err = sharedValidation.validatePositiveInteger(msg.Tags.ReturnAmount, &quot;ReturnAmount&quot;)</span>
<span class="fc" data-hits="3">  if not success then return false, err end</span>

  -- Calculate the actual position tokens to sell
<span class="fc" data-hits="1">  local positionTokensToSell = cpmm:calcSellAmount(msg.Tags.ReturnAmount, msg.Tags.PositionId)</span>

 -- Ensure the sell amount does not exceed the maximum allowed
<span class="fc" data-hits="1"> if bint(positionTokensToSell) &gt; bint(msg.Tags.MaxPositionTokensToSell) then</span>
<span class="nc">  return false, &quot;Max position tokens to sell not sufficient!&quot;</span>
end

<span class="fc" data-hits="1">  return true</span>
end

--- Validates calc buy amount
--- @param msg Message The message to be validated
--- @param validPositionIds table&lt;string&gt; The array of valid position IDs
--- @return boolean, string|nil
<span class="fc" data-hits="1">function cpmmValidation.calcBuyAmount(msg, validPositionIds)</span>
<span class="fc" data-hits="5">  local success, err = sharedValidation.validateItem(msg.Tags.PositionId, validPositionIds, &quot;PositionId&quot;)</span>
<span class="fc" data-hits="5">  if not success then return false, err end</span>

<span class="fc" data-hits="3">  return sharedValidation.validatePositiveInteger(msg.Tags.InvestmentAmount, &quot;InvestmentAmount&quot;)</span>
end

--- Validates calc sell amount
--- @param msg Message The message to be validated
--- @param validPositionIds table&lt;string&gt; The array of valid position IDs
--- @return boolean, string|nil
<span class="fc" data-hits="1">function cpmmValidation.calcSellAmount(msg, validPositionIds)</span>
<span class="nc">  local success, err = sharedValidation.validateItem(msg.Tags.PositionId, validPositionIds, &quot;PositionId&quot;)</span>
<span class="nc">  if not success then return false, err end</span>

<span class="nc">  return sharedValidation.validatePositiveInteger(msg.Tags.ReturnAmount, &quot;ReturnAmount&quot;)</span>
end

--- Validates fees withdrawable
--- @param msg Message The message to be validated
--- @return boolean, string|nil
<span class="fc" data-hits="1">function cpmmValidation.feesWithdrawable(msg)</span>
<span class="nc">  if msg.Tags[&quot;Recipient&quot;] then</span>
<span class="nc">    return sharedValidation.validateAddress(msg.Tags[&#39;Recipient&#39;], &#39;Recipient&#39;)</span>
  end

<span class="nc">  return true</span>
end

--- Validates withdraw fees
--- @param msg Message The message to be validated
--- @return boolean, string|nil
<span class="fc" data-hits="1">function cpmmValidation.withdrawFees(msg)</span>
<span class="nc">  if msg.Tags[&quot;OnBehalfOf&quot;] then</span>
<span class="nc">    return sharedValidation.validateAddress(msg.Tags[&#39;OnBehalfOf&#39;], &#39;OnBehalfOf&#39;)</span>
  end

<span class="nc">  return true</span>
end

--- Validates update configurator
--- @param msg Message The message to be validated
--- @param configurator string The configurator address
--- @return boolean, string|nil
<span class="fc" data-hits="1">function cpmmValidation.updateConfigurator(msg, configurator)</span>
<span class="nc">  if msg.From ~= configurator then</span>
<span class="nc">    return false, &#39;Sender must be configurator!&#39;</span>
  end

<span class="nc">  return sharedValidation.validateAddress(msg.Tags.Configurator, &#39;Configurator&#39;)</span>
end

--- Validates update take fee
--- @param msg Message The message to be validated
--- @param configurator string The configurator address
--- @return boolean, string|nil
<span class="fc" data-hits="1">function cpmmValidation.updateTakeFee(msg, configurator)</span>
<span class="nc">  if msg.From ~= configurator then</span>
<span class="nc">    return false, &#39;Sender must be configurator!&#39;</span>
  end

<span class="nc">  local success, err = sharedValidation.validatePositiveIntegerOrZero(msg.Tags.CreatorFee, &#39;CreatorFee&#39;)</span>
<span class="nc">  if not success then return false, err end</span>

<span class="nc">  success, err = sharedValidation.validatePositiveIntegerOrZero(msg.Tags.ProtocolFee, &#39;ProtocolFee&#39;)</span>
<span class="nc">  if not success then return false, err end</span>

<span class="nc">  local totalFee = bint.__add(bint(msg.Tags.CreatorFee), bint(msg.Tags.ProtocolFee))</span>
<span class="nc">  if not bint.__lt(totalFee, 1000) then</span>
<span class="nc">    return false, &#39;Net fee must be less than or equal to 1000 bps&#39;</span>
  end

<span class="nc">  return true</span>
end

--- Validates update protocol fee target
--- @param msg Message The message to be validated
--- @param configurator string The configurator address
--- @return boolean, string|nil
<span class="fc" data-hits="1">function cpmmValidation.updateProtocolFeeTarget(msg, configurator)</span>
<span class="nc">  if msg.From ~= configurator then</span>
<span class="nc">    return false, &#39;Sender must be configurator!&#39;</span>
  end

<span class="nc">  if not msg.Tags.ProtocolFeeTarget then</span>
<span class="nc">    return false, &#39;ProtocolFeeTarget is required!&#39;</span>
  end

<span class="nc">  return true</span>
end

--- Validates update logo
--- @param msg Message The message to be validated
--- @param configurator string The configurator address
--- @return boolean, string|nil
<span class="fc" data-hits="1">function cpmmValidation.updateLogo(msg, configurator)</span>
<span class="nc">  if msg.From ~= configurator then</span>
<span class="nc">    return false, &#39;Sender must be configurator!&#39;</span>
  end

<span class="nc">  if not msg.Tags.Logo then</span>
<span class="nc">    return false, &#39;Logo is required!&#39;</span>
  end

<span class="nc">  return true</span>
end

<span class="fc" data-hits="1">return cpmmValidation</span>
</pre>
      </div>

      <div class="hidden file danger" id="src-marketmodules-market">
         <h2 class="title">
            src/marketModules/market.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 39.61%"></span>
                  <span><strong>39.61%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>61</strong> Hits</span>
               <span class="miss"><strong>93</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums">--[[
======================================================================================
Outcome © 2025. All Rights Reserved.
======================================================================================
This code is proprietary and owned by Outcome.

You are permitted to build applications, integrations, and extensions that interact
with the Outcome Protocol, provided such usage adheres to the official Outcome
terms of service and does not result in unauthorized forks or clones of this codebase.

Redistribution, modification, or unauthorized use of this code is strictly prohibited
without explicit written permission from Outcome.
======================================================================================
]]

<span class="fc" data-hits="1">local Market = {}</span>
<span class="fc" data-hits="1">local MarketMethods = {}</span>
<span class="fc" data-hits="1">local MarketNotices = require(&#39;marketModules.marketNotices&#39;)</span>
<span class="fc" data-hits="1">local json = require(&#39;json&#39;)</span>
<span class="fc" data-hits="1">local bint = require(&#39;.bint&#39;)(256)</span>
<span class="fc" data-hits="1">local cpmm = require(&#39;marketModules.cpmm&#39;)</span>

--- Represents a Market
--- @class Market
--- @field cpmm CPMM The Constant Product Market Maker

--- Creates a new Market instance
--- @param configurator string The process ID of the configurator
--- @param dataIndex string The process ID of the data index process
--- @param collateralToken string The process ID of the collateral token
--- @param resolutionAgent string The process ID of the resolution agent
--- @param creator string The address of the market creator
--- @param question string The market question
--- @param rules string The market rules
--- @param category string The market category
--- @param subcategory string The market subcategory
--- @param positionIds table&lt;string, ...&gt; The position IDs
--- @param name string The CPMM token(s) name
--- @param ticker string The CPMM token(s) ticker
--- @param logo string The CPMM token(s) logo
--- @param lpFee number The liquidity provider fee
--- @param creatorFee number The market creator fee
--- @param creatorFeeTarget string The market creator fee target
--- @param protocolFee number The protocol fee
--- @param protocolFeeTarget string The protocol fee target
--- @return Market market The new Market instance
<span class="fc" data-hits="1">function Market.new(</span>
  configurator,
  dataIndex,
  collateralToken,
  resolutionAgent,
  creator,
  question,
  rules,
  category,
  subcategory,
  positionIds,
  name,
  ticker,
  logo,
  lpFee,
  creatorFee,
  creatorFeeTarget,
  protocolFee,
  protocolFeeTarget
)
<span class="fc" data-hits="6">  local market = {</span>
<span class="fc" data-hits="12">    cpmm = cpmm.new(</span>
<span class="fc" data-hits="6">      configurator,</span>
<span class="fc" data-hits="6">      collateralToken,</span>
<span class="fc" data-hits="6">      resolutionAgent,</span>
<span class="fc" data-hits="6">      positionIds,</span>
<span class="fc" data-hits="6">      name,</span>
<span class="fc" data-hits="6">      ticker,</span>
<span class="fc" data-hits="6">      logo,</span>
<span class="fc" data-hits="6">      lpFee,</span>
<span class="fc" data-hits="6">      creatorFee,</span>
<span class="fc" data-hits="6">      creatorFeeTarget,</span>
<span class="fc" data-hits="6">      protocolFee,</span>
      protocolFeeTarget
<span class="fc" data-hits="12">    ),</span>
<span class="fc" data-hits="6">    question = question,</span>
<span class="fc" data-hits="6">    rules = rules,</span>
<span class="fc" data-hits="6">    category = category,</span>
<span class="fc" data-hits="6">    subcategory = subcategory,</span>
<span class="fc" data-hits="6">    creator = creator,</span>
<span class="fc" data-hits="6">    dataIndex = dataIndex</span>
  }
<span class="fc" data-hits="12">  setmetatable(market, {</span>
    __index = function(_, k)
<span class="nc">      if MarketMethods[k] then</span>
<span class="nc">        return MarketMethods[k]</span>
<span class="nc">      elseif MarketNotices[k] then</span>
<span class="nc">        return MarketNotices[k]</span>
      else
<span class="nc">        return nil</span>
      end
    end
  })
<span class="fc" data-hits="6">  return market</span>
end

--- Info
--- @param msg Message The message received
--- @return Message The info message
<span class="fc" data-hits="1">function MarketMethods:info(msg)</span>
<span class="nc">  return msg.reply({</span>
    Name = self.cpmm.token.name,
    Ticker = self.cpmm.token.ticker,
    Logo = self.cpmm.token.logo,
    Denomination = tostring(self.cpmm.token.denomination),
    PositionIds = json.encode(self.cpmm.tokens.positionIds),
    CollateralToken = self.cpmm.tokens.collateralToken,
    Configurator = self.cpmm.configurator,
    DataIndex = self.dataIndex,
    ResolutionAgent = self.cpmm.tokens.resolutionAgent,
    Question = self.question,
    Rules = self.rules,
    Category = self.category,
    Subcategory = self.subcategory,
    Creator = self.creator,
    LpFee = tostring(self.cpmm.lpFee),
    LpFeePoolWeight = self.cpmm.feePoolWeight,
    LpFeeTotalWithdrawn = self.cpmm.totalWithdrawnFees,
    CreatorFee = tostring(self.cpmm.tokens.creatorFee),
    CreatorFeeTarget = self.cpmm.tokens.creatorFeeTarget,
    ProtocolFee = tostring(self.cpmm.tokens.protocolFee),
    ProtocolFeeTarget = self.cpmm.tokens.protocolFeeTarget,
<span class="nc">    Owner = Owner</span>
  })
end

--[[
=============
ACTIVITY LOGS
=============
]]

local function logFunding(dataIndex, user, onBehalfOf, operation, collateral, quantity, msg)
<span class="nc">  return msg.forward(dataIndex, {</span>
    Action = &quot;Log-Funding&quot;,
    User = user,
    OnBehalfOf = onBehalfOf,
    Operation = operation,
    Collateral = collateral,
    Quantity = quantity,
  })
end

local function logPrediction(dataIndex, user, onBehalfOf, operation, collateral, quantity, outcome, shares, price, msg)
<span class="nc">  return msg.forward(dataIndex, {</span>
    Action = &quot;Log-Prediction&quot;,
    User = user,
    OnBehalfOf = onBehalfOf,
    Operation = operation,
    Collateral = collateral,
    Quantity = quantity,
    Outcome = outcome,
    Shares = shares,
<span class="nc">    Price = price</span>
  })
end

local function logProbabilities(dataIndex, probabilities, msg)
<span class="nc">  return msg.forward(dataIndex, {</span>
    Action = &quot;Log-Probabilities&quot;,
<span class="nc">    Probabilities = json.encode(probabilities)</span>
  })
end

--[[
==================
CPMM WRITE METHODS
==================
]]

--- Add funding
--- Message forwarded from the collateral token
--- @param msg Message The message received
<span class="fc" data-hits="1">function MarketMethods:addFunding(msg)</span>
<span class="nc">  local distribution = msg.Tags[&#39;X-Distribution&#39;] and json.decode(msg.Tags[&#39;X-Distribution&#39;]) or nil</span>
<span class="nc">  local onBehalfOf = msg.Tags[&#39;X-OnBehalfOf&#39;] or msg.Tags.Sender</span>
  -- Add funding to the CPMM
<span class="nc">  self.cpmm:addFunding(onBehalfOf, msg.Tags.Quantity, distribution, msg)</span>
  -- Log funding update to data index
<span class="nc">  logFunding(self.dataIndex, msg.Tags.Sender, onBehalfOf, &#39;add&#39;, self.cpmm.tokens.collateralToken, msg.Tags.Quantity, msg)</span>
end

--- Remove funding
--- Message forwarded from the LP token
--- @param msg Message The message received
<span class="fc" data-hits="1">function MarketMethods:removeFunding(msg)</span>
<span class="nc">  local onBehalfOf = msg.Tags[&#39;OnBehalfOf&#39;] or msg.From</span>
  -- Remove funding from the CPMM
<span class="nc">  self.cpmm:removeFunding(onBehalfOf, msg.Tags.Quantity, msg)</span>
  -- Log funding update to data index
<span class="nc">  logFunding(self.dataIndex, msg.From, onBehalfOf, &#39;remove&#39;, self.cpmm.tokens.collateralToken, msg.Tags.Quantity, msg)</span>
end

--- Buy
--- Message forwarded from the collateral token
--- @param msg Message The message received
<span class="fc" data-hits="1">function MarketMethods:buy(msg)</span>
<span class="nc">  local positionTokensToBuy = self.cpmm:calcBuyAmount(msg.Tags.Quantity, msg.Tags[&#39;X-PositionId&#39;])</span>
<span class="nc">  local onBehalfOf = msg.Tags[&#39;X-OnBehalfOf&#39;] or msg.Tags.Sender</span>
  -- Buy position tokens from the CPMM
<span class="nc">  self.cpmm:buy(msg.Tags.Sender, onBehalfOf, msg.Tags.Quantity, msg.Tags[&#39;X-PositionId&#39;], tonumber(msg.Tags[&#39;X-MinPositionTokensToBuy&#39;]), msg)</span>
  -- Log prediction and probability update to data index
<span class="nc">  local price = tostring(bint.__div(bint(positionTokensToBuy), bint(msg.Tags.Quantity)))</span>
<span class="nc">  logPrediction(self.dataIndex, msg.Tags.Sender, onBehalfOf, &quot;buy&quot;, self.cpmm.tokens.collateralToken, msg.Tags.Quantity, msg.Tags[&#39;X-PositionId&#39;], positionTokensToBuy, price, msg)</span>
<span class="nc">  logProbabilities(self.dataIndex, self.cpmm:calcProbabilities(), msg)</span>
end

--- Sell
--- @param msg Message The message received
<span class="fc" data-hits="1">function MarketMethods:sell(msg)</span>
<span class="nc">  local positionTokensToSell = self.cpmm:calcSellAmount(msg.Tags.ReturnAmount, msg.Tags.PositionId)</span>
<span class="nc">  local onBehalfOf = msg.Tags[&#39;OnBehalfOf&#39;] or msg.From</span>
  -- Sell position tokens to the CPMM
<span class="nc">  self.cpmm:sell(msg.From, onBehalfOf, msg.Tags.ReturnAmount, msg.Tags.PositionId, msg.Tags.MaxPositionTokensToSell, msg)</span>
  -- Log prediction and probability update to data index
<span class="nc">  local price = tostring(bint.__div(positionTokensToSell, bint(msg.Tags.ReturnAmount)))</span>
<span class="nc">  logPrediction(self.dataIndex, msg.From, onBehalfOf, &quot;sell&quot;, self.cpmm.tokens.collateralToken, msg.Tags.ReturnAmount, msg.Tags.PositionId, positionTokensToSell, price, msg)</span>
<span class="nc">  logProbabilities(self.dataIndex, self.cpmm:calcProbabilities(), msg)</span>
end

--- Withdraw fees
--- @param msg Message The message received
<span class="fc" data-hits="1">function MarketMethods:withdrawFees(msg)</span>
<span class="nc">  local onBehalfOf = msg.Tags[&#39;OnBehalfOf&#39;] or msg.From</span>
<span class="nc">  self.cpmm:withdrawFees(msg.From, onBehalfOf, msg, true)</span>
end

--[[
=================
CPMM READ METHODS
=================
]]

--- Calc buy amount
--- @param msg Message The message received
--- @return Message calcBuyAmountNotice The calc buy amount notice
<span class="fc" data-hits="1">function MarketMethods:calcBuyAmount(msg)</span>
<span class="nc">  local buyAmount = self.cpmm:calcBuyAmount(msg.Tags.InvestmentAmount, msg.Tags.PositionId)</span>
<span class="nc">  return msg.reply({</span>
    BuyAmount = buyAmount,
    PositionId =  msg.Tags.PositionId,
    InvestmentAmount = msg.Tags.InvestmentAmount,
<span class="nc">    Data = buyAmount</span>
  })
end

--- Calc sell amount
--- @param msg Message The message received
--- @return Message calcSellAmountNotice The calc sell amount notice
<span class="fc" data-hits="1">function MarketMethods:calcSellAmount(msg)</span>
<span class="nc">  local sellAmount = self.cpmm:calcSellAmount(msg.Tags.ReturnAmount, msg.Tags.PositionId)</span>
<span class="nc">  return msg.reply({</span>
    SellAmount = sellAmount,
    PositionId = msg.Tags.PositionId,
    ReturnAmount = msg.Tags.ReturnAmount,
<span class="nc">    Data = sellAmount</span>
  })
end

--- Colleced fees
--- @return Message collectedFees The total unwithdrawn fees collected by the CPMM
<span class="fc" data-hits="1">function MarketMethods:collectedFees(msg)</span>
<span class="nc">  local fees = self.cpmm:collectedFees()</span>
<span class="nc">  return msg.reply({</span>
    CollectedFees = fees,
<span class="nc">    Data = fees</span>
  })
end

--- Fees withdrawable
--- @param msg Message The message received
--- @return Message feesWithdrawable The fees withdrawable by the account
<span class="fc" data-hits="1">function MarketMethods:feesWithdrawable(msg)</span>
<span class="nc">  local account = msg.Tags[&quot;Recipient&quot;] or msg.From</span>
<span class="nc">  local fees = self.cpmm:feesWithdrawableBy(account)</span>
<span class="nc">  return msg.reply({</span>
    FeesWithdrawable = fees,
    Account = account,
<span class="nc">    Data = fees</span>
  })
end

--[[
======================
LP TOKEN WRITE METHODS
======================
]]

--- Transfer
--- @param msg Message The message received
<span class="fc" data-hits="1">function MarketMethods:transfer(msg)</span>
<span class="nc">  self.cpmm:transfer(msg.From, msg.Tags.Recipient, msg.Tags.Quantity, msg.Tags.Cast, msg)</span>
end

--[[
=====================
LP TOKEN READ METHODS
=====================
]]

--- Balance
--- @param msg Message The message received
--- @return Message balance The balance of the account
<span class="fc" data-hits="1">function MarketMethods:balance(msg)</span>
<span class="nc">  local bal = &#39;0&#39;</span>

  -- If not Recipient is provided, then return the Senders balance
<span class="nc">  if (msg.Tags.Recipient) then</span>
<span class="nc">    if (self.cpmm.token.balances[msg.Tags.Recipient]) then</span>
<span class="nc">      bal = self.cpmm.token.balances[msg.Tags.Recipient]</span>
    end
<span class="nc">  elseif msg.Tags.Target and self.cpmm.token.balances[msg.Tags.Target] then</span>
<span class="nc">    bal = self.cpmm.token.balances[msg.Tags.Target]</span>
<span class="nc">  elseif self.cpmm.token.balances[msg.From] then</span>
<span class="nc">    bal = self.cpmm.token.balances[msg.From]</span>
  end

<span class="nc">  return msg.reply({</span>
    Balance = bal,
    Ticker = self.cpmm.token.ticker,
    Account = msg.Tags.Recipient or msg.From,
<span class="nc">    Data = bal</span>
  })
end

--- Balances
--- @param msg Message The message received
--- @return Message balances The balances of all accounts
<span class="fc" data-hits="1">function MarketMethods:balances(msg)</span>
<span class="nc">  return msg.reply({ Data = json.encode(self.cpmm.token.balances) })</span>
end

--- Total supply
--- @param msg Message The message received
--- @return Message totalSupply The total supply of the LP token
<span class="fc" data-hits="1">function MarketMethods:totalSupply(msg)</span>
<span class="nc">  return msg.reply({ Data = json.encode(self.cpmm.token.totalSupply) })</span>
end

--[[
================================
CONDITIONAL TOKENS WRITE METHODS
================================
]]

--- Merge positions
--- @param msg Message The message received
<span class="fc" data-hits="1">function MarketMethods:mergePositions(msg)</span>
<span class="nc">  local onBehalfOf = msg.Tags[&quot;OnBehalfOf&quot;] or msg.From</span>
<span class="nc">  self.cpmm.tokens:mergePositions(msg.From, onBehalfOf, msg.Tags.Quantity, false, msg, true)</span>
end

--- Report payouts
--- @param msg Message The message received
<span class="fc" data-hits="1">function MarketMethods:reportPayouts(msg)</span>
<span class="nc">  local payouts = json.decode(msg.Tags.Payouts)</span>
<span class="nc">  self.cpmm.tokens:reportPayouts(payouts, msg)</span>
end

--- Redeem positions
--- @param msg Message The message received
<span class="fc" data-hits="1">function MarketMethods:redeemPositions(msg)</span>
<span class="nc">  local onBehalfOf = msg.Tags[&quot;OnBehalfOf&quot;] or msg.From</span>
<span class="nc">  self.cpmm.tokens:redeemPositions(onBehalfOf, msg)</span>
end

--[[
===============================
CONDITIONAL TOKENS READ METHODS
===============================
]]

--- Get payout numerators
--- @param msg Message The message received
--- @return Message payoutNumerators payout numerators for the condition
<span class="fc" data-hits="1">function MarketMethods:getPayoutNumerators(msg)</span>
<span class="nc">  return msg.reply({ Data = json.encode(self.cpmm.tokens.payoutNumerators) })</span>
end

--- Get payout denominator
--- @param msg Message The message received
--- @return Message payoutDenominator The payout denominator for the condition
<span class="fc" data-hits="1">function MarketMethods:getPayoutDenominator(msg)</span>
<span class="nc">  return msg.reply({ Data = tostring(self.cpmm.tokens.payoutDenominator) })</span>
end

--[[
==================================
SEMI-FUNGIBLE TOKENS WRITE METHODS
==================================
]]

--- Transfer single
--- @param msg Message The message received
<span class="fc" data-hits="1">function MarketMethods:transferSingle(msg)</span>
<span class="nc">  self.cpmm.tokens:transferSingle(msg.From, msg.Tags.Recipient, msg.Tags.PositionId, msg.Tags.Quantity, msg.Tags.Cast, msg, true)</span>
end

--- Transfer batch
--- @param msg Message The message received
--- @return table&lt;Message&gt;|Message|nil transferBatchNotices The transfer notices, error notice or nothing
<span class="fc" data-hits="1">function MarketMethods:transferBatch(msg)</span>
<span class="nc">  local positionIds = json.decode(msg.Tags.PositionIds)</span>
<span class="nc">  local quantities = json.decode(msg.Tags.Quantities)</span>
<span class="nc">  return self.cpmm.tokens:transferBatch(msg.From, msg.Tags.Recipient, positionIds, quantities, msg.Tags.Cast, msg, true)</span>
end

--[[
=================================
SEMI-FUNGIBLE TOKENS READ METHODS
=================================
]]

--- Balance by ID
--- @param msg Message The message received
--- @return Message balanceById The balance of the account filtered by ID
<span class="fc" data-hits="1">function MarketMethods:balanceById(msg)</span>
<span class="nc">  local account = msg.Tags.Recipient or msg.From</span>
<span class="nc">  local bal = self.cpmm.tokens:getBalance(msg.From, account, msg.Tags.PositionId)</span>
<span class="nc">  return msg.reply({</span>
    Balance = bal,
    PositionId = msg.Tags.PositionId,
    Account = account,
<span class="nc">    Data = bal</span>
  })
end

--- Balances by ID
--- @param msg Message The message received
--- @return Message balancesById The balances of all accounts filtered by ID
<span class="fc" data-hits="1">function MarketMethods:balancesById(msg)</span>
<span class="nc">  local bals = self.cpmm.tokens:getBalances(msg.Tags.PositionId)</span>
<span class="nc">  return msg.reply({</span>
    PositionId = msg.Tags.PositionId,
<span class="nc">    Data = json.encode(bals)</span>
  })
end

--- Batch balance
--- @param msg Message The message received
--- @return Message batchBalance The balance accounts filtered by IDs
<span class="fc" data-hits="1">function MarketMethods:batchBalance(msg)</span>
<span class="nc">  local recipients = json.decode(msg.Tags.Recipients)</span>
<span class="nc">  local positionIds = json.decode(msg.Tags.PositionIds)</span>
<span class="nc">  local bals = self.cpmm.tokens:getBatchBalance(recipients, positionIds)</span>
<span class="nc">  return msg.reply({</span>
    PositionIds = msg.Tags.PositionIds,
    Accounts = msg.Tags.Recipients,
<span class="nc">    Data = json.encode(bals)</span>
  })
end

--- Batch balances
--- @param msg Message The message received
--- @return Message batchBalances The balances of all accounts filtered by IDs
<span class="fc" data-hits="1">function MarketMethods:batchBalances(msg)</span>
<span class="nc">  local positionIds = json.decode(msg.Tags.PositionIds)</span>
<span class="nc">  local bals = self.cpmm.tokens:getBatchBalances(positionIds)</span>
<span class="nc">  return msg.reply({ Data = json.encode(bals) })</span>
end

--- Balances all
--- @param msg Message The message received
--- @return Message balances The balances of all accounts
<span class="fc" data-hits="1">function MarketMethods:balancesAll(msg)</span>
<span class="nc">  return msg.reply({ Data = json.encode(self.cpmm.tokens.balancesById) })</span>
end

--[[
==========================
CONFIGURATOR WRITE METHODS
==========================
]]

--- Update configurator
--- @param msg Message The message received
--- @return Message updateConfiguratorNotice The update configurator notice
<span class="fc" data-hits="1">function MarketMethods:updateConfigurator(msg)</span>
<span class="nc">  return self.cpmm:updateConfigurator(msg.Tags.Configurator, msg)</span>
end

--- Update data index
--- @param msg Message The message received
--- @return Message updateDataIndexNotice The update data index notice
<span class="fc" data-hits="1">function MarketMethods:updateDataIndex(msg)</span>
<span class="nc">  self.dataIndex = msg.Tags.DataIndex</span>
<span class="nc">  return self.updateDataIndexNotice(msg.Tags.DataIndex, msg)</span>
end

--- Update take fee
--- @param msg Message The message received
--- @return Message updateTakeFeeNotice The update take fee notice
<span class="fc" data-hits="1">function MarketMethods:updateTakeFee(msg)</span>
<span class="nc">  return self.cpmm:updateTakeFee(tonumber(msg.Tags.CreatorFee), tonumber(msg.Tags.ProtocolFee), msg)</span>
end

--- Update protocol fee target
--- @param msg Message The message received
--- @return Message
<span class="fc" data-hits="1">function MarketMethods:updateProtocolFeeTarget(msg)</span>
<span class="nc">  return self.cpmm:updateProtocolFeeTarget(msg.Tags.ProtocolFeeTarget, msg)</span>
end

--- Update logo
--- @param msg Message The message received
--- @return Message updateLogoNotice The update logo notice
<span class="fc" data-hits="1">function MarketMethods:updateLogo(msg)</span>
<span class="nc">  return self.cpmm:updateLogo(msg.Tags.Logo, msg)</span>
end

<span class="fc" data-hits="1">return Market</span>
</pre>
      </div>

      <div class="hidden file success-low" id="src-marketmodules-marketnotices">
         <h2 class="title">
            src/marketModules/marketNotices.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 60.00%"></span>
                  <span><strong>60.00%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>3</strong> Hits</span>
               <span class="miss"><strong>2</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums">--[[
=========================================================
Part of the Outcome codebase © 2025. All Rights Reserved.
See market.lua for full license details.
=========================================================
]]

<span class="fc" data-hits="1">local MarketNotices = {}</span>

--- Sends a update data index notice
--- @param dataIndex string The updated data index
--- @param msg Message The message received
--- @return Message The data index updated notice
<span class="fc" data-hits="1">function MarketNotices.updateDataIndexNotice(dataIndex, msg)</span>
<span class="nc">  return msg.reply({</span>
    Action = &quot;Update-Data-Index-Notice&quot;,
<span class="nc">    Data = dataIndex</span>
  })
end

<span class="fc" data-hits="1">return MarketNotices</span>
</pre>
      </div>

      <div class="hidden file success-high" id="src-marketmodules-semifungibletokens">
         <h2 class="title">
            src/marketModules/semiFungibleTokens.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 99.15%"></span>
                  <span><strong>99.15%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>116</strong> Hits</span>
               <span class="miss"><strong>1</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums">--[[
==============================================================================
Outcome © 2025. MIT License.
Module: semiFungibleTokens.lua
==============================================================================
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and&#47;or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
==============================================================================
]]

<span class="fc" data-hits="4">local SemiFungibleTokens = {}</span>
<span class="fc" data-hits="4">local SemiFungibleTokensMethods = {}</span>
<span class="fc" data-hits="4">local SemiFungibleTokensNotices = require(&#39;marketModules.semiFungibleTokensNotices&#39;)</span>
<span class="fc" data-hits="4">local bint = require(&#39;.bint&#39;)(256)</span>

-- Represents SemiFungibleTokens
--- @class SemiFungibleTokens
--- @field name string The token name
--- @field ticker string The token ticker
--- @field logo string The token logo Arweave TxID
--- @field balancesById table&lt;string, table&lt;string, string&gt;&gt; The account token balances by ID
--- @field totalSupplyById table&lt;string, string&gt; The total supply of the token by ID
--- @field denomination number The number of decimals

--- Creates a new SemiFungibleTokens instance
--- @param name string The token name
--- @param ticker string The token ticker
--- @param logo string The token logo Arweave TxID
--- @param balancesById table&lt;string, table&lt;string, string&gt;&gt; The account token balances by ID
--- @param totalSupplyById table&lt;string, string&gt; The total supply of the token by ID
--- @param denomination number The number of decimals
--- @return SemiFungibleTokens semiFungibleTokens The new SemiFungibleTokens instance
<span class="fc" data-hits="4">function SemiFungibleTokens.new(name, ticker, logo, balancesById, totalSupplyById, denomination)</span>
<span class="fc" data-hits="45">  local semiFungibleTokens = {</span>
<span class="fc" data-hits="45">    name = name,</span>
<span class="fc" data-hits="45">    ticker = ticker,</span>
<span class="fc" data-hits="45">    logo = logo,</span>
<span class="fc" data-hits="45">    balancesById = balancesById,</span>
<span class="fc" data-hits="45">    totalSupplyById = totalSupplyById,</span>
<span class="fc" data-hits="45">    denomination = denomination</span>
  }
<span class="fc" data-hits="90">  setmetatable(semiFungibleTokens, {</span>
    __index = function(_, k)
<span class="fc" data-hits="114">      if SemiFungibleTokensMethods[k] then</span>
<span class="fc" data-hits="69">        return SemiFungibleTokensMethods[k]</span>
<span class="fc" data-hits="45">      elseif SemiFungibleTokensNotices[k] then</span>
<span class="fc" data-hits="45">        return SemiFungibleTokensNotices[k]</span>
      else
<span class="nc">        return nil</span>
      end
    end
  })
<span class="fc" data-hits="45">  return semiFungibleTokens</span>
end

--- Mint a quantity of tokens with the given ID
--- @param to string The address that will own the minted tokens
--- @param id string The ID of the tokens to mint
--- @param quantity string The quantity of tokens to mint
--- @param msg Message The message received
--- @return Message The mint notice
<span class="fc" data-hits="4">function SemiFungibleTokensMethods:mint(to, id, quantity, msg)</span>
<span class="fc" data-hits="6">  assert(quantity, &#39;Quantity is required!&#39;)</span>
<span class="fc" data-hits="6">  assert(bint.__lt(0, bint(quantity)), &#39;Quantity must be greater than zero!&#39;)</span>
  -- mint tokens
<span class="fc" data-hits="6">  if not self.balancesById[id] then self.balancesById[id] = {} end</span>
<span class="fc" data-hits="6">  if not self.balancesById[id][to] then self.balancesById[id][to] = &quot;0&quot; end</span>
<span class="fc" data-hits="6">  if not self.totalSupplyById[id] then self.totalSupplyById[id] = &quot;0&quot; end</span>
<span class="fc" data-hits="6">  self.balancesById[id][to] = tostring(bint.__add(self.balancesById[id][to], bint(quantity)))</span>
<span class="fc" data-hits="6">  self.totalSupplyById[id] = tostring(bint.__add(self.totalSupplyById[id], bint(quantity)))</span>
  -- send notice
<span class="fc" data-hits="6">  return self.mintSingleNotice(to, id, quantity, msg)</span>
end

--- Batch mint quantities of tokens with the given IDs
--- @param to string The address that will own the minted tokens
--- @param ids table&lt;string&gt; The IDs of the tokens to mint
--- @param quantities table&lt;string&gt; The quantities of tokens to mint
--- @param msg Message The message received
--- @return Message The batch mint notice
<span class="fc" data-hits="4">function SemiFungibleTokensMethods:batchMint(to, ids, quantities, msg)</span>
<span class="fc" data-hits="27">  assert(#ids == #quantities, &#39;Ids and quantities must have the same lengths&#39;)</span>
  -- mint tokens
<span class="fc" data-hits="93">  for i = 1, #ids do</span>
    -- @dev spacing to resolve text to code eval issue
<span class="fc" data-hits="68">    if not self.balancesById[ ids[i] ] then self.balancesById[ ids[i] ] = {} end</span>
<span class="fc" data-hits="68">    if not self.balancesById[ ids[i] ][to] then self.balancesById[ ids[i] ][to] = &quot;0&quot; end</span>
<span class="fc" data-hits="68">    if not self.totalSupplyById[ ids[i] ] then self.totalSupplyById[ ids[i] ] = &quot;0&quot; end</span>
<span class="fc" data-hits="68">    self.balancesById[ ids[i] ][to] = tostring(bint.__add(self.balancesById[ ids[i] ][to], quantities[i]))</span>
<span class="fc" data-hits="67">    self.totalSupplyById[ ids[i] ] = tostring(bint.__add(self.totalSupplyById[ ids[i] ], quantities[i]))</span>
  end
  -- send notice
<span class="fc" data-hits="25">  return self.mintBatchNotice(to, ids, quantities, msg)</span>
end

--- Burn a quantity of tokens with a given ID
--- @param from string The process ID that will no longer own the burned tokens
--- @param id string The ID of the tokens to burn
--- @param quantity string The quantity of tokens to burn
--- @param msg Message The message received
--- @param useReply boolean Whether to use `msg.reply` or `ao.send`
--- @return Message The burn notice
<span class="fc" data-hits="4">function SemiFungibleTokensMethods:burn(from, id, quantity, msg, useReply)</span>
<span class="fc" data-hits="4">  assert(bint.__lt(0, bint(quantity)), &#39;Quantity must be greater than zero!&#39;)</span>
<span class="fc" data-hits="4">  assert(self.balancesById[id], &#39;Id must exist! &#39; .. id)</span>
<span class="fc" data-hits="4">  assert(self.balancesById[id][from], &#39;Account must hold token! :: &#39; .. id)</span>
<span class="fc" data-hits="4">  assert(bint.__le(bint(quantity), self.balancesById[id][from]), &#39;Account must have sufficient tokens! &#39; .. id)</span>
  -- burn tokens
<span class="fc" data-hits="4">  self.balancesById[id][from] = tostring(bint.__sub(self.balancesById[id][from], bint(quantity)))</span>
<span class="fc" data-hits="4">  self.totalSupplyById[id] = tostring(bint.__sub(self.totalSupplyById[id], bint(quantity)))</span>
  -- send notice
<span class="fc" data-hits="4">  return self.burnSingleNotice(from, id, quantity, msg, useReply)</span>
end

--- Batch burn a quantity of tokens with the given IDs
--- @param from string The process ID that will no longer own the burned tokens
--- @param ids table&lt;string&gt; The IDs of the tokens to burn
--- @param quantities table&lt;string&gt; The quantities of tokens to burn
--- @param msg Message The message received
--- @param useReply boolean Whether to use `msg.reply` or `ao.send`
--- @return Message The batch burn notice
<span class="fc" data-hits="4">function SemiFungibleTokensMethods:batchBurn(from, ids, quantities, msg, useReply)</span>
<span class="fc" data-hits="5">  assert(#ids == #quantities, &#39;Ids and quantities must have the same lengths&#39;)</span>
<span class="fc" data-hits="14">  for i = 1, #ids do</span>
<span class="fc" data-hits="11">    assert(bint.__lt(0, quantities[i]), &#39;Quantity must be greater than zero!&#39;)</span>
<span class="fc" data-hits="11">    assert(self.balancesById[ ids[i] ], &#39;Id must exist! &#39; .. ids[i])</span>
<span class="fc" data-hits="10">    assert(self.balancesById[ ids[i] ][from], &#39;Account must hold token! &#39; .. ids[i])</span>
<span class="fc" data-hits="9">    assert(bint.__le(quantities[i], self.balancesById[ ids[i] ][from]), &#39;Account must have sufficient tokens!&#39;)</span>
  end
  -- burn tokens
<span class="fc" data-hits="3">  local remainingBalances = {}</span>
<span class="fc" data-hits="12">  for i = 1, #ids do</span>
<span class="fc" data-hits="9">    self.balancesById[ ids[i] ][from] = tostring(bint.__sub(self.balancesById[ ids[i] ][from], quantities[i]))</span>
<span class="fc" data-hits="9">    self.totalSupplyById[ ids[i] ] = tostring(bint.__sub(self.totalSupplyById[ ids[i] ], quantities[i]))</span>
<span class="fc" data-hits="9">    remainingBalances[i] = self.balancesById[ ids[i] ][from]</span>
  end
  -- send notice
<span class="fc" data-hits="3">  return self.burnBatchNotice(from, ids, quantities, remainingBalances, msg, useReply)</span>
end

--- Transfer a quantity of tokens with the given ID
--- @param from string The process ID that will send the token
--- @param recipient string The process ID that will receive the token
--- @param id string The ID of the tokens to transfer
--- @param quantity string The quantity of tokens to transfer
--- @param cast boolean The cast is set to true to silence the transfer notice
--- @param useReply boolean Whether to use `msg.reply` or `ao.send`
--- @param msg Message The message received
--- @return table&lt;Message&gt;|Message|nil The transfer notices, error notice or nothing
<span class="fc" data-hits="4">function SemiFungibleTokensMethods:transferSingle(from, recipient, id, quantity, cast, msg, useReply)</span>
<span class="fc" data-hits="3">  if not self.balancesById[id] then self.balancesById[id] = {} end</span>
<span class="fc" data-hits="3">  if not self.balancesById[id][from] then self.balancesById[id][from] = &quot;0&quot; end</span>
<span class="fc" data-hits="3">  if not self.balancesById[id][recipient] then self.balancesById[id][recipient] = &quot;0&quot; end</span>

<span class="fc" data-hits="3">  local qty = bint(quantity)</span>
<span class="fc" data-hits="3">  local balance = bint(self.balancesById[id][from])</span>
<span class="fc" data-hits="3">  if bint.__le(qty, balance) then</span>
<span class="fc" data-hits="2">    self.balancesById[id][from] = tostring(bint.__sub(balance, qty))</span>
<span class="fc" data-hits="2">    self.balancesById[id][recipient] = tostring(bint.__add(self.balancesById[id][recipient], qty))</span>

    -- Only send the notifications if the cast tag is not set
<span class="fc" data-hits="2">    if not cast then</span>
<span class="fc" data-hits="1">      return self.transferSingleNotices(from, recipient, id, quantity, msg, useReply)</span>
    end
  else
<span class="fc" data-hits="1">    return self.transferErrorNotice(id, msg)</span>
  end
end

--- Batch transfer quantities of tokens with the given IDs
--- @param from string The process ID that will send the token
--- @param recipient string The process ID that will receive the token
--- @param ids table&lt;string&gt; The IDs of the tokens to transfer
--- @param quantities table&lt;string&gt; The quantities of tokens to transfer
--- @param cast boolean The cast is set to true to silence the transfer notice
--- @param useReply boolean Whether to use `msg.reply` or `ao.send`
--- @param msg Message The message received
--- @return table&lt;Message&gt;|Message|nil The transfer notices, error notice or nothing
<span class="fc" data-hits="4">function SemiFungibleTokensMethods:transferBatch(from, recipient, ids, quantities, cast, msg, useReply)</span>
<span class="fc" data-hits="7">  local ids_ = {}</span>
<span class="fc" data-hits="7">  local quantities_ = {}</span>

<span class="fc" data-hits="18">  for i = 1, #ids do</span>
<span class="fc" data-hits="12">    if not self.balancesById[ ids[i] ] then self.balancesById[ ids[i] ] = {} end</span>
<span class="fc" data-hits="12">    if not self.balancesById[ ids[i] ][from] then self.balancesById[ ids[i] ][from] = &quot;0&quot; end</span>
<span class="fc" data-hits="12">    if not self.balancesById[ ids[i] ][recipient] then self.balancesById[ ids[i] ][recipient] = &quot;0&quot; end</span>

<span class="fc" data-hits="12">    local qty = bint(quantities[i])</span>
<span class="fc" data-hits="12">    local balance = bint(self.balancesById[ ids[i] ][from])</span>

<span class="fc" data-hits="12">    if bint.__le(qty, balance) then</span>
<span class="fc" data-hits="11">      self.balancesById[ ids[i] ][from] = tostring(bint.__sub(balance, qty))</span>
<span class="fc" data-hits="11">      self.balancesById[ ids[i] ][recipient] = tostring(bint.__add(self.balancesById[ ids[i] ][recipient], qty))</span>
<span class="fc" data-hits="11">      table.insert(ids_, ids[i])</span>
<span class="fc" data-hits="11">      table.insert(quantities_, quantities[i])</span>
    else
<span class="fc" data-hits="1">      return self.transferErrorNotice(ids[i], msg)</span>
    end
  end

  -- Only send the notifications if the cast tag is not set
<span class="fc" data-hits="6">  if not cast and #ids_ &gt; 0 then</span>
<span class="fc" data-hits="4">    return self.transferBatchNotices(from, recipient, ids_, quantities_, msg, useReply)</span>
  end
end

--- Get account balance of tokens with the given ID
--- @param sender string The process ID of the sender
--- @param recipient string|nil The process ID of the recipient (optional)
--- @param id string The ID of the token
--- @return string The balance of the account for the given ID
<span class="fc" data-hits="4">function SemiFungibleTokensMethods:getBalance(sender, recipient, id)</span>
<span class="fc" data-hits="2">  local bal = &#39;0&#39;</span>
  -- If ID is found then continue
<span class="fc" data-hits="2">  if self.balancesById[id] then</span>
    -- If recipient is not provided, return the senders balance
<span class="fc" data-hits="2">    if (recipient and self.balancesById[id][recipient]) then</span>
<span class="fc" data-hits="1">      bal = self.balancesById[id][recipient]</span>
<span class="fc" data-hits="1">    elseif self.balancesById[id][sender] then</span>
<span class="fc" data-hits="1">      bal = self.balancesById[id][sender]</span>
    end
  end
  -- return balance
<span class="fc" data-hits="2">  return bal</span>
end

--- Get accounts&#39; balance of tokens with the given IDs
--- @param recipients table&lt;string&gt; The process IDs of the recipients
--- @param ids table&lt;string&gt; The IDs of the tokens
--- @return table&lt;string&gt; The balances of the recipients for each respective ID
<span class="fc" data-hits="4">function SemiFungibleTokensMethods:getBatchBalance(recipients, ids)</span>
<span class="fc" data-hits="13">  assert(#recipients == #ids, &#39;Recipients and Ids must have same lengths&#39;)</span>
<span class="fc" data-hits="13">  local bals = {}</span>

<span class="fc" data-hits="40">  for i = 1, #recipients do</span>
<span class="fc" data-hits="27">    table.insert(bals, &#39;0&#39;)</span>
<span class="fc" data-hits="27">    if self.balancesById[ ids[i] ] then</span>
<span class="fc" data-hits="27">      if self.balancesById[ ids[i] ][ recipients[i] ] then</span>
<span class="fc" data-hits="27">        bals[i] = self.balancesById[ ids[i] ][ recipients[i] ]</span>
      end
    end
  end

<span class="fc" data-hits="13">  return bals</span>
end

--- Get account balances of tokens with the given ID
--- @param id string The ID of the token
--- @return table&lt;string, string&gt; The account balances for the given ID
<span class="fc" data-hits="4">function SemiFungibleTokensMethods:getBalances(id)</span>
<span class="fc" data-hits="1">  local bals = {}</span>
<span class="fc" data-hits="1">  if self.balancesById[id] then</span>
<span class="fc" data-hits="1">    bals = self.balancesById[id]</span>
  end
  -- return balances
<span class="fc" data-hits="1">  return bals</span>
end

--- Get accounts&#39; balances of tokens with the given IDs
--- @param positionIds table&lt;string&gt; The IDs of the tokens
--- @return table&lt;string, table&lt;string, string&gt;&gt; The account balances for each respective ID
<span class="fc" data-hits="4">function SemiFungibleTokensMethods:getBatchBalances(positionIds)</span>
<span class="fc" data-hits="1">  local bals = {}</span>

<span class="fc" data-hits="4">  for i = 1, #positionIds do</span>
<span class="fc" data-hits="3">    bals[ positionIds[i] ] = {}</span>
<span class="fc" data-hits="3">    if self.balancesById[ positionIds[i] ] then</span>
<span class="fc" data-hits="3">      bals[ positionIds[i] ] = self.balancesById[ positionIds[i] ]</span>
    end
  end
  -- return balances
<span class="fc" data-hits="1">  return bals</span>
end

<span class="fc" data-hits="4">return SemiFungibleTokens</span>
</pre>
      </div>

      <div class="hidden file success-high" id="src-marketmodules-semifungibletokensnotices">
         <h2 class="title">
            src/marketModules/semiFungibleTokensNotices.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 96.81%"></span>
                  <span><strong>96.81%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>91</strong> Hits</span>
               <span class="miss"><strong>3</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums">--[[
=========================================================
Part of the Outcome codebase © 2025. All Rights Reserved.
See semiFungibleTokens.lua for full license details.
=========================================================
]]

-- local ao = require(&#39;.ao&#39;)
<span class="fc" data-hits="5">local json = require(&#39;json&#39;)</span>

<span class="fc" data-hits="5">local SemiFungibleTokensNotices = {}</span>

--- Mint single notice
--- @param to string The address that will own the minted token
--- @param id string The ID of the token to be minted
--- @param quantity string The quantity of the token to be minted
--- @param msg Message The message received
--- @return Message The mint notice
<span class="fc" data-hits="5">function SemiFungibleTokensNotices.mintSingleNotice(to, id, quantity, msg)</span>
<span class="fc" data-hits="14">  return msg.reply({</span>
<span class="fc" data-hits="7">    Recipient = to,</span>
<span class="fc" data-hits="7">    PositionId = tostring(id),</span>
<span class="fc" data-hits="7">    Quantity = tostring(quantity),</span>
<span class="fc" data-hits="7">    Action = &#39;Mint-Single-Notice&#39;,</span>
<span class="fc" data-hits="7">    Data = Colors.gray .. &quot;Successfully minted &quot; .. Colors.blue .. tostring(quantity) .. Colors.gray .. &quot; of id &quot; .. Colors.blue .. tostring(id) .. Colors.reset</span>
  })
end

--- Mint batch notice
--- @param to string The address that will own the minted tokens
--- @param ids table&lt;string&gt; The IDs of the tokens to be minted
--- @param quantities table&lt;string&gt; The quantities of the tokens to be minted
--- @param msg Message The message received
--- @return Message The batch mint notice
<span class="fc" data-hits="5">function SemiFungibleTokensNotices.mintBatchNotice(to, ids, quantities, msg)</span>
<span class="fc" data-hits="52">  return msg.forward(to, {</span>
<span class="fc" data-hits="26">    Recipient = to,</span>
<span class="fc" data-hits="26">    PositionIds = json.encode(ids),</span>
<span class="fc" data-hits="26">    Quantities = json.encode(quantities),</span>
<span class="fc" data-hits="26">    Action = &#39;Mint-Batch-Notice&#39;,</span>
<span class="fc" data-hits="26">    Data = &quot;Successfully minted batch&quot;</span>
  })
end

--- Burn single notice
--- @param from string The address that will burn the token
--- @param id string The ID of the token to be burned
--- @param quantity string The quantity of the token to be burned
--- @param msg Message The message received
--- @param useReply boolean Whether to use `msg.reply` or `ao.send`
--- @return Message The burn notice
<span class="fc" data-hits="5">function SemiFungibleTokensNotices.burnSingleNotice(from, id, quantity, msg, useReply)</span>
  -- Prepare notice
<span class="fc" data-hits="5">  local notice = {</span>
<span class="fc" data-hits="5">    Recipient = from,</span>
<span class="fc" data-hits="5">    PositionId = tostring(id),</span>
<span class="fc" data-hits="5">    Quantity = tostring(quantity),</span>
<span class="fc" data-hits="5">    Action = &#39;Burn-Single-Notice&#39;,</span>
<span class="fc" data-hits="5">    Data = Colors.gray .. &quot;Successfully burned &quot; .. Colors.blue .. tostring(quantity) .. Colors.gray .. &quot; of id &quot; .. Colors.blue .. tostring(id) .. Colors.reset</span>
  }
  -- Forward X-Tags
<span class="fc" data-hits="24">  for tagName, tagValue in pairs(msg) do</span>
    -- Tags beginning with &quot;X-&quot; are forwarded
<span class="fc" data-hits="19">    if string.sub(tagName, 1, 2) == &quot;X-&quot; then</span>
<span class="fc" data-hits="2">      notice[tagName] = tagValue</span>
    end
  end
  -- Send notice
<span class="fc" data-hits="5">  if useReply then return msg.reply(notice) end</span>
<span class="fc" data-hits="3">  notice.Target = from</span>
<span class="fc" data-hits="3">  return ao.send(notice)</span>
end

--- Burn batch notice
--- @param from string The address that will burn the tokens
--- @param positionIds table&lt;string&gt; The IDs of the positions to be burned
--- @param quantities table&lt;string&gt; The quantities of the tokens to be burned
--- @param remainingBalances table&lt;string&gt; The remaining balances of unburned tokens
--- @param msg Message The message received
--- @param useReply boolean Whether to use `msg.reply` or `ao.send`
--- @return Message The burn notice
<span class="fc" data-hits="5">function SemiFungibleTokensNotices.burnBatchNotice(from, positionIds, quantities, remainingBalances, msg, useReply)</span>
  -- Prepare notice
<span class="fc" data-hits="4">  local notice = {</span>
<span class="fc" data-hits="4">    Recipient = from,</span>
<span class="fc" data-hits="4">    PositionIds = json.encode(positionIds),</span>
<span class="fc" data-hits="4">    Quantities = json.encode(quantities),</span>
<span class="fc" data-hits="4">    RemainingBalances = json.encode(remainingBalances),</span>
<span class="fc" data-hits="4">    Action = &#39;Burn-Batch-Notice&#39;,</span>
<span class="fc" data-hits="4">    Data = &quot;Successfully burned batch&quot;</span>
  }
  -- Forward X-Tags
<span class="fc" data-hits="22">  for tagName, tagValue in pairs(msg) do</span>
    -- Tags beginning with &quot;X-&quot; are forwarded
<span class="fc" data-hits="18">    if string.sub(tagName, 1, 2) == &quot;X-&quot; then</span>
<span class="fc" data-hits="2">      notice[tagName] = tagValue</span>
    end
  end
  -- Send notice
<span class="fc" data-hits="4">  if useReply then return msg.reply(notice) end</span>
<span class="fc" data-hits="2">  notice.Target = from</span>
<span class="fc" data-hits="2">  return ao.send(notice)</span>
end

--- Transfer single token notices
--- @param from string The address to be debited
--- @param to string The address to be credited
--- @param id string The ID of the token to be transferred
--- @param quantity string The quantity of the token to be transferred
--- @param msg Message The message received
--- @param useReply boolean Whether to use `msg.reply` or `ao.send`
--- @return table&lt;Message&gt; The debit and credit transfer notices
<span class="fc" data-hits="5">function SemiFungibleTokensNotices.transferSingleNotices(from, to, id, quantity, msg, useReply)</span>
  -- Prepare debit notice
<span class="fc" data-hits="2">  local debitNotice = {</span>
<span class="fc" data-hits="2">    Action = &#39;Debit-Single-Notice&#39;,</span>
<span class="fc" data-hits="2">    Recipient = to,</span>
<span class="fc" data-hits="2">    PositionId = tostring(id),</span>
<span class="fc" data-hits="2">    Quantity = tostring(quantity),</span>
<span class="fc" data-hits="2">    Data = Colors.gray .. &quot;You transferred &quot; .. Colors.blue .. tostring(quantity) .. Colors.gray .. &quot; of id &quot;</span>
<span class="fc" data-hits="2">      .. Colors.blue .. tostring(id) .. Colors.gray .. &quot; to &quot; .. Colors.green .. to .. Colors.reset</span>
  }
  -- Prepare credit notice
<span class="fc" data-hits="2">  local creditNotice = {</span>
<span class="fc" data-hits="2">    Action = &#39;Credit-Single-Notice&#39;,</span>
<span class="fc" data-hits="2">    Sender = from,</span>
<span class="fc" data-hits="2">    PositionId = tostring(id),</span>
<span class="fc" data-hits="2">    Quantity = tostring(quantity),</span>
<span class="fc" data-hits="2">    Data = Colors.gray .. &quot;You received &quot; .. Colors.blue .. tostring(quantity) .. Colors.gray .. &quot; of id &quot;</span>
<span class="fc" data-hits="2">      .. Colors.blue .. tostring(id) .. Colors.gray .. &quot; from &quot; .. Colors.green .. from .. Colors.reset</span>
  }
  -- Forward X-Tags
<span class="fc" data-hits="14">  for tagName, tagValue in pairs(msg) do</span>
    -- Tags beginning with &quot;X-&quot; are forwarded
<span class="fc" data-hits="12">    if string.sub(tagName, 1, 2) == &quot;X-&quot; then</span>
<span class="fc" data-hits="2">      debitNotice[tagName] = tagValue</span>
<span class="fc" data-hits="2">      creditNotice[tagName] = tagValue</span>
    end
  end
  -- Send notices
<span class="fc" data-hits="2">  if useReply then return { msg.reply(debitNotice), msg.forward(to, creditNotice) } end</span>
<span class="nc">  debitNotice.Target = from</span>
<span class="nc">  creditNotice.Target = to</span>
<span class="nc">  return { ao.send(debitNotice), ao.send(creditNotice) }</span>
end

--- Transfer batch tokens notices
--- @param from string The address to be debited
--- @param to string The address to be credited
--- @param ids table&lt;string&gt; The IDs of the tokens to be transferred
--- @param quantities table&lt;string&gt; The quantities of the tokens to be transferred
--- @param msg Message The message received
--- @param useReply boolean Whether to use `msg.reply` or `ao.send`
--- @return table&lt;Message&gt; The debit and credit batch transfer notices
<span class="fc" data-hits="5">function SemiFungibleTokensNotices.transferBatchNotices(from, to, ids, quantities, msg, useReply)</span>
  -- Prepare debit notice
<span class="fc" data-hits="5">  local debitNotice = {</span>
<span class="fc" data-hits="5">    Action = &#39;Debit-Batch-Notice&#39;,</span>
<span class="fc" data-hits="5">    Recipient = to,</span>
<span class="fc" data-hits="5">    PositionIds = json.encode(ids),</span>
<span class="fc" data-hits="5">    Quantities = json.encode(quantities),</span>
<span class="fc" data-hits="5">    Data = Colors.gray .. &quot;You transferred batch to &quot; .. Colors.green .. to .. Colors.reset</span>
  }
  -- Prepare credit notice
<span class="fc" data-hits="5">  local creditNotice = {</span>
<span class="fc" data-hits="5">    Action = &#39;Credit-Batch-Notice&#39;,</span>
<span class="fc" data-hits="5">    Sender = from,</span>
<span class="fc" data-hits="5">    PositionIds = json.encode(ids),</span>
<span class="fc" data-hits="5">    Quantities = json.encode(quantities),</span>
<span class="fc" data-hits="5">    Data = Colors.gray .. &quot;You received batch from &quot; .. Colors.green .. from .. Colors.reset</span>
  }
  -- Forward X-Tags
<span class="fc" data-hits="29">  for tagName, tagValue in pairs(msg) do</span>
    -- Tags beginning with &quot;X-&quot; are forwarded
<span class="fc" data-hits="24">    if string.sub(tagName, 1, 2) == &quot;X-&quot; then</span>
<span class="fc" data-hits="2">      debitNotice[tagName] = tagValue</span>
<span class="fc" data-hits="2">      creditNotice[tagName] = tagValue</span>
    end
  end
  -- Send notice
<span class="fc" data-hits="5">  if useReply then return { msg.reply(debitNotice), msg.forward(to, creditNotice) } end</span>
<span class="fc" data-hits="3">  debitNotice.Target = from</span>
<span class="fc" data-hits="3">  creditNotice.Target = to</span>
<span class="fc" data-hits="3">  return {ao.send(debitNotice), ao.send(creditNotice)}</span>
end

--- Transfer error notice
--- @param id string The ID of the token to be transferred
--- @param msg Message The message received
--- @return Message The transfer error notice
<span class="fc" data-hits="5">function SemiFungibleTokensNotices.transferErrorNotice(id, msg)</span>
<span class="fc" data-hits="6">  return msg.reply({</span>
<span class="fc" data-hits="3">    Action = &#39;Transfer-Error&#39;,</span>
<span class="fc" data-hits="3">    [&#39;Message-Id&#39;] = msg.Id,</span>
<span class="fc" data-hits="3">    [&#39;PositionId&#39;] = id,</span>
<span class="fc" data-hits="3">    Error = &#39;Insufficient Balance!&#39;</span>
  })
end

<span class="fc" data-hits="5">return SemiFungibleTokensNotices</span>
</pre>
      </div>

      <div class="hidden file success-low" id="src-marketmodules-semifungibletokensvalidation">
         <h2 class="title">
            src/marketModules/semiFungibleTokensValidation.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 63.24%"></span>
                  <span><strong>63.24%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>43</strong> Hits</span>
               <span class="miss"><strong>25</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums">--[[
=========================================================
Part of the Outcome codebase © 2025. All Rights Reserved.
See semiFungibleTokens.lua for full license details.
=========================================================
]]

<span class="fc" data-hits="1">local semiFungibleTokensValidation = {}</span>
<span class="fc" data-hits="1">local sharedValidation = require(&#39;marketModules.sharedValidation&#39;)</span>
<span class="fc" data-hits="1">local json = require(&quot;json&quot;)</span>

--- Validates a transferSingle message
--- @param msg Message The message received
--- @param validPositionIds table&lt;string&gt; The array of valid token IDs
--- @return boolean, string|nil Returns true on success, or false and an error message on failure
<span class="fc" data-hits="1">function semiFungibleTokensValidation.transferSingle(msg, validPositionIds)</span>
<span class="fc" data-hits="10">  local success, err = sharedValidation.validateAddress(msg.Tags.Recipient, &#39;Recipient&#39;)</span>
<span class="fc" data-hits="10">  if not success then return false, err end</span>

<span class="fc" data-hits="8">  success, err = sharedValidation.validateItem(msg.Tags.PositionId, validPositionIds, &quot;PositionId&quot;)</span>
<span class="fc" data-hits="8">  if not success then return false, err end</span>

<span class="fc" data-hits="6">  success, err = sharedValidation.validatePositiveInteger(msg.Tags.Quantity, &quot;Quantity&quot;)</span>
<span class="fc" data-hits="6">  if not success then return false, err end</span>

<span class="fc" data-hits="1">  return true</span>
end

--- Validates a transferBatch message
--- @param msg Message The message received
--- @param validPositionIds table&lt;string&gt; The array of valid token IDs
--- @return boolean, string|nil Returns true on success, or false and an error message on failure
<span class="fc" data-hits="1">function semiFungibleTokensValidation.transferBatch(msg, validPositionIds)</span>
<span class="fc" data-hits="6">  local success, err = sharedValidation.validateAddress(msg.Tags.Recipient, &#39;Recipient&#39;)</span>
<span class="fc" data-hits="6">  if not success then return false, err end</span>

<span class="fc" data-hits="4">  if type(msg.Tags.PositionIds) ~= &#39;string&#39; then</span>
<span class="fc" data-hits="1">    return false, &#39;PositionIds is required!&#39;</span>
  end
<span class="fc" data-hits="3">  local positionIds = json.decode(msg.Tags.PositionIds)</span>

<span class="fc" data-hits="3">  if type(msg.Tags.Quantities) ~= &#39;string&#39; then</span>
<span class="fc" data-hits="1">    return false, &#39;Quantities is required!&#39;</span>
  end
<span class="fc" data-hits="2">  local quantities = json.decode(msg.Tags.Quantities)</span>

<span class="fc" data-hits="2">  if #positionIds ~= #quantities then</span>
<span class="nc">    return false, &#39;Input array lengths must match!&#39;</span>
  end
<span class="fc" data-hits="2">  if #positionIds == 0 then</span>
<span class="nc">    return false, &quot;Input array length must be greater than zero!&quot;</span>
  end

<span class="fc" data-hits="7">  for i = 1, #positionIds do</span>
<span class="fc" data-hits="6">    success, err = sharedValidation.validateItem(positionIds[i], validPositionIds, &quot;PositionId&quot;)</span>
<span class="fc" data-hits="6">    if not success then return false, err end</span>

<span class="fc" data-hits="5">    success, err = sharedValidation.validatePositiveInteger(quantities[i], &quot;Quantity&quot;)</span>
<span class="fc" data-hits="5">    if not success then return false, err end</span>
  end

<span class="fc" data-hits="1">  return true</span>
end

--- Validates a balanceById message
--- @param msg Message The message received
--- @param validPositionIds table&lt;string&gt; The array of valid token IDs
--- @return boolean, string|nil Returns true on success, or false and an error message on failure
<span class="fc" data-hits="1">function semiFungibleTokensValidation.balanceById(msg, validPositionIds)</span>
<span class="fc" data-hits="2">  if msg.Tags.Recipient then</span>
<span class="nc">    local success, err = sharedValidation.validateAddress(msg.Tags.Recipient, &#39;Recipient&#39;)</span>
<span class="nc">    if not success then return false, err end</span>
  end
<span class="fc" data-hits="2">  return sharedValidation.validateItem(msg.Tags.PositionId, validPositionIds, &quot;PositionId&quot;)</span>
end

--- Validates a balancesById message
--- @param msg Message The message received
--- @param validPositionIds table&lt;string&gt; The array of valid token IDs
--- @return boolean, string|nil Returns true on success, or false and an error message on failure
<span class="fc" data-hits="1">function semiFungibleTokensValidation.balancesById(msg, validPositionIds)</span>
<span class="nc">  if msg.Tags.Recipient then</span>
<span class="nc">    local success, err = sharedValidation.validateAddress(msg.Tags.Recipient, &#39;Recipient&#39;)</span>
<span class="nc">    if not success then return false, err end</span>
  end
<span class="nc">  return sharedValidation.validateItem(msg.Tags.PositionId, validPositionIds, &quot;PositionId&quot;)</span>
end

--- Validates a batchBalance message
--- @param msg Message The message received
--- @param validPositionIds table&lt;string&gt; The array of valid token IDs
--- @return boolean, string|nil Returns true on success, or false and an error message on failure
<span class="fc" data-hits="1">function semiFungibleTokensValidation.batchBalance(msg, validPositionIds)</span>
<span class="nc">  if not msg.Tags.Recipients then</span>
<span class="nc">    return false, &quot;Recipients is required!&quot;</span>
  end
<span class="nc">  local recipients = json.decode(msg.Tags.Recipients)</span>

<span class="nc">  if not msg.Tags.PositionIds then</span>
<span class="nc">    return false, &quot;PositionIds is required!&quot;</span>
  end
<span class="nc">  local positionIds = json.decode(msg.Tags.PositionIds)</span>

<span class="nc">  if #recipients ~= #positionIds then</span>
<span class="nc">    return false, &quot;Input array lengths must match!&quot;</span>
  end
<span class="nc">  if #recipients == 0 then</span>
<span class="nc">    return false, &quot;Input array length must be greater than zero!&quot;</span>
  end

<span class="nc">  for i = 1, #positionIds do</span>
<span class="nc">    local success, err = sharedValidation.validateAddress(recipients[i], &#39;Recipient&#39;)</span>
<span class="nc">    if not success then return false, err end</span>

<span class="nc">    success, err = sharedValidation.validateItem(positionIds[i], validPositionIds, &quot;PositionId&quot;)</span>
<span class="nc">    if not success then return false, err end</span>
  end

<span class="nc">  return true</span>
end

--- Validates a batchBalances message
--- @param msg Message The message received
--- @param validPositionIds table&lt;string&gt; The array of valid token IDs
--- @return boolean, string|nil Returns true on success, or false and an error message on failure
<span class="fc" data-hits="1">function semiFungibleTokensValidation.batchBalances(msg, validPositionIds)</span>
<span class="fc" data-hits="2">  if not msg.Tags.PositionIds then</span>
<span class="fc" data-hits="1">    return false, &quot;PositionIds is required!&quot;</span>
  end
<span class="fc" data-hits="1">  local positionIds = json.decode(msg.Tags.PositionIds)</span>

<span class="fc" data-hits="1">  if #positionIds == 0 then</span>
<span class="nc">    return false, &quot;Input array length must be greater than zero!&quot;</span>
  end

<span class="fc" data-hits="4">  for i = 1, #positionIds do</span>
<span class="fc" data-hits="3">    local success, err = sharedValidation.validateItem(positionIds[i], validPositionIds, &quot;PositionId&quot;)</span>
<span class="fc" data-hits="3">    if not success then return false, err end</span>
  end

<span class="fc" data-hits="1">  return true</span>
end

<span class="fc" data-hits="1">return semiFungibleTokensValidation</span>
</pre>
      </div>

      <div class="hidden file warning" id="src-marketmodules-sharedutils">
         <h2 class="title">
            src/marketModules/sharedUtils.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 54.05%"></span>
                  <span><strong>54.05%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>20</strong> Hits</span>
               <span class="miss"><strong>17</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums">--[[
=========================================================
Part of the Outcome codebase © 2025. All Rights Reserved.
See market.lua for full license details.
=========================================================
]]

<span class="fc" data-hits="4">local sharedUtils = {}</span>

--- Verify if extracted value is a JSON simple value
--- @param value any
--- @return boolean
local function isSimpleValue(value)
  -- Trim whitespace
<span class="fc" data-hits="5">  value = value:match(&quot;^%s*(.-)%s*$&quot;) or value</span>
  -- Check for a quoted string: &quot;someValue&quot;
<span class="fc" data-hits="5">  if value:match(&#39;^&quot;[^&quot;]*&quot;$&#39;) then</span>
<span class="fc" data-hits="1">    return true</span>
  end
  -- Check for a number (integer or float, optional minus sign): 123, -123, 123.45
<span class="fc" data-hits="4">  if value:match(&#39;^[-]?%d+%.?%d*$&#39;) then</span>
<span class="fc" data-hits="4">    return true</span>
  end
  -- Check for boolean
<span class="nc">  if string.lower(value) == &quot;true&quot; or string.lower(value) == &quot;false&quot; then</span>
<span class="nc">    return true</span>
  end
<span class="nc">  return false</span>
end

--- Verify if a valid JSON object
--- @param str any
--- @return boolean
<span class="fc" data-hits="4">function sharedUtils.isValidKeyValueJSON(str)</span>
<span class="nc">  if type(str) ~= &quot;string&quot; then return false end</span>
  -- Trim whitespace
<span class="nc">  str = str:match(&quot;^%s*(.-)%s*$&quot;)</span>
  -- Ensure it starts with `{` and ends with `}`
<span class="nc">  local isObject = str:match(&quot;^%{%s*(.-)%s*%}$&quot;)</span>
<span class="nc">  if not isObject then return false end</span>
  -- This pattern only extracts the key and the entire raw value
<span class="nc">  local keyValuePattern = &#39;^%s*&quot;([^&quot;]+)&quot;%s*:%s*(.-)%s*$&#39;</span>
  -- Check all key-value pairs
<span class="nc">  for keyValue in isObject:gmatch(&quot;[^,]+&quot;) do</span>
<span class="nc">    local key, rawValue = keyValue:match(keyValuePattern)</span>
<span class="nc">    if not key or not rawValue then</span>
<span class="nc">      return false</span>
    end
    -- Now validate that rawValue is a valid JSON simple value
<span class="nc">    if not isSimpleValue(rawValue) then</span>
<span class="nc">      return false</span>
    end
  end
<span class="nc">  return true</span>
end

--- Verify if a valid JSON array
--- @param str any
--- @return boolean
<span class="fc" data-hits="4">function sharedUtils.isJSONArray(str)</span>
<span class="fc" data-hits="3">  if type(str) ~= &quot;string&quot; then return false end</span>
  -- Trim whitespace
<span class="fc" data-hits="3">  str = str:match(&quot;^%s*(.-)%s*$&quot;)</span>
  -- Ensure it starts with `[` and ends with `]`
<span class="fc" data-hits="3">  local isArray = str:match(&quot;^%[%s*(.-)%s*%]$&quot;)</span>
<span class="fc" data-hits="3">  if not isArray then return false end</span>
  -- Split the array elements and validate each one
<span class="fc" data-hits="7">  for value in isArray:gmatch(&quot;[^,]+&quot;) do</span>
<span class="fc" data-hits="5">    value = value:match(&quot;^%s*(.-)%s*$&quot;) -- Trim whitespace around each value</span>
<span class="fc" data-hits="5">    if not isSimpleValue(value) then</span>
<span class="nc">      return false</span>
    end
  end
<span class="fc" data-hits="2">  return true</span>
end

--- Verify if a valid Arweave address
--- @param address any
--- @return boolean
<span class="fc" data-hits="4">function sharedUtils.isValidArweaveAddress(address)</span>
<span class="fc" data-hits="33">	return type(address) == &quot;string&quot; and #address == 43 and string.match(address, &quot;^[%w-_]+$&quot;) ~= nil</span>
end

--- Verify if a valid boolean string
--- @param value any
--- @return boolean
<span class="fc" data-hits="4">function sharedUtils.isValidBooleanString(value)</span>
<span class="nc">  return type(value) == &quot;string&quot; and (string.lower(value) == &quot;true&quot; or string.lower(value) == &quot;false&quot;)</span>
end

<span class="fc" data-hits="4">return sharedUtils</span>
</pre>
      </div>

      <div class="hidden file success-low" id="src-marketmodules-sharedvalidation">
         <h2 class="title">
            src/marketModules/sharedValidation.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 73.68%"></span>
                  <span><strong>73.68%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>28</strong> Hits</span>
               <span class="miss"><strong>10</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums">--[[
=========================================================
Part of the Outcome codebase © 2025. All Rights Reserved.
See market.lua for full license details.
=========================================================
]]

<span class="fc" data-hits="4">local sharedValidation = {}</span>
<span class="fc" data-hits="4">local sharedUtils = require(&#39;marketModules.sharedUtils&#39;)</span>
<span class="fc" data-hits="4">local utils = require(&#39;.utils&#39;)</span>

--- Validates address
--- @param address any The address to be validated
--- @param tagName string The name of the tag being validated
--- @return boolean, string|nil Returns true on success, or false and an error message on failure
<span class="fc" data-hits="4">function sharedValidation.validateAddress(address, tagName)</span>
<span class="fc" data-hits="36">  if type(address) ~= &#39;string&#39; then</span>
<span class="fc" data-hits="3">    return false, tagName .. &#39; is required and must be a string!&#39;</span>
  end
<span class="fc" data-hits="33">  if not sharedUtils.isValidArweaveAddress(address) then</span>
<span class="fc" data-hits="3">    return false, tagName .. &#39; must be a valid Arweave address!&#39;</span>
  end
<span class="fc" data-hits="30">  return true</span>
end

--- Validates array item
--- @param item any The item to be validated
--- @param validItems table&lt;string&gt; The array of valid items
--- @param tagName string The name of the tag being validated
--- @return boolean, string|nil Returns true on success, or false and an error message on failure
<span class="fc" data-hits="4">function sharedValidation.validateItem(item, validItems, tagName)</span>
<span class="fc" data-hits="36">  if type(item) ~= &#39;string&#39; then</span>
<span class="fc" data-hits="4">    return false, tagName .. &#39; is required and must be a string!&#39;</span>
  end
<span class="fc" data-hits="32">  if not utils.includes(item, validItems) then</span>
<span class="fc" data-hits="6">    return false, &#39;Invalid &#39; .. tagName .. &#39;!&#39;</span>
  end
<span class="fc" data-hits="26">  return true</span>
end

--- Validates positive integer
--- @param quantity any The quantity to be validated
--- @param tagName string The name of the tag being validated
--- @return boolean, string|nil Returns true on success, or false and an error message on failure
<span class="fc" data-hits="4">function sharedValidation.validatePositiveInteger(quantity, tagName)</span>
<span class="fc" data-hits="47">  if type(quantity) ~= &#39;string&#39; then</span>
<span class="fc" data-hits="8">    return false, tagName .. &#39; is required and must be a string!&#39;</span>
  end

<span class="fc" data-hits="39">  local num = tonumber(quantity)</span>
<span class="fc" data-hits="39">  if not num then</span>
<span class="fc" data-hits="9">    return false, tagName .. &#39; must be a valid number!&#39;</span>
  end
<span class="fc" data-hits="30">  if num &lt;= 0 then</span>
<span class="fc" data-hits="4">    return false, tagName .. &#39; must be greater than zero!&#39;</span>
  end
<span class="fc" data-hits="26">  if num % 1 ~= 0 then</span>
<span class="fc" data-hits="2">    return false, tagName .. &#39; must be an integer!&#39;</span>
  end

<span class="fc" data-hits="24">  return true</span>
end

--- Validates positive integer or zero
--- @param quantity any The quantity to be validated
--- @param tagName string The name of the tag being validated
--- @return boolean, string|nil Returns true on success, or false and an error message on failure
<span class="fc" data-hits="4">function sharedValidation.validatePositiveIntegerOrZero(quantity, tagName)</span>
<span class="nc">  if type(quantity) ~= &#39;string&#39; then</span>
<span class="nc">    return false, tagName .. &#39; is required and must be a string!&#39;</span>
  end

<span class="nc">  local num = tonumber(quantity)</span>
<span class="nc">  if not num then</span>
<span class="nc">    return false, tagName .. &#39; must be a valid number!&#39;</span>
  end
<span class="nc">  if num &lt; 0 then</span>
<span class="nc">    return false, tagName .. &#39; must be greater than or equal to zero!&#39;</span>
  end
<span class="nc">  if num % 1 ~= 0 then</span>
<span class="nc">    return false, tagName .. &#39; must be an integer!&#39;</span>
  end

<span class="nc">  return true</span>
end

<span class="fc" data-hits="4">return sharedValidation</span>
</pre>
      </div>

      <div class="hidden file success-high" id="src-marketmodules-token">
         <h2 class="title">
            src/marketModules/token.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 98.41%"></span>
                  <span><strong>98.41%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>62</strong> Hits</span>
               <span class="miss"><strong>1</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums">--[[
================================================================================
Module: token.lua
Adapted from the AO Cookbook Token Blueprint:
https:&#47;&#47;cookbook_ao.g8way.io&#47;guides&#47;aos&#47;blueprints&#47;token.html
Licensed under the Business Source License 1.1 (BSL 1.1)
================================================================================

Licensor:          Forward Research
Licensed Work:     aos codebase. The Licensed Work is (c) 2024 Forward Research
Official License:  https:&#47;&#47;github.com&#47;permaweb&#47;aos&#47;blob&#47;main&#47;LICENSE
Additional Use Grant:
  The aos codebases are offered under the BSL 1.1 license for the duration
  of the testnet period. After the testnet phase is over, the code will be
  made available under either a new evolutionary forking license or a
  traditional OSS license (GPLv3&#47;v2, MIT, etc).
  More info: https:&#47;&#47;arweave.medium.com&#47;arweave-is-an-evolutionary-protocol-e072f5e69eaa
Change Date:       Four years from the date the Licensed Work is published.
Change License:    MPL 2.0

Notice:
This code is provided under the Business Source License 1.1. Redistribution,
modification, or unauthorized use of this code must comply with the terms of
the Business Source License.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, AND NONINFRINGEMENT.
================================================================================
]]

<span class="fc" data-hits="3">local Token = {}</span>
<span class="fc" data-hits="3">local TokenMethods = {}</span>
<span class="fc" data-hits="3">local TokenNotices = require(&#39;marketModules.tokenNotices&#39;)</span>
<span class="fc" data-hits="3">local bint = require(&#39;.bint&#39;)(256)</span>

--- Represents a Token
--- @class Token
--- @field name string The token name
--- @field ticker string The token ticker
--- @field logo string The token logo Arweave TxID
--- @field balances table&lt;string, string&gt; The user token balances
--- @field totalSupply string The total supply of the token
--- @field denomination number The number of decimals

--- Creates a new Token instance
--- @param name string The token name
--- @param ticker string The token ticker
--- @param logo string The token logo Arweave TxID
--- @param balances table&lt;string, string&gt; The user token balances
--- @param totalSupply string The total supply of the token
--- @param denomination number The number of decimals
--- @return Token token The new Token instance
<span class="fc" data-hits="3">function Token.new(name, ticker, logo, balances, totalSupply, denomination)</span>
<span class="fc" data-hits="22">  local token = {</span>
<span class="fc" data-hits="22">    name = name,</span>
<span class="fc" data-hits="22">    ticker = ticker,</span>
<span class="fc" data-hits="22">    logo = logo,</span>
<span class="fc" data-hits="22">    balances = balances,</span>
<span class="fc" data-hits="22">    totalSupply = totalSupply,</span>
<span class="fc" data-hits="22">    denomination = denomination</span>
  }
<span class="fc" data-hits="44">  setmetatable(token, {</span>
    __index = function(_, k)
<span class="fc" data-hits="34">      if TokenMethods[k] then</span>
<span class="fc" data-hits="17">        return TokenMethods[k]</span>
<span class="fc" data-hits="17">      elseif TokenNotices[k] then</span>
<span class="fc" data-hits="17">        return TokenNotices[k]</span>
      else
<span class="nc">        return nil</span>
      end
    end
  })
<span class="fc" data-hits="22">  return token</span>
end

--- Mint a quantity of tokens
--- @param to string The address that will own the minted tokens
--- @param quantity string The quantity of tokens to mint
--- @param msg Message The message received
--- @return Message The mint notice
<span class="fc" data-hits="3">function TokenMethods:mint(to, quantity, msg)</span>
<span class="fc" data-hits="11">  assert(quantity, &#39;Quantity is required!&#39;)</span>
<span class="fc" data-hits="11">  assert(bint.__lt(0, bint(quantity)), &#39;Quantity must be greater than zero!&#39;)</span>
  -- Mint tokens
<span class="fc" data-hits="11">  if not self.balances[to] then self.balances[to] = &#39;0&#39; end</span>
<span class="fc" data-hits="11">  self.balances[to] = tostring(bint.__add(bint(self.balances[to]), bint(quantity)))</span>
<span class="fc" data-hits="11">  self.totalSupply = tostring(bint.__add(bint(self.totalSupply), bint(quantity)))</span>
  -- Send notice
<span class="fc" data-hits="11">  return self.mintNotice(to, quantity, msg)</span>
end

--- Burn a quantity of tokens
--- @param from string The process ID that will no longer own the burned tokens
--- @param quantity string The quantity of tokens to burn
--- @param msg Message The message received
--- @return Message The burn notice
<span class="fc" data-hits="3">function TokenMethods:burn(from, quantity, msg)</span>
<span class="fc" data-hits="4">  assert(bint.__lt(0, bint(quantity)), &#39;Quantity must be greater than zero!&#39;)</span>
<span class="fc" data-hits="4">  assert(self.balances[from], &#39;Must have token balance!&#39;)</span>
<span class="fc" data-hits="4">  assert(bint.__le(bint(quantity), self.balances[from]), &#39;Must have sufficient tokens!&#39;)</span>
  -- Burn tokens
<span class="fc" data-hits="4">  self.balances[from] = tostring(bint.__sub(self.balances[from], bint(quantity)))</span>
<span class="fc" data-hits="4">  self.totalSupply = tostring(bint.__sub(bint(self.totalSupply), bint(quantity)))</span>
  -- Send notice
<span class="fc" data-hits="4">  return self.burnNotice(quantity, msg)</span>
end

--- Transfer a quantity of tokens
--- @param from string The process ID that will send the token
--- @param recipient string The process ID that will receive the token
--- @param quantity string The quantity of tokens to transfer
--- @param cast boolean The cast is set to true to silence the transfer notice
--- @param msg Message The message received
--- @return table&lt;Message&gt;|Message|nil The transfer notices, error notice or nothing
<span class="fc" data-hits="3">function TokenMethods:transfer(from, recipient, quantity, cast, msg)</span>
<span class="fc" data-hits="2">  if not self.balances[from] then self.balances[from] = &quot;0&quot; end</span>
<span class="fc" data-hits="2">  if not self.balances[recipient] then self.balances[recipient] = &quot;0&quot; end</span>

<span class="fc" data-hits="2">  local qty = bint(quantity)</span>
<span class="fc" data-hits="2">  local balance = bint(self.balances[from])</span>

<span class="fc" data-hits="2">  if bint.__le(qty, balance) then</span>
<span class="fc" data-hits="1">    self.balances[from] = tostring(bint.__sub(balance, qty))</span>
<span class="fc" data-hits="1">    self.balances[recipient] = tostring(bint.__add(self.balances[recipient], qty))</span>

    -- Only send the notifications to the Sender and Recipient
    -- if the Cast tag is not set on the Transfer message
<span class="fc" data-hits="1">    if not cast then</span>
      -- Debit-Notice message template, that is sent to the Sender of the transfer
<span class="fc" data-hits="1">      local debitNotice = {</span>
<span class="fc" data-hits="1">        Action = &#39;Debit-Notice&#39;,</span>
<span class="fc" data-hits="1">        Recipient = recipient,</span>
<span class="fc" data-hits="1">        Quantity = quantity,</span>
<span class="fc" data-hits="1">        Data = Colors.gray ..</span>
<span class="fc" data-hits="1">            &quot;You transferred &quot; ..</span>
<span class="fc" data-hits="1">            Colors.blue .. quantity .. Colors.gray .. &quot; to &quot; .. Colors.green .. recipient .. Colors.reset</span>
      }
      -- Credit-Notice message template, that is sent to the Recipient of the transfer
<span class="fc" data-hits="1">      local creditNotice = {</span>
<span class="fc" data-hits="1">        Action = &#39;Credit-Notice&#39;,</span>
<span class="fc" data-hits="1">        Sender = from,</span>
<span class="fc" data-hits="1">        Quantity = quantity,</span>
<span class="fc" data-hits="1">        Data = Colors.gray ..</span>
<span class="fc" data-hits="1">            &quot;You received &quot; ..</span>
<span class="fc" data-hits="1">            Colors.blue .. quantity .. Colors.gray .. &quot; from &quot; .. Colors.green .. from .. Colors.reset</span>
      }

      -- Add forwarded tags to the credit and debit notice messages
<span class="fc" data-hits="5">      for tagName, tagValue in pairs(msg.Tags) do</span>
        -- Tags beginning with &quot;X-&quot; are forwarded
<span class="fc" data-hits="4">        if string.sub(tagName, 1, 2) == &quot;X-&quot; then</span>
<span class="fc" data-hits="1">          debitNotice[tagName] = tagValue</span>
<span class="fc" data-hits="1">          creditNotice[tagName] = tagValue</span>
        end
      end

      -- Send Debit-Notice and Credit-Notice
<span class="fc" data-hits="1">      return self.transferNotices(debitNotice, creditNotice, recipient, msg)</span>
    end
  else
<span class="fc" data-hits="1">    return self.transferErrorNotice(msg)</span>
  end
end

<span class="fc" data-hits="3">return Token</span>
</pre>
      </div>

      <div class="hidden file success-high" id="src-marketmodules-tokennotices">
         <h2 class="title">
            src/marketModules/tokenNotices.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 100.00%"></span>
                  <span><strong>100.00%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>21</strong> Hits</span>
               <span class="miss"><strong>0</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums">--[[
=========================================================
Part of the Outcome codebase © 2025. All Rights Reserved.
See tokens.lua for full license details.
=========================================================
]]

-- local ao = require(&#39;.ao&#39;) @dev required for unit tests?
<span class="fc" data-hits="4">local TokenNotices = {}</span>

--- Mint notice
--- @param recipient string The address that will own the minted tokens
--- @param quantity string The quantity of tokens to mint
--- @param msg Message The message received
--- @return Message The mint notice
<span class="fc" data-hits="4">function TokenNotices.mintNotice(recipient, quantity, msg)</span>
<span class="fc" data-hits="24">  return msg.forward(recipient, {</span>
<span class="fc" data-hits="12">    Recipient = recipient,</span>
<span class="fc" data-hits="12">    Quantity = tostring(quantity),</span>
<span class="fc" data-hits="12">    Action = &#39;Mint-Notice&#39;,</span>
<span class="fc" data-hits="12">    Data = Colors.gray .. &quot;Successfully minted &quot; .. Colors.blue .. tostring(quantity) .. Colors.reset</span>
  })
end

--- Burn notice
--- @param quantity string The quantity of tokens to burn
--- @param msg Message The message received
--- @return Message The burn notice
<span class="fc" data-hits="4">function TokenNotices.burnNotice(quantity, msg)</span>
<span class="fc" data-hits="10">  return ao.send({</span>
<span class="fc" data-hits="5">    Target = msg.Sender and msg.Sender or msg.From,</span>
<span class="fc" data-hits="5">    Quantity = tostring(quantity),</span>
<span class="fc" data-hits="5">    Action = &#39;Burn-Notice&#39;,</span>
<span class="fc" data-hits="5">    Data = Colors.gray .. &quot;Successfully burned &quot; .. Colors.blue .. tostring(quantity) .. Colors.reset</span>
  })
end

--- Transfer notices
--- @param debitNotice Message The notice to send the spender
--- @param creditNotice Message The notice to send the receiver
--- @param recipient string The address that will receive the tokens
--- @param msg Message The mesage received
--- @return table&lt;Message&gt; The transfer notices
<span class="fc" data-hits="4">function TokenNotices.transferNotices(debitNotice, creditNotice, recipient, msg)</span>
<span class="fc" data-hits="2">  return { msg.reply(debitNotice), msg.forward(recipient, creditNotice) }</span>
end

--- Transfer error notice
--- @param msg Message The mesage received
--- @return Message The transfer error notice
<span class="fc" data-hits="4">function TokenNotices.transferErrorNotice(msg)</span>
<span class="fc" data-hits="4">  return msg.reply({</span>
<span class="fc" data-hits="2">    Action = &#39;Transfer-Error&#39;,</span>
<span class="fc" data-hits="2">    [&#39;Message-Id&#39;] = msg.Id,</span>
<span class="fc" data-hits="2">    Error = &#39;Insufficient Balance!&#39;</span>
  })
end

<span class="fc" data-hits="4">return TokenNotices</span>
</pre>
      </div>

      <div class="hidden file success-low" id="src-marketmodules-tokenvalidation">
         <h2 class="title">
            src/marketModules/tokenValidation.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 66.67%"></span>
                  <span><strong>66.67%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>10</strong> Hits</span>
               <span class="miss"><strong>5</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums">--[[
=========================================================
Part of the Outcome codebase © 2025. All Rights Reserved.
See tokens.lua for full license details.
=========================================================
]]

<span class="fc" data-hits="1">local tokenValidation = {}</span>
<span class="fc" data-hits="1">local sharedValidation = require(&#39;marketModules.sharedValidation&#39;)</span>

--- Validates a transfer message
--- @param msg Message The message received
--- @return boolean, string|nil Returns true on success, or false and an error message on failure
<span class="fc" data-hits="1">function tokenValidation.transfer(msg)</span>
<span class="fc" data-hits="8">  local success, err = sharedValidation.validateAddress(msg.Tags.Recipient, &#39;Recipient&#39;)</span>
<span class="fc" data-hits="8">  if not success then return false, err end</span>

<span class="fc" data-hits="6">  success, err = sharedValidation.validatePositiveInteger(msg.Tags.Quantity, &quot;Quantity&quot;)</span>
<span class="fc" data-hits="6">  if not success then return false, err end</span>

<span class="fc" data-hits="1">  return true</span>
end

--- Validates balance
--- @param msg Message The message to be validated
--- @return boolean, string|nil
<span class="fc" data-hits="1">function tokenValidation.balance(msg)</span>
<span class="nc">  if msg.Tags[&#39;Recipient&#39;] then</span>
<span class="nc">    return sharedValidation.validateAddress(msg.Tags[&#39;Recipient&#39;], &#39;Recipient&#39;)</span>
<span class="nc">  elseif msg.Tags[&#39;Target&#39;] then</span>
<span class="nc">    return sharedValidation.validateAddress(msg.Tags[&#39;Target&#39;], &#39;Target&#39;)</span>
  end

<span class="nc">  return true</span>
end

<span class="fc" data-hits="1">return tokenValidation</span>
</pre>
      </div>

   </main>
   <footer>
        Code coverage generated by <a href="https://lunarmodules.github.io/luacov/" target="_blank">LuaCov</a> at 2025-02-28 17:14:12
   </footer>

   <script type="text/javascript">
      !function(){/*
      
       Copyright (C) 2006 Google Inc.
      
       Licensed under the Apache License, Version 2.0 (the "License");
       you may not use this file except in compliance with the License.
       You may obtain a copy of the License at
      
            http://www.apache.org/licenses/LICENSE-2.0
      
       Unless required by applicable law or agreed to in writing, software
       distributed under the License is distributed on an "AS IS" BASIS,
       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       See the License for the specific language governing permissions and
       limitations under the License.
      */
      "undefined"!==typeof window&&(window.PR_SHOULD_USE_CONTINUATION=!0);
      (function(){function T(a){function d(e){var a=e.charCodeAt(0);if(92!==a)return a;var c=e.charAt(1);return(a=w[c])?a:"0"<=c&&"7">=c?parseInt(e.substring(1),8):"u"===c||"x"===c?parseInt(e.substring(2),16):e.charCodeAt(1)}function f(e){if(32>e)return(16>e?"\\x0":"\\x")+e.toString(16);e=String.fromCharCode(e);return"\\"===e||"-"===e||"]"===e||"^"===e?"\\"+e:e}function c(e){var c=e.substring(1,e.length-1).match(RegExp("\\\\u[0-9A-Fa-f]{4}|\\\\x[0-9A-Fa-f]{2}|\\\\[0-3][0-7]{0,2}|\\\\[0-7]{1,2}|\\\\[\\s\\S]|-|[^-\\\\]","g"));
      e=[];var a="^"===c[0],b=["["];a&&b.push("^");for(var a=a?1:0,g=c.length;a<g;++a){var h=c[a];if(/\\[bdsw]/i.test(h))b.push(h);else{var h=d(h),k;a+2<g&&"-"===c[a+1]?(k=d(c[a+2]),a+=2):k=h;e.push([h,k]);65>k||122<h||(65>k||90<h||e.push([Math.max(65,h)|32,Math.min(k,90)|32]),97>k||122<h||e.push([Math.max(97,h)&-33,Math.min(k,122)&-33]))}}e.sort(function(e,a){return e[0]-a[0]||a[1]-e[1]});c=[];g=[];for(a=0;a<e.length;++a)h=e[a],h[0]<=g[1]+1?g[1]=Math.max(g[1],h[1]):c.push(g=h);for(a=0;a<c.length;++a)h=
      c[a],b.push(f(h[0])),h[1]>h[0]&&(h[1]+1>h[0]&&b.push("-"),b.push(f(h[1])));b.push("]");return b.join("")}function m(e){for(var a=e.source.match(RegExp("(?:\\[(?:[^\\x5C\\x5D]|\\\\[\\s\\S])*\\]|\\\\u[A-Fa-f0-9]{4}|\\\\x[A-Fa-f0-9]{2}|\\\\[0-9]+|\\\\[^ux0-9]|\\(\\?[:!=]|[\\(\\)\\^]|[^\\x5B\\x5C\\(\\)\\^]+)","g")),b=a.length,d=[],g=0,h=0;g<b;++g){var k=a[g];"("===k?++h:"\\"===k.charAt(0)&&(k=+k.substring(1))&&(k<=h?d[k]=-1:a[g]=f(k))}for(g=1;g<d.length;++g)-1===d[g]&&(d[g]=++E);for(h=g=0;g<b;++g)k=a[g],
      "("===k?(++h,d[h]||(a[g]="(?:")):"\\"===k.charAt(0)&&(k=+k.substring(1))&&k<=h&&(a[g]="\\"+d[k]);for(g=0;g<b;++g)"^"===a[g]&&"^"!==a[g+1]&&(a[g]="");if(e.ignoreCase&&q)for(g=0;g<b;++g)k=a[g],e=k.charAt(0),2<=k.length&&"["===e?a[g]=c(k):"\\"!==e&&(a[g]=k.replace(/[a-zA-Z]/g,function(a){a=a.charCodeAt(0);return"["+String.fromCharCode(a&-33,a|32)+"]"}));return a.join("")}for(var E=0,q=!1,l=!1,n=0,b=a.length;n<b;++n){var p=a[n];if(p.ignoreCase)l=!0;else if(/[a-z]/i.test(p.source.replace(/\\u[0-9a-f]{4}|\\x[0-9a-f]{2}|\\[^ux]/gi,
      ""))){q=!0;l=!1;break}}for(var w={b:8,t:9,n:10,v:11,f:12,r:13},r=[],n=0,b=a.length;n<b;++n){p=a[n];if(p.global||p.multiline)throw Error(""+p);r.push("(?:"+m(p)+")")}return new RegExp(r.join("|"),l?"gi":"g")}function U(a,d){function f(a){var b=a.nodeType;if(1==b){if(!c.test(a.className)){for(b=a.firstChild;b;b=b.nextSibling)f(b);b=a.nodeName.toLowerCase();if("br"===b||"li"===b)m[l]="\n",q[l<<1]=E++,q[l++<<1|1]=a}}else if(3==b||4==b)b=a.nodeValue,b.length&&(b=d?b.replace(/\r\n?/g,"\n"):b.replace(/[ \t\r\n]+/g,
      " "),m[l]=b,q[l<<1]=E,E+=b.length,q[l++<<1|1]=a)}var c=/(?:^|\s)nocode(?:\s|$)/,m=[],E=0,q=[],l=0;f(a);return{a:m.join("").replace(/\n$/,""),c:q}}function J(a,d,f,c,m){f&&(a={h:a,l:1,j:null,m:null,a:f,c:null,i:d,g:null},c(a),m.push.apply(m,a.g))}function V(a){for(var d=void 0,f=a.firstChild;f;f=f.nextSibling)var c=f.nodeType,d=1===c?d?a:f:3===c?W.test(f.nodeValue)?a:d:d;return d===a?void 0:d}function G(a,d){function f(a){for(var l=a.i,n=a.h,b=[l,"pln"],p=0,q=a.a.match(m)||[],r={},e=0,t=q.length;e<
      t;++e){var z=q[e],v=r[z],g=void 0,h;if("string"===typeof v)h=!1;else{var k=c[z.charAt(0)];if(k)g=z.match(k[1]),v=k[0];else{for(h=0;h<E;++h)if(k=d[h],g=z.match(k[1])){v=k[0];break}g||(v="pln")}!(h=5<=v.length&&"lang-"===v.substring(0,5))||g&&"string"===typeof g[1]||(h=!1,v="src");h||(r[z]=v)}k=p;p+=z.length;if(h){h=g[1];var A=z.indexOf(h),C=A+h.length;g[2]&&(C=z.length-g[2].length,A=C-h.length);v=v.substring(5);J(n,l+k,z.substring(0,A),f,b);J(n,l+k+A,h,K(v,h),b);J(n,l+k+C,z.substring(C),f,b)}else b.push(l+
      k,v)}a.g=b}var c={},m;(function(){for(var f=a.concat(d),l=[],n={},b=0,p=f.length;b<p;++b){var w=f[b],r=w[3];if(r)for(var e=r.length;0<=--e;)c[r.charAt(e)]=w;w=w[1];r=""+w;n.hasOwnProperty(r)||(l.push(w),n[r]=null)}l.push(/[\0-\uffff]/);m=T(l)})();var E=d.length;return f}function x(a){var d=[],f=[];a.tripleQuotedStrings?d.push(["str",/^(?:\'\'\'(?:[^\'\\]|\\[\s\S]|\'{1,2}(?=[^\']))*(?:\'\'\'|$)|\"\"\"(?:[^\"\\]|\\[\s\S]|\"{1,2}(?=[^\"]))*(?:\"\"\"|$)|\'(?:[^\\\']|\\[\s\S])*(?:\'|$)|\"(?:[^\\\"]|\\[\s\S])*(?:\"|$))/,
      null,"'\""]):a.multiLineStrings?d.push(["str",/^(?:\'(?:[^\\\']|\\[\s\S])*(?:\'|$)|\"(?:[^\\\"]|\\[\s\S])*(?:\"|$)|\`(?:[^\\\`]|\\[\s\S])*(?:\`|$))/,null,"'\"`"]):d.push(["str",/^(?:\'(?:[^\\\'\r\n]|\\.)*(?:\'|$)|\"(?:[^\\\"\r\n]|\\.)*(?:\"|$))/,null,"\"'"]);a.verbatimStrings&&f.push(["str",/^@\"(?:[^\"]|\"\")*(?:\"|$)/,null]);var c=a.hashComments;c&&(a.cStyleComments?(1<c?d.push(["com",/^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/,null,"#"]):d.push(["com",/^#(?:(?:define|e(?:l|nd)if|else|error|ifn?def|include|line|pragma|undef|warning)\b|[^\r\n]*)/,
      null,"#"]),f.push(["str",/^<(?:(?:(?:\.\.\/)*|\/?)(?:[\w-]+(?:\/[\w-]+)+)?[\w-]+\.h(?:h|pp|\+\+)?|[a-z]\w*)>/,null])):d.push(["com",/^#[^\r\n]*/,null,"#"]));a.cStyleComments&&(f.push(["com",/^\/\/[^\r\n]*/,null]),f.push(["com",/^\/\*[\s\S]*?(?:\*\/|$)/,null]));if(c=a.regexLiterals){var m=(c=1<c?"":"\n\r")?".":"[\\S\\s]";f.push(["lang-regex",RegExp("^(?:^^\\.?|[+-]|[!=]=?=?|\\#|%=?|&&?=?|\\(|\\*=?|[+\\-]=|->|\\/=?|::?|<<?=?|>>?>?=?|,|;|\\?|@|\\[|~|{|\\^\\^?=?|\\|\\|?=?|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\s*("+
      ("/(?=[^/*"+c+"])(?:[^/\\x5B\\x5C"+c+"]|\\x5C"+m+"|\\x5B(?:[^\\x5C\\x5D"+c+"]|\\x5C"+m+")*(?:\\x5D|$))+/")+")")])}(c=a.types)&&f.push(["typ",c]);c=(""+a.keywords).replace(/^ | $/g,"");c.length&&f.push(["kwd",new RegExp("^(?:"+c.replace(/[\s,]+/g,"|")+")\\b"),null]);d.push(["pln",/^\s+/,null," \r\n\t\u00a0"]);c="^.[^\\s\\w.$@'\"`/\\\\]*";a.regexLiterals&&(c+="(?!s*/)");f.push(["lit",/^@[a-z_$][a-z_$@0-9]*/i,null],["typ",/^(?:[@_]?[A-Z]+[a-z][A-Za-z_$@0-9]*|\w+_t\b)/,null],["pln",/^[a-z_$][a-z_$@0-9]*/i,
      null],["lit",/^(?:0x[a-f0-9]+|(?:\d(?:_\d+)*\d*(?:\.\d*)?|\.\d\+)(?:e[+\-]?\d+)?)[a-z]*/i,null,"0123456789"],["pln",/^\\[\s\S]?/,null],["pun",new RegExp(c),null]);return G(d,f)}function L(a,d,f){function c(a){var b=a.nodeType;if(1==b&&!t.test(a.className))if("br"===a.nodeName.toLowerCase())m(a),a.parentNode&&a.parentNode.removeChild(a);else for(a=a.firstChild;a;a=a.nextSibling)c(a);else if((3==b||4==b)&&f){var e=a.nodeValue,d=e.match(q);d&&(b=e.substring(0,d.index),a.nodeValue=b,(e=e.substring(d.index+
      d[0].length))&&a.parentNode.insertBefore(l.createTextNode(e),a.nextSibling),m(a),b||a.parentNode.removeChild(a))}}function m(a){function c(a,b){var e=b?a.cloneNode(!1):a,k=a.parentNode;if(k){var k=c(k,1),d=a.nextSibling;k.appendChild(e);for(var f=d;f;f=d)d=f.nextSibling,k.appendChild(f)}return e}for(;!a.nextSibling;)if(a=a.parentNode,!a)return;a=c(a.nextSibling,0);for(var e;(e=a.parentNode)&&1===e.nodeType;)a=e;b.push(a)}for(var t=/(?:^|\s)nocode(?:\s|$)/,q=/\r\n?|\n/,l=a.ownerDocument,n=l.createElement("li");a.firstChild;)n.appendChild(a.firstChild);
      for(var b=[n],p=0;p<b.length;++p)c(b[p]);d===(d|0)&&b[0].setAttribute("value",d);var w=l.createElement("ol");w.className="linenums";d=Math.max(0,d-1|0)||0;for(var p=0,r=b.length;p<r;++p)n=b[p],n.className="L"+(p+d)%10,n.firstChild||n.appendChild(l.createTextNode("\u00a0")),w.appendChild(n);a.appendChild(w)}function t(a,d){for(var f=d.length;0<=--f;){var c=d[f];I.hasOwnProperty(c)?D.console&&console.warn("cannot override language handler %s",c):I[c]=a}}function K(a,d){a&&I.hasOwnProperty(a)||(a=/^\s*</.test(d)?
      "default-markup":"default-code");return I[a]}function M(a){var d=a.j;try{var f=U(a.h,a.l),c=f.a;a.a=c;a.c=f.c;a.i=0;K(d,c)(a);var m=/\bMSIE\s(\d+)/.exec(navigator.userAgent),m=m&&8>=+m[1],d=/\n/g,t=a.a,q=t.length,f=0,l=a.c,n=l.length,c=0,b=a.g,p=b.length,w=0;b[p]=q;var r,e;for(e=r=0;e<p;)b[e]!==b[e+2]?(b[r++]=b[e++],b[r++]=b[e++]):e+=2;p=r;for(e=r=0;e<p;){for(var x=b[e],z=b[e+1],v=e+2;v+2<=p&&b[v+1]===z;)v+=2;b[r++]=x;b[r++]=z;e=v}b.length=r;var g=a.h;a="";g&&(a=g.style.display,g.style.display="none");
      try{for(;c<n;){var h=l[c+2]||q,k=b[w+2]||q,v=Math.min(h,k),A=l[c+1],C;if(1!==A.nodeType&&(C=t.substring(f,v))){m&&(C=C.replace(d,"\r"));A.nodeValue=C;var N=A.ownerDocument,u=N.createElement("span");u.className=b[w+1];var B=A.parentNode;B.replaceChild(u,A);u.appendChild(A);f<h&&(l[c+1]=A=N.createTextNode(t.substring(v,h)),B.insertBefore(A,u.nextSibling))}f=v;f>=h&&(c+=2);f>=k&&(w+=2)}}finally{g&&(g.style.display=a)}}catch(y){D.console&&console.log(y&&y.stack||y)}}var D="undefined"!==typeof window?
      window:{},B=["break,continue,do,else,for,if,return,while"],F=[[B,"auto,case,char,const,default,double,enum,extern,float,goto,inline,int,long,register,restrict,short,signed,sizeof,static,struct,switch,typedef,union,unsigned,void,volatile"],"catch,class,delete,false,import,new,operator,private,protected,public,this,throw,true,try,typeof"],H=[F,"alignas,alignof,align_union,asm,axiom,bool,concept,concept_map,const_cast,constexpr,decltype,delegate,dynamic_cast,explicit,export,friend,generic,late_check,mutable,namespace,noexcept,noreturn,nullptr,property,reinterpret_cast,static_assert,static_cast,template,typeid,typename,using,virtual,where"],
      O=[F,"abstract,assert,boolean,byte,extends,finally,final,implements,import,instanceof,interface,null,native,package,strictfp,super,synchronized,throws,transient"],P=[F,"abstract,add,alias,as,ascending,async,await,base,bool,by,byte,checked,decimal,delegate,descending,dynamic,event,finally,fixed,foreach,from,get,global,group,implicit,in,interface,internal,into,is,join,let,lock,null,object,out,override,orderby,params,partial,readonly,ref,remove,sbyte,sealed,select,set,stackalloc,string,select,uint,ulong,unchecked,unsafe,ushort,value,var,virtual,where,yield"],
      F=[F,"abstract,async,await,constructor,debugger,enum,eval,export,from,function,get,import,implements,instanceof,interface,let,null,of,set,undefined,var,with,yield,Infinity,NaN"],Q=[B,"and,as,assert,class,def,del,elif,except,exec,finally,from,global,import,in,is,lambda,nonlocal,not,or,pass,print,raise,try,with,yield,False,True,None"],R=[B,"alias,and,begin,case,class,def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,rescue,retry,self,super,then,true,undef,unless,until,when,yield,BEGIN,END"],
      B=[B,"case,done,elif,esac,eval,fi,function,in,local,set,then,until"],S=/^(DIR|FILE|array|vector|(de|priority_)?queue|(forward_)?list|stack|(const_)?(reverse_)?iterator|(unordered_)?(multi)?(set|map)|bitset|u?(int|float)\d*)\b/,W=/\S/,X=x({keywords:[H,P,O,F,"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END",Q,R,B],hashComments:!0,cStyleComments:!0,multiLineStrings:!0,regexLiterals:!0}),
      I={};t(X,["default-code"]);t(G([],[["pln",/^[^<?]+/],["dec",/^<!\w[^>]*(?:>|$)/],["com",/^<\!--[\s\S]*?(?:-\->|$)/],["lang-",/^<\?([\s\S]+?)(?:\?>|$)/],["lang-",/^<%([\s\S]+?)(?:%>|$)/],["pun",/^(?:<[%?]|[%?]>)/],["lang-",/^<xmp\b[^>]*>([\s\S]+?)<\/xmp\b[^>]*>/i],["lang-js",/^<script\b[^>]*>([\s\S]*?)(<\/script\b[^>]*>)/i],["lang-css",/^<style\b[^>]*>([\s\S]*?)(<\/style\b[^>]*>)/i],["lang-in.tag",/^(<\/?[a-z][^<>]*>)/i]]),"default-markup htm html mxml xhtml xml xsl".split(" "));t(G([["pln",/^[\s]+/,
      null," \t\r\n"],["atv",/^(?:\"[^\"]*\"?|\'[^\']*\'?)/,null,"\"'"]],[["tag",/^^<\/?[a-z](?:[\w.:-]*\w)?|\/?>$/i],["atn",/^(?!style[\s=]|on)[a-z](?:[\w:-]*\w)?/i],["lang-uq.val",/^=\s*([^>\'\"\s]*(?:[^>\'\"\s\/]|\/(?=\s)))/],["pun",/^[=<>\/]+/],["lang-js",/^on\w+\s*=\s*\"([^\"]+)\"/i],["lang-js",/^on\w+\s*=\s*\'([^\']+)\'/i],["lang-js",/^on\w+\s*=\s*([^\"\'>\s]+)/i],["lang-css",/^style\s*=\s*\"([^\"]+)\"/i],["lang-css",/^style\s*=\s*\'([^\']+)\'/i],["lang-css",/^style\s*=\s*([^\"\'>\s]+)/i]]),["in.tag"]);
      t(G([],[["atv",/^[\s\S]+/]]),["uq.val"]);t(x({keywords:H,hashComments:!0,cStyleComments:!0,types:S}),"c cc cpp cxx cyc m".split(" "));t(x({keywords:"null,true,false"}),["json"]);t(x({keywords:P,hashComments:!0,cStyleComments:!0,verbatimStrings:!0,types:S}),["cs"]);t(x({keywords:O,cStyleComments:!0}),["java"]);t(x({keywords:B,hashComments:!0,multiLineStrings:!0}),["bash","bsh","csh","sh"]);t(x({keywords:Q,hashComments:!0,multiLineStrings:!0,tripleQuotedStrings:!0}),["cv","py","python"]);t(x({keywords:"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END",
      hashComments:!0,multiLineStrings:!0,regexLiterals:2}),["perl","pl","pm"]);t(x({keywords:R,hashComments:!0,multiLineStrings:!0,regexLiterals:!0}),["rb","ruby"]);t(x({keywords:F,cStyleComments:!0,regexLiterals:!0}),["javascript","js","ts","typescript"]);t(x({keywords:"all,and,by,catch,class,else,extends,false,finally,for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,throw,true,try,unless,until,when,while,yes",hashComments:3,cStyleComments:!0,multilineStrings:!0,tripleQuotedStrings:!0,
      regexLiterals:!0}),["coffee"]);t(G([],[["str",/^[\s\S]+/]]),["regex"]);var Y=D.PR={createSimpleLexer:G,registerLangHandler:t,sourceDecorator:x,PR_ATTRIB_NAME:"atn",PR_ATTRIB_VALUE:"atv",PR_COMMENT:"com",PR_DECLARATION:"dec",PR_KEYWORD:"kwd",PR_LITERAL:"lit",PR_NOCODE:"nocode",PR_PLAIN:"pln",PR_PUNCTUATION:"pun",PR_SOURCE:"src",PR_STRING:"str",PR_TAG:"tag",PR_TYPE:"typ",prettyPrintOne:D.prettyPrintOne=function(a,d,f){f=f||!1;d=d||null;var c=document.createElement("div");c.innerHTML="<pre>"+a+"</pre>";
      c=c.firstChild;f&&L(c,f,!0);M({j:d,m:f,h:c,l:1,a:null,i:null,c:null,g:null});return c.innerHTML},prettyPrint:D.prettyPrint=function(a,d){function f(){for(var c=D.PR_SHOULD_USE_CONTINUATION?b.now()+250:Infinity;p<x.length&&b.now()<c;p++){for(var d=x[p],l=g,n=d;n=n.previousSibling;){var m=n.nodeType,u=(7===m||8===m)&&n.nodeValue;if(u?!/^\??prettify\b/.test(u):3!==m||/\S/.test(n.nodeValue))break;if(u){l={};u.replace(/\b(\w+)=([\w:.%+-]+)/g,function(a,b,c){l[b]=c});break}}n=d.className;if((l!==g||r.test(n))&&
      !e.test(n)){m=!1;for(u=d.parentNode;u;u=u.parentNode)if(v.test(u.tagName)&&u.className&&r.test(u.className)){m=!0;break}if(!m){d.className+=" prettyprinted";m=l.lang;if(!m){var m=n.match(w),q;!m&&(q=V(d))&&z.test(q.tagName)&&(m=q.className.match(w));m&&(m=m[1])}if(B.test(d.tagName))u=1;else var u=d.currentStyle,y=t.defaultView,u=(u=u?u.whiteSpace:y&&y.getComputedStyle?y.getComputedStyle(d,null).getPropertyValue("white-space"):0)&&"pre"===u.substring(0,3);y=l.linenums;(y="true"===y||+y)||(y=(y=n.match(/\blinenums\b(?::(\d+))?/))?
      y[1]&&y[1].length?+y[1]:!0:!1);y&&L(d,y,u);M({j:m,h:d,m:y,l:u,a:null,i:null,c:null,g:null})}}}p<x.length?D.setTimeout(f,250):"function"===typeof a&&a()}for(var c=d||document.body,t=c.ownerDocument||document,c=[c.getElementsByTagName("pre"),c.getElementsByTagName("code"),c.getElementsByTagName("xmp")],x=[],q=0;q<c.length;++q)for(var l=0,n=c[q].length;l<n;++l)x.push(c[q][l]);var c=null,b=Date;b.now||(b={now:function(){return+new Date}});var p=0,w=/\blang(?:uage)?-([\w.]+)(?!\S)/,r=/\bprettyprint\b/,
      e=/\bprettyprinted\b/,B=/pre|xmp/i,z=/^code$/i,v=/^(?:pre|code|xmp)$/i,g={};f()}},H=D.define;"function"===typeof H&&H.amd&&H("google-code-prettify",[],function(){return Y})})();}()
      
   </script>

   <script type="text/javascript">
      /*
      
       Copyright (C) 2008 Google Inc.
      
       Licensed under the Apache License, Version 2.0 (the "License");
       you may not use this file except in compliance with the License.
       You may obtain a copy of the License at
      
          http://www.apache.org/licenses/LICENSE-2.0
      
       Unless required by applicable law or agreed to in writing, software
       distributed under the License is distributed on an "AS IS" BASIS,
       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       See the License for the specific language governing permissions and
       limitations under the License.
      */
      PR.registerLangHandler(PR.createSimpleLexer([["pln",/^[\t\n\r \xA0]+/,null,"\t\n\r \u00a0"],["str",/^(?:\"(?:[^\"\\]|\\[\s\S])*(?:\"|$)|\'(?:[^\'\\]|\\[\s\S])*(?:\'|$))/,null,"\"'"]],[["com",/^--(?:\[(=*)\[[\s\S]*?(?:\]\1\]|$)|[^\r\n]*)/],["str",/^\[(=*)\[[\s\S]*?(?:\]\1\]|$)/],["kwd",/^(?:and|break|do|else|elseif|end|false|for|function|if|in|local|nil|not|or|repeat|return|then|true|until|while)\b/,null],["lit",/^[+-]?(?:0x[\da-f]+|(?:(?:\.\d+|\d+(?:\.\d*)?)(?:e[+\-]?\d+)?))/i],
      ["pln",/^[a-z_]\w*/i],["pun",/^[^\w\t\n\r \xA0][^\w\t\n\r \xA0\"\'\-\+=]*/]]),["lua"]);
      
   </script>

   <script type="text/javascript">
      function initialize() {
      
         const LOCAL_STORAGE_KEY = "luacov_report_visible_ids";
      
         let visibleIDs;
      
         if (localStorage) {
            visibleIDs = localStorage.getItem(LOCAL_STORAGE_KEY);
         }
         if (!visibleIDs) {
            visibleIDs = []
         } else {
            visibleIDs = JSON.parse(visibleIDs);
         }
      
         function save() {
            if (localStorage) {
               localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(visibleIDs));
            }
         }
      
         function show(id) {
            let classList = document.getElementById(id).classList;
            if (classList.contains('hidden')) {
               classList.remove("hidden");
               if (visibleIDs.indexOf(id) < 0) {
                  visibleIDs.push(id);
                  save();
               }
            }
         }
      
         function hide(id) {
            let classList = document.getElementById(id).classList;
            if (!classList.contains('hidden')) {
               classList.add("hidden");
               if (visibleIDs.indexOf(id) >= 0) {
                  visibleIDs.splice(visibleIDs.indexOf(id), 1);
                  save();
               }
            }
         }
      
         const fileHeaders = Array.prototype.slice.call(document.getElementsByTagName("h2"));
         fileHeaders.forEach(function (h2) {
            let div = h2.parentElement;
            let id = div.getAttribute("id");
            h2.onclick = function () {
               if (div.classList.contains('hidden')) {
                  show(id)
               } else {
                  hide(id)
               }
            }
         });
      
         let changed;
         visibleIDs.forEach((id) => {
            if (!document.getElementById(id)) {
               changed = true;
               visibleIDs.splice(visibleIDs.indexOf(id), 1);
            } else {
               show(id);
            }
         });
         if (changed) {
            save();
         }
      
         prettyPrint()
      }
      
   </script>

</body>
</html>
