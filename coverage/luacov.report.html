<!doctype html>
<html lang="en">
<head>
   <meta charset="utf-8" />
   <title>Code coverage report</title>
   <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/>
   <link rel="shortcut icon" type="image/png" sizes="16x16" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAFo9M/3AAAACXBIWXMAAADsAAAA7AF5KHG9AAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAYBJREFUOI2tkjtLA0EUhb+JjxQ+qhGtBAtbG0GJFj5rsfQXWKUUQau7QoRIUFBRyG8QBNuABhFNoY12dopso43iM2iuxe7ETXwQxQMLM3funnPumYFKiJaXJtiZyfJRJnOo4I0ZAOujAKc9fAlvDkStXSoAxEAXAW5uHvsdYZ/1Ud+iIqImYiIGTEBTDh4SQA7ExCIO34Bt1Zn7dHo8B03NoeGgwfpS5nL2skmhLCESmfOPWOgFb+TDk9yGc7pC6bilpWF3eflIId4FtDn1rfAP9by8qqqCPDpeA/IMxD9LinESqyJgfcH6ggj4VvBtcCMxkNmfrBv4PgMRMXW1RQCwGof+HRjehJEXyBcA6qs4p4A00BkpPgEbcLcGJIBW0FFgJdKzkAApubjcl0rtq0OQr2SqfYUjDJ0AzdWHhcIVr68lDg4uSaX2KRbfBmA0D3sXrse9pnOgW6T2RCAIMcygcRCKZ0D7+vRnlmRWmF6vrGeTwT58S/PXIB2/0/8nvAPwp5kuNmMrGQAAAABJRU5ErkJggg==" />

   <style>
      @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono&display=swap');
      
      html {
          height: 100%;
      }
      
      body {
          position: relative;
          margin: 0;
          font-family: 'Roboto Mono', monospace;
          display: flex;
          flex-direction: column;
          min-height: 100%;
      }
      
      main {
          flex: 1 0 auto;
      }
      
      footer {
          flex-shrink: 0;
          font-size: 12px;
          color: #808080;
          width: 100%;
          height: 30px;
          line-height: 30px;
          text-align: center;
      }
      
      .pln {
          color: #000
      }
      
      @media screen {
          .str {
              color: #080
          }
      
          .kwd {
              color: #008
          }
      
          .com {
              color: #800
          }
      
          .typ {
              color: #606
          }
      
          .lit {
              color: #066
          }
      
          .clo, .opn, .pun {
              color: #660
          }
      
          .tag {
              color: #008
          }
      
          .atn {
              color: #606
          }
      
          .atv {
              color: #080
          }
      
          .dec, .var {
              color: #606
          }
      
          .fun {
              color: red
          }
      }
      
      @media print, projection {
          .kwd, .tag, .typ {
              font-weight: 700
          }
      
          .str {
              color: #060
          }
      
          .kwd {
              color: #006
          }
      
          .com {
              color: #600;
              font-style: italic
          }
      
          .typ {
              color: #404
          }
      
          .lit {
              color: #044
          }
      
          .clo, .opn, .pun {
              color: #440
          }
      
          .tag {
              color: #006
          }
      
          .atn {
              color: #404
          }
      
          .atv {
              color: #060
          }
      }
      
      pre.prettyprint {
          padding: 0;
          margin: 0;
          border: 0;
          border-bottom: 1px solid #808080;
      }
      
      .file.hidden pre.prettyprint {
          display: none;
      }
      
      ol.linenums {
          margin-top: 0;
          margin-bottom: 0;
          counter-reset: number;
          list-style-type: none;
      }
      
      pre.prettyprint ol {
          margin: 0;
          padding: 0;
      }
      
      pre.prettyprint li {
          font-size: 14px;
          word-wrap: normal;
          white-space: pre;
          line-height: 20px;
      }
      
      pre.prettyprint li::before {
          counter-increment: number;
          content: counter(number) "\a0";
          float: left;
          position: relative;
          width: 1%;
          min-width: 50px;
          padding-right: 10px;
          padding-left: 10px;
          font-size: 12px;
          color: #6E7781;
          text-align: right;
          white-space: nowrap;
          vertical-align: top;
          line-height: 20px;
      }
      
      pre.prettyprint span.fc {
          background-color: #DFF0D8;
          display: block;
      }
      
      pre.prettyprint span.fc:before {
          content: attr(data-hits);
          position: absolute;
          left: 0;
          width: 30px;
          margin-left: 5px;
          text-align: center;
          font-size: 10px;
          color: #808080;
      }
      
      pre.prettyprint span.nc {
          background-color: #F2DEDE;
          display: block;
      }
      
      pre.prettyprint span.pc {
          background-color: #FFFFCC;
          display: block;
      }
      
      pre.prettyprint span.bpc:hover {
          background-color: #FFFF80;
      }
      
      pre.prettyprint span.hits {
          position: absolute;
          left: 0;
          width: 30px;
          margin-left: 5px;
          text-align: center;
          font-size: 10px;
      }
      
      
      .file .title {
          border-bottom: 1px solid #808080;
          border-left: 0;
          border-right: 0;
          padding: 0.67em;
          margin: 0;
          position: relative;
      }
      
      .file:not(.total) .title {
          cursor: pointer;
      }
      
      .file:not(.total) .title:before {
          content: "";
          display: block;
          width: 100%;
          height: 100%;
          position: absolute;
          left: 0;
          right: 0;
          bottom: 0;
          top: 0;
          background: #fff;
          opacity: 0.0;
          transition: all 200ms;
      }
      
      .file:not(.total) .title:not(.total):hover:before {
          opacity: 0.3;
      }
      
      .file.danger .title {
          background: #F2DEDE;
      }
      
      .file.warning .title {
          background: #FCF8E3;
      }
      
      .file.success-low .title {
          background: #DFF0D8;
      }
      
      .file.success-medium .title {
          background: #C3E3B5;
      }
      
      .file.success-high .title {
          background: #99CB84;
      }
      
      .file .title .stats {
          font-size: 12px;
          line-height: 12px;
          color: #444;
          margin-top: 2px;
          display: flex;
      }
      
      .file .title .stats .hits,
      .file .title .stats .cov,
      .file .title .stats .miss {
          padding: 2px 6px;
          border-radius: 12px;
          border: 1px solid #808080;
          position: relative;
          margin-right: 10px;
      }
      
      .file .title .stats .hits {
          background: #DFF0D8;
      }
      
      .file .title .stats .cov {
          background: #F2DEDE;
          overflow: hidden;
      }
      
      .file .title .stats .cov span {
          position: relative;
      }
      
      .file .title .stats .cov .bg {
          height: 100%;
          position: absolute;
          left: 0;
          top: 0;
          background-color: #DFF0D8;
      }
      
      .file .title .stats .miss {
          background: #F2DEDE;
      }
      
   </style>

</head>
<body onload="initialize()">
   <main>
      <div class="file success-medium total">
         <h1 class="title">
            Code coverage report
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 81.83%"></span>
                  <span><strong>81.83%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>923</strong> Hits</span>
               <span class="miss"><strong>205</strong> Missed</span>
            </span>
         </h1>
      </div>

      <div class="hidden file success-high" id="src-configurator">
         <h2 class="title">
            src/configurator.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 100.00%"></span>
                  <span><strong>100.00%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>44</strong> Hits</span>
               <span class="miss"><strong>0</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums"><span class="fc" data-hits="1">local json = require(&#39;json&#39;)</span>
<span class="fc" data-hits="1">local configurator = require(&#39;modules.configurator&#39;)</span>
<span class="fc" data-hits="1">local configuratorValidation = require(&#39;modules.configuratorValidation&#39;)</span>

---------------------------------------------------------------------------------
-- CONFIGURATOR -----------------------------------------------------------------
---------------------------------------------------------------------------------
<span class="fc" data-hits="1">Env = &#39;DEV&#39;</span>
<span class="fc" data-hits="1">Version = &#39;1.0.1&#39;</span>
-- @dev Reset state on load while in DEV mode
<span class="fc" data-hits="1">if not Configurator or Env == &#39;DEV&#39; then Configurator = configurator:new(Env) end</span>

---------------------------------------------------------------------------------
-- READ HANDLER -----------------------------------------------------------------
---------------------------------------------------------------------------------

-- Info
<span class="fc" data-hits="2">Handlers.add(&quot;Info&quot;, Handlers.utils.hasMatchingTag(&quot;Action&quot;, &quot;Info&quot;), function(msg)</span>
<span class="fc" data-hits="2">  return msg.reply({</span>
<span class="fc" data-hits="1">    Admin = Configurator.admin,</span>
<span class="fc" data-hits="1">    Delay = Configurator.delay,</span>
<span class="fc" data-hits="1">    Staged = json.encode(Configurator.staged)</span>
  })
end)

---------------------------------------------------------------------------------
-- GENERAL WRITE HANDLERS -------------------------------------------------------
---------------------------------------------------------------------------------

-- Stage Update
<span class="fc" data-hits="2">Handlers.add(&quot;Stage-Update&quot;, Handlers.utils.hasMatchingTag(&quot;Action&quot;, &quot;Stage-Update&quot;), function(msg)</span>
<span class="fc" data-hits="3">  configuratorValidation.updateProcess(msg)</span>
<span class="fc" data-hits="3">  local updateTags = msg.Tags.UpdateTags or &quot;&quot;</span>
<span class="fc" data-hits="3">  local updateData = msg.Tags.UpdateData or &quot;&quot;</span>
<span class="fc" data-hits="3">  return Configurator:stageUpdate(msg.Tags.UpdateProcess, msg.Tags.UpdateAction, updateTags, updateData, msg)</span>
end)

-- Unstage Update
<span class="fc" data-hits="2">Handlers.add(&quot;Unstage-Update&quot;, Handlers.utils.hasMatchingTag(&quot;Action&quot;, &quot;Unstage-Update&quot;), function(msg)</span>
<span class="fc" data-hits="1">  configuratorValidation.updateProcess(msg)</span>
<span class="fc" data-hits="1">  local updateTags = msg.Tags.UpdateTags or &quot;&quot;</span>
<span class="fc" data-hits="1">  local updateData = msg.Tags.UpdateData or &quot;&quot;</span>
<span class="fc" data-hits="1">  return Configurator:unstageUpdate(msg.Tags.UpdateProcess, msg.Tags.UpdateAction, updateTags, updateData, msg)</span>
end)

-- Action Update
<span class="fc" data-hits="2">Handlers.add(&quot;Action-Update&quot;, Handlers.utils.hasMatchingTag(&quot;Action&quot;, &quot;Action-Update&quot;), function(msg)</span>
<span class="fc" data-hits="1">  configuratorValidation.updateProcess(msg)</span>
<span class="fc" data-hits="1">  local updateTags = msg.Tags.UpdateTags or &quot;&quot;</span>
<span class="fc" data-hits="1">  local updateData = msg.Tags.UpdateData or &quot;&quot;</span>
<span class="fc" data-hits="1">  return Configurator:actionUpdate(msg.Tags.UpdateProcess, msg.Tags.UpdateAction, updateTags, updateData, msg)</span>
end)

---------------------------------------------------------------------------------
-- ADMIN WRITE HANDLERS ---------------------------------------------------------
---------------------------------------------------------------------------------

-- Stage Update Admin
<span class="fc" data-hits="2">Handlers.add(&quot;Stage-Update-Admin&quot;, Handlers.utils.hasMatchingTag(&quot;Action&quot;, &quot;Stage-Update-Admin&quot;), function(msg)</span>
<span class="fc" data-hits="3">  configuratorValidation.updateAdmin(msg)</span>
<span class="fc" data-hits="3">  return Configurator:stageUpdateAdmin(msg.Tags.UpdateAdmin, msg)</span>
end)

-- Unstage Update Admin
<span class="fc" data-hits="2">Handlers.add(&quot;Unstage-Update-Admin&quot;, Handlers.utils.hasMatchingTag(&quot;Action&quot;, &quot;Unstage-Update-Admin&quot;), function(msg)</span>
<span class="fc" data-hits="1">  configuratorValidation.updateAdmin(msg)</span>
<span class="fc" data-hits="1">  return Configurator:unstageUpdateAdmin(msg.Tags.UpdateAdmin, msg)</span>
end)

-- Action Update Admin
<span class="fc" data-hits="2">Handlers.add(&quot;Action-Update-Admin&quot;, Handlers.utils.hasMatchingTag(&quot;Action&quot;, &quot;Action-Update-Admin&quot;), function(msg)</span>
<span class="fc" data-hits="1">  configuratorValidation.updateAdmin(msg)</span>
<span class="fc" data-hits="1">  return Configurator:actionUpdateAdmin(msg.Tags.UpdateAdmin, msg)</span>
end)

---------------------------------------------------------------------------------
-- DELAY WRITE HANDLERS ---------------------------------------------------------
---------------------------------------------------------------------------------

-- Stage Update DelayTime
<span class="fc" data-hits="2">Handlers.add(&quot;Stage-Update-Delay&quot;, Handlers.utils.hasMatchingTag(&quot;Action&quot;, &quot;Stage-Update-Delay&quot;), function(msg)</span>
<span class="fc" data-hits="3">  configuratorValidation.updateDelay(msg)</span>
<span class="fc" data-hits="3">  return Configurator:stageUpdateDelay(msg.Tags.UpdateDelay, msg)</span>
end)

-- Unstage Update DelayTime
<span class="fc" data-hits="2">Handlers.add(&quot;Unstage-Update-Delay&quot;, Handlers.utils.hasMatchingTag(&quot;Action&quot;, &quot;Unstage-Update-Delay&quot;), function(msg)</span>
<span class="fc" data-hits="1">  configuratorValidation.updateDelay(msg)</span>
<span class="fc" data-hits="1">  return Configurator:unstageUpdateDelay(msg.Tags.UpdateDelay, msg)</span>
end)

-- Action Update DelayTime
<span class="fc" data-hits="2">Handlers.add(&quot;Action-Update-Delay&quot;, Handlers.utils.hasMatchingTag(&quot;Action&quot;, &quot;Action-Update-Delay&quot;), function(msg)</span>
<span class="fc" data-hits="1">  configuratorValidation.updateDelay(msg)</span>
<span class="fc" data-hits="1">  return Configurator:actionUpdateDelay(msg.Tags.UpdateDelay, msg)</span>
end)
</pre>
      </div>

      <div class="hidden file warning" id="src-modules-conditionaltokens">
         <h2 class="title">
            src/modules/conditionalTokens.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 57.69%"></span>
                  <span><strong>57.69%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>60</strong> Hits</span>
               <span class="miss"><strong>44</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums">-- reference: https:&#47;&#47;github.com&#47;gnosis&#47;conditional-tokens-contracts&#47;blob&#47;master&#47;contracts&#47;ConditionalTokens.sol
<span class="fc" data-hits="2">local ao = require(&#39;.ao&#39;)</span>
<span class="fc" data-hits="2">local json = require(&#39;json&#39;)</span>
<span class="fc" data-hits="2">local bint = require(&#39;.bint&#39;)(256)</span>
<span class="fc" data-hits="2">local crypto = require(&#39;.crypto&#39;)</span>
<span class="fc" data-hits="2">local semiFungibleTokens = require(&#39;modules.semiFungibleTokens&#39;)</span>

<span class="fc" data-hits="2">local SemiFungibleTokens = {}</span>
<span class="fc" data-hits="2">local ConditionalTokens = {}</span>
<span class="fc" data-hits="2">local ConditionalTokensMethods = require(&#39;modules.conditionalTokensNotices&#39;)</span>

-- Constructor for ConditionalTokens 
<span class="fc" data-hits="2">function ConditionalTokens:new()</span>
  -- Initialize SemiFungibleTokens and store the object
<span class="fc" data-hits="15">  SemiFungibleTokens = semiFungibleTokens:new()</span>

  -- Create a new ConditionalTokens object
<span class="fc" data-hits="15">  local obj = {</span>
    -- SemiFungible Tokens
<span class="fc" data-hits="15">    tokens = SemiFungibleTokens,</span>
<span class="fc" data-hits="15">    conditionId = &#39;&#39;,</span>
<span class="fc" data-hits="15">    outcomeSlotCount = nil,</span>
<span class="fc" data-hits="15">    positionIds = {},</span>
<span class="fc" data-hits="15">    payoutNumerators = {},</span>
<span class="fc" data-hits="15">    payoutDenominator = {},</span>
    -- Take Fee vars
<span class="fc" data-hits="15">    creatorFee = 0,</span>
<span class="fc" data-hits="15">    creatorFeeTarget = &#39;&#39;,</span>
<span class="fc" data-hits="15">    protocolFee = 0,</span>
<span class="fc" data-hits="15">    protocolFeeTarget = &#39;&#39;</span>
  }

  -- Set metatable for method lookups from ConditionalTokensMethods, SemiFungibleTokensMethods, and ConditionalTokensHelpers
<span class="fc" data-hits="30">  setmetatable(obj, {</span>
    __index = function(t, k)
      -- First, look up the key in ConditionalTokensMethods
<span class="fc" data-hits="31">      if ConditionalTokensMethods[k] then</span>
<span class="fc" data-hits="30">        return ConditionalTokensMethods[k]</span>
      -- Lastly, look up the key in the semiFungibleInstance methods
<span class="fc" data-hits="1">      elseif SemiFungibleTokens[k] then</span>
<span class="nc">        return SemiFungibleTokens[k]</span>
      else
<span class="fc" data-hits="1">        return nil</span>
      end
    end
  })
<span class="fc" data-hits="15">  return obj</span>
end

-- @dev This function prepares a condition by initializing a payout vector associated with the condition.
-- @param conditionId The condition&#39;s ID. This ID may be derived from the other three parameters via ``keccak256(abi.encodePacked(questionId, resolutionAgent, outcomeSlotCount))``.
-- @param outcomeSlotCount The number of outcome slots which should be used for this condition. Must not exceed 256.
<span class="fc" data-hits="2">function ConditionalTokensMethods:prepareCondition(conditionId, outcomeSlotCount, msg)</span>
<span class="fc" data-hits="7">  assert(self.payoutNumerators[conditionId] == nil, &quot;condition already prepared&quot;)</span>
  -- Initialize the payout vector associated with the condition.
<span class="fc" data-hits="7">  self.payoutNumerators[conditionId] = {}</span>
<span class="fc" data-hits="27">  for _ = 1, outcomeSlotCount do</span>
<span class="fc" data-hits="20">    table.insert(self.payoutNumerators[conditionId], 0)</span>
  end
  -- Initialize the denominator to zero to indicate that the condition has not been resolved.
<span class="fc" data-hits="7">  self.payoutDenominator[conditionId] = 0</span>
  -- Send the condition preparation notice.
<span class="fc" data-hits="7">  return self.conditionPreparationNotice(conditionId, outcomeSlotCount, msg)</span>
end

-- @dev This function splits a position from collateral. This contract will attempt to transfer `amount` collateral from the message sender to itself. 
-- If successful, `quantity` stake will be minted in the split target positions. If any of the transfers, mints, or burns fail, the transaction will revert.
-- @param from The initiator of the original Split-Position &#47; Create-Position action message.
-- @param collateralToken The address of the positions&#39; backing collateral token.
-- @param quantity The quantity of collateral or stake to split.
-- @param msg Msg passed to retrieve x-tags
<span class="fc" data-hits="2">function ConditionalTokensMethods:splitPosition(from, collateralToken, quantity, msg)</span>
<span class="fc" data-hits="5">  assert(self.payoutNumerators[self.conditionId] and #self.payoutNumerators[self.conditionId] &gt; 0, &quot;Condition not prepared!&quot;)</span>
  -- Create equal split positions.
<span class="fc" data-hits="4">  local quantities = {}</span>
<span class="fc" data-hits="16">  for _ = 1, #self.positionIds do</span>
<span class="fc" data-hits="12">    table.insert(quantities, quantity)</span>
  end
  -- Mint the stake in the split target positions.
<span class="fc" data-hits="4">  SemiFungibleTokens:batchMint(from, self.positionIds, quantities, msg)</span>
  -- Send notice.
<span class="fc" data-hits="4">  return self.positionSplitNotice(from, collateralToken, self.conditionId, quantity, msg)</span>
end

-- @dev This function merges positions. If merging to the collateral, this contract will attempt to transfer `quantity` collateral to the message sender.
-- Otherwise, this contract will burn `quantity` stake held by the message sender in the positions being merged worth of semi-fungible tokens.
-- If successful, `quantity` stake will be minted in the merged position. If any of the transfers, mints, or burns fail, the transaction will revert.
-- @param from The initiator of the original Merge-Positions action message.
-- @param onBehalfOf The address that will receive the collateral.
-- @param quantity The quantity of collateral or stake to merge.
-- @param msg Msg passed to retrieve x-tags
<span class="fc" data-hits="2">function ConditionalTokensMethods:mergePositions(from, onBehalfOf, quantity, isSell, msg)</span>
<span class="fc" data-hits="5">  assert(self.payoutNumerators[self.conditionId] and #self.payoutNumerators[self.conditionId] &gt; 0, &quot;Condition not prepared!&quot;)</span>
  -- Create equal merge positions.
<span class="fc" data-hits="4">  local quantities = {}</span>
<span class="fc" data-hits="16">  for _ = 1, #self.positionIds do</span>
<span class="fc" data-hits="12">    table.insert(quantities, quantity)</span>
  end
  -- Burn equal quantiies from user positions.
<span class="fc" data-hits="4">  self.tokens:batchBurn(from, self.positionIds, quantities, msg)</span>
  -- @dev below already handled within the sell method. 
  -- sell method w&#47; a different quantity and recipient.
<span class="fc" data-hits="2">  if not isSell then</span>
    -- Return the collateral to the user.
<span class="fc" data-hits="2">    ao.send({</span>
<span class="fc" data-hits="1">      Target = self.collateralToken,</span>
<span class="fc" data-hits="1">      Action = &quot;Transfer&quot;,</span>
<span class="fc" data-hits="1">      Quantity = quantity,</span>
<span class="fc" data-hits="1">      Recipient = onBehalfOf</span>
    })
  end
  -- Send notice.
<span class="fc" data-hits="2">  return self.positionsMergeNotice(self.conditionId, quantity, msg)</span>
end

-- @dev Called by the resolutionAgent for reporting results of conditions. Will set the payout vector for the condition with the ID `keccak256(resolutionAgent .. questionId .. tostring(outcomeSlotCount))`, 
-- where ResolutionAgent is the message sender, QuestionId is one of the parameters of this function, and OutcomeSlotCount is the length of the payouts parameter, which contains the payoutNumerators for each outcome slot of the condition.
-- @param QuestionId The question ID the oracle is answering for
-- @param Payouts The oracle&#39;s answer
<span class="fc" data-hits="2">function ConditionalTokensMethods:reportPayouts(questionId, payouts, msg)</span>
  -- IMPORTANT, the payouts length accuracy is enforced because outcomeSlotCount is part of the hash.
<span class="nc">  local outcomeSlotCount = #payouts</span>
<span class="nc">  assert(outcomeSlotCount &gt; 1, &quot;there should be more than one outcome slot&quot;)</span>
  -- IMPORTANT, the resolutionAgent is enforced to be the sender because it&#39;s part of the hash.
<span class="nc">  local conditionId = self.getConditionId(msg.From, questionId, tostring(outcomeSlotCount))</span>
<span class="nc">  assert(self.payoutNumerators[conditionId] and #self.payoutNumerators[conditionId] == outcomeSlotCount, &quot;condition not prepared or found&quot;)</span>
<span class="nc">  assert(self.payoutDenominator[conditionId] == 0, &quot;payout denominator already set&quot;)</span>
  -- Set the payout vector for the condition.
<span class="nc">  local den = 0</span>
<span class="nc">  for i = 1, outcomeSlotCount do</span>
<span class="nc">    local num = payouts[i]</span>
<span class="nc">    den = den + num</span>
<span class="nc">    assert(self.payoutNumerators[conditionId][i] == 0, &quot;payout numerator already set&quot;)</span>
<span class="nc">    self.payoutNumerators[conditionId][i] = num</span>
  end
<span class="nc">  assert(den &gt; 0, &quot;payout is all zeroes&quot;)</span>
<span class="nc">  self.payoutDenominator[conditionId] = den</span>
  -- Send the condition resolution notice.
<span class="nc">  return self.conditionResolutionNotice(conditionId, msg.From, questionId, outcomeSlotCount, self.payoutNumerators[conditionId], msg)</span>
end

-- @dev This function redeems positions. If redeeming to the collateral, this contract will attempt to transfer the payout to the message sender.
-- Otherwise, this contract will burn the stake held by the message sender in the positions being redeemed worth of semi-fungible tokens.
-- If successful, the payout will be minted in the parent position. If any of the transfers, mints, or burns fail, the transaction will revert.
-- @param from The initiator of the original Redeem-Positions action message.
-- @param collateralToken The address of the positions&#39; backing collateral token.
-- @param parentCollectionId The ID of the outcome collections common to the positions being redeemed and the parent position. May be null, in which only the collateral is shared.
-- @param conditionId The ID of the condition to redeem on.
-- @param indexSets An array of index sets representing the outcome slots of the given condition. E.g. A|B and C but not A|B and B|C (is not disjoint). Each element&#39;s a number which, together with the condition, represents the outcome collection. E.g. 0b110 is A|B, 0b010 is B, etc.
<span class="fc" data-hits="2">function ConditionalTokensMethods:redeemPositions(msg)</span>
<span class="nc">  local den = self.payoutDenominator[self.conditionId]</span>
<span class="nc">  assert(den &gt; 0, &quot;result for condition not received yet&quot;)</span>
<span class="nc">  assert(self.payoutNumerators[self.conditionId] and #self.payoutNumerators[self.conditionId] &gt; 0, &quot;condition not prepared yet&quot;)</span>
<span class="nc">  local totalPayout = 0</span>
<span class="nc">  for i = 1, #self.positionIds do</span>
<span class="nc">    local positionId = self.positionIds[i]</span>
<span class="nc">    local payoutNumerator = self.payoutNumerators[self.conditionId][tonumber(positionId)]</span>

    -- Get the stake to redeem.
<span class="nc">    if not self.tokens.balancesById[positionId] then self.tokens.balancesById[positionId] = {} end</span>
<span class="nc">    if not self.tokens.balancesById[positionId][msg.From] then self.tokens.balancesById[positionId][msg.From] = &quot;0&quot; end</span>
<span class="nc">    local payoutStake = self.tokens.balancesById[positionId][msg.From]</span>
<span class="nc">    assert(bint.__lt(0, bint(payoutStake)), &quot;no stake to redeem&quot;)</span>
    -- Calculate the payout and burn position.
<span class="nc">    totalPayout = math.floor(totalPayout + (payoutStake * payoutNumerator) &#47; den)</span>
<span class="nc">    self:burn(msg.From, positionId, payoutStake, msg)</span>
  end
  -- Return totla payout minus take fee.
<span class="nc">  if totalPayout &gt; 0 then</span>
<span class="nc">    totalPayout = math.floor(totalPayout)</span>
<span class="nc">    self:returnTotalPayoutMinusTakeFee(self.collateralToken, msg.From, totalPayout)</span>
  end
  -- Send notice.
<span class="nc">  return self.payoutRedemptionNotice(self.collateralToken, self.conditionId, totalPayout, msg)</span>
end

-- @dev Gets the outcome slot count of a condition.
-- @param ConditionId ID of the condition.
-- @return Number of outcome slots associated with a condition, or zero if condition has not been prepared yet.
<span class="fc" data-hits="2">function ConditionalTokensMethods:getOutcomeSlotCount(msg)</span>
<span class="nc">  assert(msg.Tags.ConditionId, &quot;ConditionId is required!&quot;)</span>
<span class="nc">  return self.payoutNumerators[msg.Tags.ConditionId] and #self.payoutNumerators[msg.Tags.ConditionId] or 0</span>
end

-- @dev Constructs a condition ID from a resolutionAgent, a question ID, and the outcome slot count for the question.
-- @param ResolutionAgent The process assigned to report the result for the prepared condition.
-- @param QuestionId An identifier for the question to be answered by the resolutionAgent.
-- @param OutcomeSlotCount The number of outcome slots which should be used for this condition. Must not exceed 256.
<span class="fc" data-hits="2">function ConditionalTokensMethods.getConditionId(resolutionAgent, questionId, outcomeSlotCount)</span>
<span class="nc">  return crypto.digest.keccak256(resolutionAgent .. questionId .. outcomeSlotCount).asHex()</span>
end

<span class="fc" data-hits="2">function ConditionalTokensMethods:returnTotalPayoutMinusTakeFee(collateralToken, from, totalPayout)</span>
<span class="nc">  local protocolFee =  tostring(bint.ceil(bint.__div(bint.__mul(totalPayout, self.protocolFee), 1e4)))</span>
<span class="nc">  local creatorFee =  tostring(bint.ceil(bint.__div(bint.__mul(totalPayout, self.creatorFee), 1e4)))</span>
<span class="nc">  local takeFee = tostring(bint.__add(bint(creatorFee), bint(protocolFee)))</span>
<span class="nc">  local totalPayoutMinusFee = tostring(bint.__sub(totalPayout, bint(takeFee)))</span>
  -- prepare txns
<span class="nc">  local protocolFeeTxn = {</span>
    Target = collateralToken,
    Action = &quot;Transfer&quot;,
    Recipient = self.protocolFeeTarget,
    Quantity = protocolFee,
  }
<span class="nc">  local creatorFeeTxn = {</span>
    Target = collateralToken,
    Action = &quot;Transfer&quot;,
    Recipient = self.creatorFeeTarget,
    Quantity = creatorFee,
  }
<span class="nc">  local totalPayoutMinutTakeFeeTxn = {</span>
    Target = collateralToken,
    Action = &quot;Transfer&quot;,
    Recipient = from,
<span class="nc">    Quantity = totalPayoutMinusFee</span>
  }
  -- send txns
<span class="nc">  return { ao.send(protocolFeeTxn), ao.send(creatorFeeTxn), ao.send(totalPayoutMinutTakeFeeTxn) }</span>
end

<span class="fc" data-hits="2">return ConditionalTokens</span>
</pre>
      </div>

      <div class="hidden file success-high" id="src-modules-conditionaltokensnotices">
         <h2 class="title">
            src/modules/conditionalTokensNotices.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 100.00%"></span>
                  <span><strong>100.00%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>41</strong> Hits</span>
               <span class="miss"><strong>0</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums"><span class="fc" data-hits="3">local ao = require(&#39;.ao&#39;)</span>
<span class="fc" data-hits="3">local json = require(&#39;json&#39;)</span>

<span class="fc" data-hits="3">local ConditionalTokensNotices = {}</span>

-- @dev Emitted upon the successful preparation of a condition.
-- @param sender The address of the account that prepared the condition.
-- @param conditionId The condition&#39;s ID. This ID may be derived from the other three parameters via ``keccak256(abi.encodePacked(questionId, resolutionAgent, outcomeSlotCount))``.
-- @param outcomeSlotCount The number of outcome slots which should be used for this condition. Must not exceed 256.
-- @param msg For sending msg.reply
<span class="fc" data-hits="3">function ConditionalTokensNotices.conditionPreparationNotice(conditionId, outcomeSlotCount, msg)</span>
  -- TODO: Decide if to be sent to user and&#47;or Data Index
<span class="fc" data-hits="16">  return msg.reply({</span>
<span class="fc" data-hits="8">    Action = &quot;Condition-Preparation-Notice&quot;,</span>
<span class="fc" data-hits="8">    ConditionId = conditionId,</span>
<span class="fc" data-hits="8">    OutcomeSlotCount = tostring(outcomeSlotCount)</span>
  })
end

-- @dev Emitted upon the successful condition resolution.
-- @param conditionId The condition&#39;s ID. This ID may be derived from the other three parameters via ``keccak256(abi.encodePacked(questionId, resolutionAgent, outcomeSlotCount))``.
-- @param resolutionAgent The process assigned to report the result for the prepared condition.
-- @param questionId An identifier for the question to be answered by the resolutionAgent.
-- @param outcomeSlotCount The number of outcome slots which should be used for this condition. Must not exceed 256.
-- @param payoutNumerators The payout numerators for each outcome slot.
<span class="fc" data-hits="3">function ConditionalTokensNotices.conditionResolutionNotice(conditionId, resolutionAgent, questionId, outcomeSlotCount, payoutNumerators, msg)</span>
  -- TODO: Decide if to be sent to user and&#47;or Data Index
<span class="fc" data-hits="2">  return msg.reply({</span>
<span class="fc" data-hits="1">    Action = &quot;Condition-Resolution-Notice&quot;,</span>
<span class="fc" data-hits="1">    ConditionId = conditionId,</span>
<span class="fc" data-hits="1">    ResolutionAgent = resolutionAgent,</span>
<span class="fc" data-hits="1">    QuestionId = questionId,</span>
<span class="fc" data-hits="1">    OutcomeSlotCount = tostring(outcomeSlotCount),</span>
<span class="fc" data-hits="1">    PayoutNumerators = json.encode(payoutNumerators)</span>
  })
end

-- @dev Emitted when a position is successfully split.
-- @param from The address of the account that split the position.
-- @param collateralToken The address of the collateral token.
-- @param conditionId The condition ID.
-- @param quantity The quantity.
-- @param msg For sending X-Tags
<span class="fc" data-hits="3">function ConditionalTokensNotices.positionSplitNotice(from, collateralToken, conditionId, quantity, msg)</span>
<span class="fc" data-hits="5">  local notice = {</span>
<span class="fc" data-hits="5">    Action = &quot;Split-Position-Notice&quot;,</span>
<span class="fc" data-hits="5">    Process = ao.id,</span>
<span class="fc" data-hits="5">    Stakeholder = from,</span>
<span class="fc" data-hits="5">    CollateralToken = collateralToken,</span>
<span class="fc" data-hits="5">    ConditionId = conditionId,</span>
<span class="fc" data-hits="5">    Quantity = quantity</span>
  }
  -- Forward tags
<span class="fc" data-hits="29">  for tagName, tagValue in pairs(msg) do</span>
    -- Tags beginning with &quot;X-&quot; are forwarded
<span class="fc" data-hits="24">    if string.sub(tagName, 1, 2) == &quot;X-&quot; then</span>
<span class="fc" data-hits="5">      notice[tagName] = tagValue</span>
    end
  end
  -- Send notice | @dev ao.send vs msg.reply to ensure message is sent to user (not collateralToken)
<span class="fc" data-hits="5">  return msg.forward(from, notice)</span>
end


-- @dev Emitted when positions are successfully merged.
-- @param from The address of the account that merged the positions.
-- @param conditionId The condition ID.
-- @param quantity The quantity.
<span class="fc" data-hits="3">function ConditionalTokensNotices.positionsMergeNotice(conditionId, quantity, msg)</span>
<span class="fc" data-hits="6">  return msg.reply({</span>
<span class="fc" data-hits="3">    Action = &quot;Merge-Positions-Notice&quot;,</span>
<span class="fc" data-hits="3">    ConditionId = conditionId, -- TODO: Check if this is needed</span>
<span class="fc" data-hits="3">    Quantity = quantity</span>
  })
end

-- @dev Emitted when a position is successfully redeemed.
-- @param redeemer The address of the account that redeemed the position.
-- @param collateralToken The address of the collateral token.
-- @param conditionId The condition ID.
-- @param payout The payout amount.
<span class="fc" data-hits="3">function ConditionalTokensNotices.payoutRedemptionNotice(collateralToken, conditionId, payout, msg)</span>
  -- TODO: Decide if to be sent to user and&#47;or Data Index
<span class="fc" data-hits="2">  return msg.reply({</span>
<span class="fc" data-hits="1">    Action = &quot;Payout-Redemption-Notice&quot;,</span>
<span class="fc" data-hits="1">    Process = ao.id,</span>
<span class="fc" data-hits="1">    CollateralToken = collateralToken,</span>
<span class="fc" data-hits="1">    ConditionId = conditionId,</span>
<span class="fc" data-hits="1">    Payout = tostring(payout)</span>
  })
end

<span class="fc" data-hits="3">return ConditionalTokensNotices</span>
</pre>
      </div>

      <div class="hidden file success-high" id="src-modules-conditionaltokensvalidation">
         <h2 class="title">
            src/modules/conditionalTokensValidation.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 100.00%"></span>
                  <span><strong>100.00%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>17</strong> Hits</span>
               <span class="miss"><strong>0</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums"><span class="fc" data-hits="1">local sharedUtils = require(&#39;modules.sharedUtils&#39;)</span>
<span class="fc" data-hits="1">local json = require(&#39;json&#39;)</span>
<span class="fc" data-hits="1">local conditionalTokensValidation = {}</span>

local function validateQuantity(quantity)
<span class="fc" data-hits="6">  assert(type(quantity) == &#39;string&#39;, &#39;Quantity is required!&#39;)</span>
<span class="fc" data-hits="5">  assert(tonumber(quantity), &#39;Quantity must be a number!&#39;)</span>
<span class="fc" data-hits="4">  assert(tonumber(quantity) &gt; 0, &#39;Quantity must be greater than zero!&#39;)</span>
<span class="fc" data-hits="2">  assert(tonumber(quantity) % 1 == 0, &#39;Quantity must be an integer!&#39;)</span>
end

local function validatePayouts(payouts)
<span class="fc" data-hits="4">  assert(payouts, &quot;Payouts is required!&quot;)</span>
<span class="fc" data-hits="3">  assert(sharedUtils.isJSONArray(payouts), &quot;Payouts must be valid JSON Array!&quot;)</span>
<span class="fc" data-hits="3">  for _, payout in ipairs(json.decode(payouts)) do</span>
<span class="fc" data-hits="2">    assert(tonumber(payout), &quot;Payouts item must be a number!&quot;)</span>
  end
end

<span class="fc" data-hits="1">function conditionalTokensValidation.mergePositions(msg)</span>
<span class="fc" data-hits="6">  validateQuantity(msg.Tags.Quantity)</span>
end

<span class="fc" data-hits="1">function conditionalTokensValidation.reportPayouts(msg)</span>
<span class="fc" data-hits="5">  assert(msg.Tags.QuestionId, &quot;QuestionId is required!&quot;)</span>
<span class="fc" data-hits="4">  validatePayouts(msg.Tags.Payouts)</span>
end

<span class="fc" data-hits="1">return conditionalTokensValidation</span>
</pre>
      </div>

      <div class="hidden file success-high" id="src-modules-configurator">
         <h2 class="title">
            src/modules/configurator.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 100.00%"></span>
                  <span><strong>100.00%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>70</strong> Hits</span>
               <span class="miss"><strong>0</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums"><span class="fc" data-hits="2">local json = require(&#39;json&#39;)</span>
<span class="fc" data-hits="2">local crypto = require(&#39;.crypto&#39;)</span>
<span class="fc" data-hits="2">local configuratorNotices = require(&#39;modules.configuratorNotices&#39;)</span>

<span class="fc" data-hits="2">local Configurator = {}</span>

-- Add configurator notices
<span class="fc" data-hits="2">local configuratorMethods = configuratorNotices</span>

-- Constructor for ProcessProvider 
<span class="fc" data-hits="2">function Configurator:new(env)</span>
  -- Create a new configurator object
<span class="fc" data-hits="19">  local obj = {</span>
<span class="fc" data-hits="19">    admin = &#39;m6W6wreOSejTb2WRHoALM6M7mw3H8D2KmFVBYC1l0O0&#39;,  -- Initial Admin Address</span>
<span class="fc" data-hits="19">    delay = env == &quot;DEV&quot; and 1 or 3*24*60*60,               -- Initial Update Delay in Seconds (i.e. 1 second or 3 days)</span>
<span class="fc" data-hits="19">    staged = {},                                            -- Staged Update Timestamps</span>
  }
  -- Set metatable for method lookups
<span class="fc" data-hits="19">  setmetatable(obj, { __index = configuratorMethods })</span>
<span class="fc" data-hits="19">  return obj</span>
end

--[[
    PROTOCOL ----------------------------------------------------------------
]]

--[[
    Stage Update
]]
<span class="fc" data-hits="2">function configuratorMethods:stageUpdate(process, action, tags, data, msg)</span>
<span class="fc" data-hits="7">  local hash = crypto.digest.keccak256(process .. action .. tags .. data).asHex()</span>
  -- stage
<span class="fc" data-hits="7">  self.staged[hash] = os.time()</span>
  -- stage notice
<span class="fc" data-hits="7">  return self.stageUpdateNotice(process, action, tags, data, hash, self.staged[hash], msg)</span>
end

--[[
    Unstage Update
]]
<span class="fc" data-hits="2">function configuratorMethods:unstageUpdate(process, action, tags, data, msg)</span>
<span class="fc" data-hits="3">  local hash = crypto.digest.keccak256(process .. action .. tags.. data).asHex()</span>
<span class="fc" data-hits="3">  assert(self.staged[hash], &#39;Update not staged! Hash: &#39; .. hash)</span>
  -- unstage
<span class="fc" data-hits="2">  self.staged[hash] = nil</span>
  -- unstage notice
<span class="fc" data-hits="2">  return self.unstageUpdateNotice(hash, msg)</span>
end

--[[
    Action Update
]]
<span class="fc" data-hits="2">function configuratorMethods:actionUpdate(process, action, tags, data, msg)</span>
<span class="fc" data-hits="4">  local hash = crypto.digest.keccak256(process .. action .. tags .. data).asHex()</span>
<span class="fc" data-hits="4">  assert(self.staged[hash], &#39;Update not staged! Hash: &#39; .. hash)</span>
<span class="fc" data-hits="3">  local remaining = self.staged[hash] + self.delay - os.time()</span>
<span class="fc" data-hits="3">  assert(remaining &lt;= 0, &#39;Update not staged long enough! Remaining: &#39; .. remaining .. &#39;s.&#39;)</span>
  -- action update
<span class="fc" data-hits="2">  local message = {</span>
<span class="fc" data-hits="2">    Target = process,</span>
<span class="fc" data-hits="2">    Action = action,</span>
<span class="fc" data-hits="2">    Data = data ~= &#39;&#39; and json.decode(data) or nil</span>
  }
<span class="fc" data-hits="4">  for tagName, tagValue in pairs(json.decode(tags)) do</span>
<span class="fc" data-hits="2">    message[tagName] = tagValue</span>
  end
<span class="fc" data-hits="2">  ao.send(message)</span>
  -- unstage
<span class="fc" data-hits="2">  self.staged[hash] = nil</span>
  -- action notice
<span class="fc" data-hits="2">  return self.actionUpdateNotice(hash, msg)</span>
end

--[[
    ADMIN ----------------------------------------------------------------
]]

--[[
    Stage Update: Admin
]]
<span class="fc" data-hits="2">function configuratorMethods:stageUpdateAdmin(updateAdmin, msg)</span>
<span class="fc" data-hits="7">  local hash = crypto.digest.keccak256(updateAdmin).asHex()</span>
  -- stage
<span class="fc" data-hits="7">  self.staged[hash] = os.time()</span>
  -- stage notice
<span class="fc" data-hits="7">  return self.stageUpdateAdminNotice(updateAdmin, hash, self.staged[hash], msg)</span>
end

--[[
    Unstage Update: Admin
]]
<span class="fc" data-hits="2">function configuratorMethods:unstageUpdateAdmin(updateAdmin, msg)</span>
<span class="fc" data-hits="3">  local hash = crypto.digest.keccak256(updateAdmin).asHex()</span>
<span class="fc" data-hits="3">  assert(self.staged[hash], &#39;Update not staged! Hash: &#39; .. hash)</span>
  -- unstage 
<span class="fc" data-hits="2">  self.staged[hash] = nil</span>
  -- unstage notice
<span class="fc" data-hits="2">  return self.unstageUpdateAdminNotice(hash, msg)</span>
end

--[[
    Action Update: Admin
]]
<span class="fc" data-hits="2">function configuratorMethods:actionUpdateAdmin(updateAdmin, msg)</span>
<span class="fc" data-hits="4">  local hash = crypto.digest.keccak256(updateAdmin).asHex()</span>
<span class="fc" data-hits="4">  assert(self.staged[hash], &#39;Update not staged! Hash: &#39; .. hash)</span>
<span class="fc" data-hits="3">  local remaining = self.staged[hash] + self.delay - os.time()</span>
<span class="fc" data-hits="3">  assert(remaining &lt;= 0, &#39;Update not staged long enough! Remaining: &#39; .. remaining .. &#39;s.&#39;)</span>
  -- action update
<span class="fc" data-hits="2">  self.admin = updateAdmin</span>
  -- unstage
<span class="fc" data-hits="2">  self.staged[hash] = nil</span>
  -- action notice
<span class="fc" data-hits="2">  return self.actionUpdateAdminNotice(hash, msg)</span>
end

--[[
    DELAY TIME ----------------------------------------------------------------
]]

--[[
    Stage Update: DelayTime
]]
<span class="fc" data-hits="2">function configuratorMethods:stageUpdateDelay(delayInSeconds, msg)</span>
<span class="fc" data-hits="7">  local hash = crypto.digest.keccak256(tostring(delayInSeconds)).asHex()</span>
<span class="fc" data-hits="7">  self.staged[hash] = os.time()</span>
  -- stage notice
<span class="fc" data-hits="7">  return self.stageUpdateDelayNotice(delayInSeconds, hash, self.staged[hash], msg)</span>
end

--[[
    Unstage Update: Delay
]]
<span class="fc" data-hits="2">function configuratorMethods:unstageUpdateDelay(delayInSeconds, msg)</span>
<span class="fc" data-hits="3">  local hash = crypto.digest.keccak256(tostring(delayInSeconds)).asHex()</span>
<span class="fc" data-hits="3">  assert(self.staged[hash], &#39;Update not staged! Hash: &#39; .. hash)</span>
  -- unstage
<span class="fc" data-hits="2">  self.staged[hash] = nil</span>
  -- unstage notice
<span class="fc" data-hits="2">  return self.unstageUpdateDelayNotice(hash, msg)</span>
end

--[[
    Action Update: Delay
]]
<span class="fc" data-hits="2">function configuratorMethods:actionUpdateDelay(delayInSeconds, msg)</span>
<span class="fc" data-hits="4">  local hash = crypto.digest.keccak256(tostring(delayInSeconds)).asHex()</span>
<span class="fc" data-hits="4">  assert(self.staged[hash], &#39;Update not staged! Hash: &#39; .. hash)</span>
<span class="fc" data-hits="3">  local remaining = self.staged[hash] + self.delay - os.time()</span>
<span class="fc" data-hits="3">  assert(remaining &lt;= 0, &#39;Update not staged long enough! Remaining: &#39; .. remaining .. &#39;s.&#39;)</span>
  -- action update
<span class="fc" data-hits="2">  self.delay = delayInSeconds</span>
  -- unstage
<span class="fc" data-hits="2">  self.staged[hash] = nil</span>
  -- action notice
<span class="fc" data-hits="2">  return self.actionUpdateDelayNotice(hash, msg)</span>
end

<span class="fc" data-hits="2">return Configurator</span>
</pre>
      </div>

      <div class="hidden file success-high" id="src-modules-configuratornotices">
         <h2 class="title">
            src/modules/configuratorNotices.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 100.00%"></span>
                  <span><strong>100.00%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>47</strong> Hits</span>
               <span class="miss"><strong>0</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums"><span class="fc" data-hits="3">local ConfiguratorNotices = {}</span>

<span class="fc" data-hits="3">function ConfiguratorNotices.stageUpdateNotice(process, action, tags, data, hash, timestamp, msg)</span>
<span class="fc" data-hits="16">  return msg.reply({</span>
<span class="fc" data-hits="8">    Action = &#39;Update-Staged&#39;,</span>
<span class="fc" data-hits="8">    UpdateProcess = process,</span>
<span class="fc" data-hits="8">    UpdateAction = action,</span>
<span class="fc" data-hits="8">    UpdateTags = tags,</span>
<span class="fc" data-hits="8">    UpdateData = data,</span>
<span class="fc" data-hits="8">    Hash = hash,</span>
<span class="fc" data-hits="8">    Timestamp = timestamp,</span>
  })
end

<span class="fc" data-hits="3">function ConfiguratorNotices.unstageUpdateNotice(hash, msg)</span>
<span class="fc" data-hits="6">  return msg.reply({</span>
<span class="fc" data-hits="3">    Action = &#39;Update-Unstaged&#39;,</span>
<span class="fc" data-hits="3">    Hash = hash</span>
  })
end

<span class="fc" data-hits="3">function ConfiguratorNotices.actionUpdateNotice(hash, msg)</span>
<span class="fc" data-hits="6">  return msg.reply({</span>
<span class="fc" data-hits="3">    Action = &#39;Update-Actioned&#39;,</span>
<span class="fc" data-hits="3">    Hash = hash</span>
  })
end

<span class="fc" data-hits="3">function ConfiguratorNotices.stageUpdateAdminNotice(admin, hash, timestamp, msg)</span>
<span class="fc" data-hits="16">  return msg.reply({</span>
<span class="fc" data-hits="8">    Action = &#39;Update-Admin-Staged&#39;,</span>
<span class="fc" data-hits="8">    UpdateAdmin = admin,</span>
<span class="fc" data-hits="8">    Hash = hash,</span>
<span class="fc" data-hits="8">    Timestamp = timestamp,</span>
  })
end

<span class="fc" data-hits="3">function ConfiguratorNotices.unstageUpdateAdminNotice(hash, msg)</span>
<span class="fc" data-hits="6">  return msg.reply({</span>
<span class="fc" data-hits="3">    Action = &#39;Update-Admin-Unstaged&#39;,</span>
<span class="fc" data-hits="3">    Hash = hash</span>
  })
end

<span class="fc" data-hits="3">function ConfiguratorNotices.actionUpdateAdminNotice(hash, msg)</span>
<span class="fc" data-hits="6">  return msg.reply({</span>
<span class="fc" data-hits="3">    Action = &#39;Update-Admin-Actioned&#39;,</span>
<span class="fc" data-hits="3">    Hash = hash</span>
  })
end

<span class="fc" data-hits="3">function ConfiguratorNotices.stageUpdateDelayNotice(delay, hash, timestamp, msg)</span>
<span class="fc" data-hits="16">  return msg.reply({</span>
<span class="fc" data-hits="8">    Action = &#39;Update-Delay-Staged&#39;,</span>
<span class="fc" data-hits="8">    UpdateDelay = delay,</span>
<span class="fc" data-hits="8">    Hash = hash,</span>
<span class="fc" data-hits="8">    Timestamp = timestamp,</span>
  })
end

<span class="fc" data-hits="3">function ConfiguratorNotices.unstageUpdateDelayNotice(hash, msg)</span>
<span class="fc" data-hits="6">  return msg.reply({</span>
<span class="fc" data-hits="3">    Action = &#39;Update-Delay-Unstaged&#39;,</span>
<span class="fc" data-hits="3">    Hash = hash</span>
  })
end

<span class="fc" data-hits="3">function ConfiguratorNotices.actionUpdateDelayNotice(hash, msg)</span>
<span class="fc" data-hits="6">  return msg.reply({</span>
<span class="fc" data-hits="3">    Action = &#39;Update-Delay-Actioned&#39;,</span>
<span class="fc" data-hits="3">    Hash = hash</span>
  })
end

<span class="fc" data-hits="3">return ConfiguratorNotices</span>
</pre>
      </div>

      <div class="hidden file success-high" id="src-modules-configuratorvalidation">
         <h2 class="title">
            src/modules/configuratorValidation.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 100.00%"></span>
                  <span><strong>100.00%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>21</strong> Hits</span>
               <span class="miss"><strong>0</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums"><span class="fc" data-hits="2">local json = require(&#39;json&#39;)</span>
<span class="fc" data-hits="2">local sharedUtils = require(&#39;modules.sharedUtils&#39;)</span>

<span class="fc" data-hits="2">local configuratorValidation = {}</span>

<span class="fc" data-hits="2">function configuratorValidation.updateProcess(msg)</span>
<span class="fc" data-hits="23">  assert(msg.From == Configurator.admin, &#39;Sender must be admin!&#39;)</span>
<span class="fc" data-hits="22">  assert(type(msg.Tags.UpdateProcess) == &#39;string&#39;, &#39;UpdateProcess is required!&#39;)</span>
<span class="fc" data-hits="21">  assert(sharedUtils.isValidArweaveAddress(msg.Tags.UpdateProcess), &#39;UpdateProcess must be a valid Arweave address!&#39;)</span>
<span class="fc" data-hits="20">  assert(type(msg.Tags.UpdateAction) == &#39;string&#39;, &#39;UpdateAction is required!&#39;)</span>
<span class="fc" data-hits="19">  assert(sharedUtils.isValidKeyValueJSON(msg.Tags.UpdateTags) or msg.Tags.UpdateTags == nil, &#39;UpdateTags must be valid JSON!&#39;)</span>
<span class="fc" data-hits="13">  assert(sharedUtils.isValidKeyValueJSON(msg.Tags.UpdateData) or msg.Tags.UpdateData == nil, &#39;UpdateData must be valid JSON!&#39;)</span>
end

<span class="fc" data-hits="2">function configuratorValidation.updateAdmin(msg)</span>
<span class="fc" data-hits="9">  assert(msg.From == Configurator.admin, &#39;Sender must be admin!&#39;)</span>
<span class="fc" data-hits="8">  assert(type(msg.Tags.UpdateAdmin) == &#39;string&#39;, &#39;UpdateAdmin is required!&#39;)</span>
<span class="fc" data-hits="7">  assert(sharedUtils.isValidArweaveAddress(msg.Tags.UpdateAdmin), &#39;UpdateAdmin must be a valid Arweave address!&#39;)</span>
end

<span class="fc" data-hits="2">function configuratorValidation.updateDelay(msg)</span>
<span class="fc" data-hits="12">  assert(msg.From == Configurator.admin, &#39;Sender must be admin!&#39;)</span>
<span class="fc" data-hits="11">  assert(msg.Tags.UpdateDelay, &#39;UpdateDelay is required!&#39;)</span>
<span class="fc" data-hits="10">  assert(tonumber(msg.Tags.UpdateDelay), &#39;UpdateDelay must be a number!&#39;)</span>
<span class="fc" data-hits="9">  assert(tonumber(msg.Tags.UpdateDelay) &gt; 0, &#39;UpdateDelay must be greater than zero!&#39;)</span>
<span class="fc" data-hits="7">  assert(tonumber(msg.Tags.UpdateDelay) % 1 == 0, &#39;UpdateDelay must be an integer!&#39;)</span>
end

<span class="fc" data-hits="2">return configuratorValidation</span>
</pre>
      </div>

      <div class="hidden file danger" id="src-modules-cpmm">
         <h2 class="title">
            src/modules/cpmm.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 32.87%"></span>
                  <span><strong>32.87%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>71</strong> Hits</span>
               <span class="miss"><strong>145</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums"><span class="fc" data-hits="1">local json = require(&#39;json&#39;)</span>
<span class="fc" data-hits="1">local bint = require(&#39;.bint&#39;)(256)</span>
<span class="fc" data-hits="1">local ao = require(&#39;.ao&#39;)</span>
<span class="fc" data-hits="1">local utils = require(&quot;.utils&quot;)</span>
<span class="fc" data-hits="1">local token = require(&#39;modules.token&#39;)</span>
<span class="fc" data-hits="1">local conditionalTokens = require(&#39;modules.conditionalTokens&#39;)</span>
<span class="fc" data-hits="1">local CPMMHelpers = require(&#39;modules.cpmmHelpers&#39;)</span>

<span class="fc" data-hits="1">local CPMM = {}</span>
<span class="fc" data-hits="1">local CPMMMethods = require(&#39;modules.cpmmNotices&#39;)</span>
<span class="fc" data-hits="1">local LPToken = {}</span>
<span class="fc" data-hits="1">local ConditionalTokens = {}</span>

-- Constructor for CPMM 
<span class="fc" data-hits="1">function CPMM:new()</span>
  -- Initialize Tokens and store the object
<span class="fc" data-hits="2">  LPToken = token:new()</span>
<span class="fc" data-hits="2">  ConditionalTokens = conditionalTokens:new()</span>
  -- Create a new CPMM object
<span class="fc" data-hits="2">  local obj = {</span>
    -- Market vars
<span class="fc" data-hits="2">    marketId = &#39;&#39;,</span>
<span class="fc" data-hits="2">    incentives = &#39;&#39;,</span>
<span class="fc" data-hits="2">    configurator = &#39;&#39;,</span>
<span class="fc" data-hits="2">    initialized = false,</span>
    -- CPMM vars
<span class="fc" data-hits="2">    poolBalances = {},</span>
<span class="fc" data-hits="2">    withdrawnFees = {},</span>
<span class="fc" data-hits="2">    feePoolWeight = &#39;0&#39;,</span>
<span class="fc" data-hits="2">    totalWithdrawnFees = &#39;0&#39;,</span>
    -- ConditionalTokens vars
<span class="fc" data-hits="2">    tokens = ConditionalTokens,</span>
    -- LP vars
<span class="fc" data-hits="2">    token = LPToken,</span>
<span class="fc" data-hits="2">    lpFee = 0</span>
  }

  -- Set metatable for method lookups
<span class="fc" data-hits="4">  setmetatable(obj, {</span>
    __index = function(t, k)
      -- First, look up the key in CPMMMethods
<span class="fc" data-hits="3">      if CPMMMethods[k] then</span>
<span class="fc" data-hits="2">        return CPMMMethods[k]</span>
      -- Then, check in CPMMHelpers
<span class="fc" data-hits="1">      elseif CPMMHelpers[k] then</span>
<span class="fc" data-hits="1">        return CPMMHelpers[k]</span>
      -- Then, look up the key in the ConditionalTokens methods
<span class="nc">      elseif ConditionalTokens[k] then</span>
<span class="nc">        return ConditionalTokens[k]</span>
      -- Lastly, look up the key in the Config methods
<span class="nc">      elseif Config[k] then</span>
<span class="nc">        return Config[k]</span>
      else
<span class="nc">        return nil</span>
      end
    end
  })
<span class="fc" data-hits="2">  return obj</span>
end

---------------------------------------------------------------------------------
-- FUNCTIONS --------------------------------------------------------------------
---------------------------------------------------------------------------------

-- Init
<span class="fc" data-hits="1">function CPMMMethods:init(configurator, incentives, collateralToken, marketId, conditionId, outcomeSlotCount, name, ticker, logo, lpFee, creatorFee, creatorFeeTarget, protocolFee, protocolFeeTarget, msg)</span>
  -- Generate Position Ids
<span class="fc" data-hits="1">  local positionIds = self.getPositionIds(tonumber(outcomeSlotCount))</span>
  -- Set Conditional Tokens vars
<span class="fc" data-hits="1">  self.tokens.conditionId = conditionId</span>
<span class="fc" data-hits="1">  self.tokens.positionIds = positionIds</span>
<span class="fc" data-hits="1">  self.tokens.outcomeSlotCount = outcomeSlotCount</span>
<span class="fc" data-hits="1">  self.tokens.collateralToken = collateralToken</span>
<span class="fc" data-hits="1">  self.tokens.creatorFee = tonumber(creatorFee)</span>
<span class="fc" data-hits="1">  self.tokens.creatorFeeTarget = creatorFeeTarget</span>
<span class="fc" data-hits="1">  self.tokens.protocolFee = tonumber(protocolFee)</span>
<span class="fc" data-hits="1">  self.tokens.protocolFeeTarget = protocolFeeTarget</span>
  -- Set LP Token vars
<span class="fc" data-hits="1">  self.token.name = name</span>
<span class="fc" data-hits="1">  self.token.ticker = ticker</span>
<span class="fc" data-hits="1">  self.token.logo = logo</span>
  -- Initialized
<span class="fc" data-hits="1">  self.marketId = marketId</span>
<span class="fc" data-hits="1">  self.initialized = true</span>
<span class="fc" data-hits="1">  self.configurator = configurator</span>
<span class="fc" data-hits="1">  self.incentives = incentives</span>
<span class="fc" data-hits="1">  self.lpFee = tonumber(lpFee)</span>
  -- Prepare Condition
<span class="fc" data-hits="1">  self.tokens:prepareCondition(conditionId, outcomeSlotCount, msg)</span>
  -- Init CPMM with market details
<span class="fc" data-hits="1">  return self.newMarketNotice(configurator, incentives, collateralToken, marketId, conditionId, positionIds, outcomeSlotCount, name, ticker, logo, lpFee, creatorFee, creatorFeeTarget, protocolFee, protocolFeeTarget, msg)</span>
end

-- Add Funding 
-- @dev: TODO: test the use of distributionHint to set the initial probability distribuiton
-- @dev: TODO: test that adding subsquent funding does not alter the probability distribution
<span class="fc" data-hits="1">function CPMMMethods:addFunding(from, onBehalfOf, addedFunds, distributionHint, msg)</span>
<span class="nc">  assert(bint.__lt(0, bint(addedFunds)), &quot;funding must be non-zero&quot;)</span>
<span class="nc">  local sendBackAmounts = {}</span>
<span class="nc">  local poolShareSupply = self.token.totalSupply</span>
<span class="nc">  local mintAmount = &#39;0&#39;</span>

<span class="nc">  if bint.__lt(0, bint(poolShareSupply)) then</span>
    -- Additional Liquidity 
<span class="nc">    assert(#distributionHint == 0, &quot;cannot use distribution hint after initial funding&quot;)</span>
    -- Get poolBalances
<span class="nc">    local poolBalances = self:getPoolBalances()</span>
    -- Calculate poolWeight
<span class="nc">    local poolWeight = 0</span>
<span class="nc">    for i = 1, #poolBalances do</span>
<span class="nc">      local balance = poolBalances[i]</span>
<span class="nc">      if bint.__lt(poolWeight, bint(balance)) then</span>
<span class="nc">        poolWeight = bint(balance)</span>
      end
    end
    -- Calculate sendBackAmounts
<span class="nc">    for i = 1, #poolBalances do</span>
<span class="nc">      local remaining = math.floor((addedFunds * poolBalances[i]) &#47; poolWeight)</span>
<span class="nc">      sendBackAmounts[i] = addedFunds - remaining</span>
    end
    -- Calculate mintAmount
    ---@diagnostic disable-next-line: param-type-mismatch
<span class="nc">    mintAmount = tostring(math.floor(tostring(bint.__div(bint.__mul(addedFunds, poolShareSupply), poolWeight))))</span>
  else
    -- Initial Liquidity
<span class="nc">    if #distributionHint &gt; 0 then</span>
<span class="nc">      local maxHint = 0</span>
<span class="nc">      for i = 1, #distributionHint do</span>
<span class="nc">        local hint = distributionHint[i]</span>
<span class="nc">        if maxHint &lt; hint then</span>
<span class="nc">          maxHint = hint</span>
        end
      end
      -- Calculate sendBackAmounts
<span class="nc">      for i = 1, #distributionHint do</span>
<span class="nc">        local remaining = math.floor((addedFunds * distributionHint[i]) &#47; maxHint)</span>
<span class="nc">        assert(remaining &gt; 0, &quot;must hint a valid distribution&quot;)</span>
<span class="nc">        sendBackAmounts[i] = addedFunds - remaining</span>
      end
    end
    -- Calculate mintAmount
<span class="nc">    mintAmount = tostring(addedFunds)</span>
  end
  -- Mint Conditional Positions
<span class="nc">  self.tokens:splitPosition(ao.id, self.tokens.collateralToken, addedFunds, msg)</span>
  -- Mint LP Tokens
<span class="nc">  self:mint(onBehalfOf, mintAmount, msg)</span>
  -- Remove non-zero items before transfer-batch
<span class="nc">  local nonZeroAmounts = {}</span>
<span class="nc">  local nonZeroPositionIds = {}</span>
<span class="nc">  for i = 1, #sendBackAmounts do</span>
<span class="nc">    if sendBackAmounts[i] &gt; 0 then</span>
<span class="nc">      table.insert(nonZeroAmounts, tostring(math.floor(sendBackAmounts[i])))</span>
<span class="nc">      table.insert(nonZeroPositionIds, self.tokens.positionIds[i])</span>
    end
  end
  -- Send back conditional tokens should there be an uneven distribution
<span class="nc">  if #nonZeroAmounts ~= 0 then</span>
<span class="nc">    self.tokens:transferBatch(ao.id, onBehalfOf, nonZeroPositionIds, nonZeroAmounts, true, msg)</span>
  end
  -- Transform sendBackAmounts to array of amounts added
<span class="nc">  for i = 1, #sendBackAmounts do</span>
<span class="nc">    sendBackAmounts[i] = addedFunds - sendBackAmounts[i]</span>
  end
  -- Send notice with amounts added
<span class="nc">  return self.fundingAddedNotice(from, sendBackAmounts, mintAmount)</span>
end

-- Remove Funding 
<span class="fc" data-hits="1">function CPMMMethods:removeFunding(from, sharesToBurn, msg)</span>
<span class="nc">  assert(bint.__lt(0, bint(sharesToBurn)), &quot;funding must be non-zero&quot;)</span>
  -- Get poolBalances
<span class="nc">  local poolBalances = self:getPoolBalances()</span>
  -- Calculate sendAmounts
<span class="nc">  local sendAmounts = {}</span>
<span class="nc">  for i = 1, #poolBalances do</span>
<span class="nc">    sendAmounts[i] = tostring(math.floor((poolBalances[i] * sharesToBurn) &#47; self.token.totalSupply))</span>
  end
  -- Calculate collateralRemovedFromFeePool
<span class="nc">  local collateralRemovedFromFeePool = ao.send({Target = self.tokens.collateralToken, Action = &#39;Balance&#39;}).receive().Data</span>
<span class="nc">  self:burn(from, sharesToBurn, msg)</span>
<span class="nc">  local poolFeeBalance = ao.send({Target = self.tokens.collateralToken, Action = &#39;Balance&#39;}).receive().Data</span>
<span class="nc">  collateralRemovedFromFeePool = tostring(math.floor(poolFeeBalance - collateralRemovedFromFeePool))</span>
  -- Send collateralRemovedFromFeePool
<span class="nc">  if bint(collateralRemovedFromFeePool) &gt; 0 then</span>
<span class="nc">    ao.send({ Target = self.tokens.collateralToken, Action = &quot;Transfer&quot;, Recipient=from, Quantity=collateralRemovedFromFeePool})</span>
  end
  -- Send conditionalTokens amounts
<span class="nc">  self.tokens:transferBatch(ao.id, from, self.tokens.positionIds, sendAmounts, false, msg)</span>
  -- Send notice
<span class="nc">  return self.fundingRemovedNotice(from, sendAmounts, collateralRemovedFromFeePool, sharesToBurn)</span>
end

-- Calc Buy Amount 
<span class="fc" data-hits="1">function CPMMMethods:calcBuyAmount(investmentAmount, positionId)</span>
<span class="nc">  assert(bint.__lt(0, investmentAmount), &#39;InvestmentAmount must be greater than zero!&#39;)</span>
<span class="nc">  assert(utils.includes(positionId, self.tokens.positionIds), &#39;PositionId must be valid!&#39;)</span>

<span class="nc">  local poolBalances = self:getPoolBalances()</span>
<span class="nc">  local investmentAmountMinusFees = investmentAmount - ((investmentAmount * self.lpFee) &#47; 1e4) -- converts fee from basis points to decimal</span>
<span class="nc">  local buyTokenPoolBalance = poolBalances[tonumber(positionId)]</span>
<span class="nc">  local endingOutcomeBalance = buyTokenPoolBalance * 1e4</span>

<span class="nc">  for i = 1, #poolBalances do</span>
<span class="nc">    if not bint.__eq(bint(i), bint(positionId)) then</span>
<span class="nc">      local poolBalance = poolBalances[i]</span>
<span class="nc">      endingOutcomeBalance = CPMMHelpers.ceildiv(tonumber(endingOutcomeBalance * poolBalance), tonumber(poolBalance + investmentAmountMinusFees))</span>
    end
  end

<span class="nc">  assert(endingOutcomeBalance &gt; 0, &quot;must have non-zero balances&quot;)</span>
<span class="nc">  return tostring(bint.ceil(buyTokenPoolBalance + investmentAmountMinusFees - CPMMHelpers.ceildiv(endingOutcomeBalance, 1e4)))</span>
end

-- Calc Sell Amount
<span class="fc" data-hits="1">function CPMMMethods:calcSellAmount(returnAmount, positionId)</span>
<span class="nc">  assert(bint.__lt(0, returnAmount), &#39;ReturnAmount must be greater than zero!&#39;)</span>
<span class="nc">  assert(utils.includes(positionId, self.tokens.positionIds), &#39;PositionId must be valid!&#39;)</span>

<span class="nc">  local poolBalances = self:getPoolBalances()</span>
<span class="nc">  local returnAmountPlusFees = CPMMHelpers.ceildiv(tonumber(returnAmount * 1e4), tonumber(1e4 - self.lpFee))</span>
<span class="nc">  local sellTokenPoolBalance = poolBalances[tonumber(positionId)]</span>
<span class="nc">  local endingOutcomeBalance = sellTokenPoolBalance * 1e4</span>

<span class="nc">  for i = 1, #poolBalances do</span>
<span class="nc">    if not bint.__eq(bint(i), bint(positionId)) then</span>
<span class="nc">      local poolBalance = poolBalances[i]</span>
<span class="nc">      assert(poolBalance - returnAmountPlusFees &gt; 0, &quot;PoolBalance must be greater than return amount plus fees!&quot;)</span>
<span class="nc">      endingOutcomeBalance = CPMMHelpers.ceildiv(tonumber(endingOutcomeBalance * poolBalance), tonumber(poolBalance - returnAmountPlusFees))</span>
    end
  end

<span class="nc">  assert(endingOutcomeBalance &gt; 0, &quot;must have non-zero balances&quot;)</span>
<span class="nc">  return tostring(bint.ceil(returnAmountPlusFees + CPMMHelpers.ceildiv(endingOutcomeBalance, 1e4) - sellTokenPoolBalance))</span>
end

-- Buy 
<span class="fc" data-hits="1">function CPMMMethods:buy(from, onBehalfOf, investmentAmount, positionId, minOutcomeTokensToBuy, msg)</span>
<span class="nc">  local outcomeTokensToBuy = self:calcBuyAmount(investmentAmount, positionId)</span>
<span class="nc">  assert(bint.__le(minOutcomeTokensToBuy, bint(outcomeTokensToBuy)), &quot;Minimum outcome tokens not reached!&quot;)</span>
  -- Calculate investmentAmountMinusFees.
<span class="nc">  local feeAmount = tostring(bint.ceil(bint.__div(bint.__mul(investmentAmount, self.lpFee), 1e4)))</span>
<span class="nc">  self.feePoolWeight = tostring(bint.__add(bint(self.feePoolWeight), bint(feeAmount)))</span>
<span class="nc">  local investmentAmountMinusFees = tostring(bint.__sub(investmentAmount, bint(feeAmount)))</span>
  -- Split position through all conditions
<span class="nc">  self.tokens:splitPosition(ao.id, self.tokens.collateralToken, investmentAmountMinusFees, msg)</span>
  -- Transfer buy position to sender
<span class="nc">  self.tokens:transferSingle(ao.id, from, positionId, outcomeTokensToBuy, false, msg)</span>
  -- Send notice.
<span class="nc">  return self.buyNotice(from, investmentAmount, feeAmount, positionId, outcomeTokensToBuy)</span>
end

-- Sell 
<span class="fc" data-hits="1">function CPMMMethods:sell(from, returnAmount, positionId, quantity, maxOutcomeTokensToSell, msg)</span>
  -- Calculate outcome tokens to sell.
<span class="nc">  local outcomeTokensToSell = self:calcSellAmount(returnAmount, positionId)</span>
<span class="nc">  assert(bint.__le(bint(outcomeTokensToSell), bint(maxOutcomeTokensToSell)), &quot;Maximum sell amount exceeded!&quot;)</span>
  -- Calculate returnAmountPlusFees.
<span class="nc">  local feeAmount = tostring(bint.ceil(bint.__div(bint.__mul(returnAmount, self.lpFee), bint.__sub(1e4, self.lpFee))))</span>
<span class="nc">  self.feePoolWeight = tostring(bint.__add(bint(self.feePoolWeight), bint(feeAmount)))</span>
<span class="nc">  local returnAmountPlusFees = tostring(bint.__add(returnAmount, bint(feeAmount)))</span>
  -- Check sufficient liquidity within the process or revert.
<span class="nc">  local collataralBalance = ao.send({Target = self.tokens.collateralToken, Action = &quot;Balance&quot;}).receive().Data</span>
<span class="nc">  assert(bint.__le(bint(returnAmountPlusFees), bint(collataralBalance)), &quot;Insufficient liquidity!&quot;)</span>
  -- Check user balance and transfer outcomeTokensToSell to process before merge.
<span class="nc">  local balance = self.tokens:getBalance(from, nil, positionId)</span>
<span class="nc">  assert(bint.__le(bint(quantity), bint(balance)), &#39;Insufficient balance!&#39;)</span>
<span class="nc">  self.tokens:transferSingle(from, ao.id, positionId, outcomeTokensToSell, true, msg)</span>
  -- Merge positions through all conditions (burns returnAmountPlusFees).
<span class="nc">  self.tokens:mergePositions(ao.id, &#39;&#39;, returnAmountPlusFees, true, msg)</span>
  -- Returns collateral to the user
<span class="nc">  ao.send({</span>
    Target = self.tokens.collateralToken,
    Action = &quot;Transfer&quot;,
    Quantity = returnAmount,
<span class="nc">    Recipient = from</span>
<span class="nc">  }).receive()</span>
  -- Returns unburned conditional tokens to user 
<span class="nc">  local unburned = tostring(bint.__sub(bint(quantity), bint(returnAmountPlusFees)))</span>
<span class="nc">  self.tokens:transferSingle(ao.id, from, positionId, unburned, true, msg)</span>
  -- Send notice (Process continued via &quot;SellOrderCompletionCollateralToken&quot; and &quot;SellOrderCompletionConditionalTokens&quot; handlers)
<span class="nc">  return self.sellNotice(from, returnAmount, feeAmount, positionId, outcomeTokensToSell)</span>
end

-- Fees
-- @dev Returns the total fees collected within the CPMM
<span class="fc" data-hits="1">function CPMMMethods:collectedFees()</span>
<span class="nc">  return tostring(self.feePoolWeight - self.totalWithdrawnFees)</span>
end

-- @dev Returns the fees withdrawable by the sender
<span class="fc" data-hits="1">function CPMMMethods:feesWithdrawableBy(sender)</span>
<span class="nc">  local balance = self.token.balances[sender] or &#39;0&#39;</span>
<span class="nc">  local rawAmount = &#39;0&#39;</span>
<span class="nc">  if bint(self.token.totalSupply) &gt; 0 then</span>
<span class="nc">    rawAmount = string.format(&#39;%.0f&#39;, (bint.__div(bint.__mul(bint(self:collectedFees()), bint(balance)), self.token.totalSupply)))</span>
  end

  -- @dev max(rawAmount - withdrawnFees, 0)
<span class="nc">  return tostring(bint.max(bint(bint.__sub(bint(rawAmount), bint(self.withdrawnFees[sender] or &#39;0&#39;))), 0))</span>
end

-- @dev Withdraws fees to the sender
<span class="fc" data-hits="1">function CPMMMethods:withdrawFees(sender, msg)</span>
<span class="nc">  local feeAmount = self:feesWithdrawableBy(sender)</span>
<span class="nc">  if bint.__lt(0, bint(feeAmount)) then</span>
<span class="nc">    self.withdrawnFees[sender] = feeAmount</span>
<span class="nc">    self.totalWithdrawnFees = tostring(bint.__add(bint(self.totalWithdrawnFees), bint(feeAmount)))</span>
<span class="nc">    msg.forward(self.tokens.collateralToken, {Action = &#39;Transfer&#39;, Recipient = sender, Quantity = feeAmount})</span>
  end
<span class="nc">  return feeAmount</span>
end

-- @dev Updates fee accounting before token transfers
<span class="fc" data-hits="1">function CPMMMethods:_beforeTokenTransfer(from, to, amount, msg)</span>
<span class="nc">  if from ~= nil then</span>
<span class="nc">    self:withdrawFees(from, msg)</span>
  end
<span class="nc">  local totalSupply = self.token.totalSupply</span>
<span class="nc">  local withdrawnFeesTransfer = totalSupply == &#39;0&#39; and amount or tostring(bint(bint.__div(bint.__mul(bint(self:collectedFees()), amount), totalSupply)))</span>

<span class="nc">  if from ~= nil and to ~= nil then</span>
<span class="nc">    self.withdrawnFees[from] = tostring(bint.__sub(bint(self.withdrawnFees[from] or &#39;0&#39;), withdrawnFeesTransfer))</span>
<span class="nc">    self.withdrawnFees[to] = tostring(bint.__add(bint(self.withdrawnFees[to] or &#39;0&#39;), withdrawnFeesTransfer))</span>
  end
end

-- LP Tokens
-- @dev See tokensMethods:mint &amp; _beforeTokenTransfer
<span class="fc" data-hits="1">function CPMMMethods:mint(to, quantity, msg)</span>
<span class="nc">  self:_beforeTokenTransfer(nil, to, quantity, msg)</span>
<span class="nc">  return self.token:mint(to, quantity, msg)</span>
end

-- @dev See tokenMethods:burn &amp; _beforeTokenTransfer
<span class="fc" data-hits="1">function CPMMMethods:burn(from, quantity, msg)</span>
<span class="nc">  self:_beforeTokenTransfer(from, nil, quantity, msg)</span>
<span class="nc">  return self.token:burn(from, quantity, msg)</span>
end

-- @dev See tokenMethods:transfer &amp; _beforeTokenTransfer
<span class="fc" data-hits="1">function CPMMMethods:transfer(from, recipient, quantity, cast, msg)</span>
<span class="nc">  self:_beforeTokenTransfer(from, recipient, quantity, msg)</span>
<span class="nc">  return self.token:transfer(from, recipient, quantity, cast, msg)</span>
end

-- @dev updates configurator
<span class="fc" data-hits="1">function CPMMMethods:updateConfigurator(configurator, msg)</span>
<span class="nc">  self.configurator = configurator</span>
<span class="nc">  return self.updateConfiguratorNotice(configurator, msg)</span>
end

-- @dev updates incentives
<span class="fc" data-hits="1">function CPMMMethods:updateIncentives(incentives, msg)</span>
<span class="nc">  self.incentives = incentives</span>
<span class="nc">  return self.updateIncentivesNotice(incentives, msg)</span>
end

-- @dev Updates the take fee
<span class="fc" data-hits="1">function CPMMMethods:updateTakeFee(creatorFee, protocolFee, msg)</span>
<span class="nc">  self.tokens.creatorFee = creatorFee</span>
<span class="nc">  self.tokens.protocolFee = protocolFee</span>
<span class="nc">  return self.updateTakeFeeNotice(creatorFee, protocolFee, creatorFee + protocolFee, msg)</span>
end

-- @dev Updtes the protocol fee target
<span class="fc" data-hits="1">function CPMMMethods:updateProtocolFeeTarget(target, msg)</span>
<span class="nc">  self.tokens.protocolFeeTarget = target</span>
<span class="nc">  return self.updateProtocolFeeTargetNotice(target, msg)</span>
end

-- @dev Updtes the logo
<span class="fc" data-hits="1">function CPMMMethods:updateLogo(logo, msg)</span>
<span class="nc">  self.token.logo = logo</span>
<span class="nc">  self.tokens.logo = logo</span>
<span class="nc">  return self.updateLogoNotice(logo, msg)</span>
end

<span class="fc" data-hits="1">return CPMM</span>
</pre>
      </div>

      <div class="hidden file success-high" id="src-modules-cpmmhelpers">
         <h2 class="title">
            src/modules/cpmmHelpers.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 100.00%"></span>
                  <span><strong>100.00%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>60</strong> Hits</span>
               <span class="miss"><strong>0</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums"><span class="fc" data-hits="2">local bint = require(&#39;.bint&#39;)(256)</span>
<span class="fc" data-hits="2">local ao = require(&#39;.ao&#39;)</span>
<span class="fc" data-hits="2">local json = require(&#39;json&#39;)</span>

<span class="fc" data-hits="2">local CPMMHelpers = {}</span>

-- Utility function: CeilDiv
<span class="fc" data-hits="2">function CPMMHelpers.ceildiv(x, y)</span>
<span class="fc" data-hits="3">  if x &gt; 0 then</span>
<span class="fc" data-hits="2">    return math.floor((x - 1) &#47; y) + 1</span>
  end
<span class="fc" data-hits="1">  return math.floor(x &#47; y)</span>
end


--@dev generates basic partition based on outcomesSlotCount
<span class="fc" data-hits="2">function CPMMHelpers.getPositionIds(outcomeSlotCount)</span>
<span class="fc" data-hits="2">  local positionIds = {}</span>
<span class="fc" data-hits="7">  for i = 1, outcomeSlotCount do</span>
<span class="fc" data-hits="5">    table.insert(positionIds, tostring(i))</span>
  end
<span class="fc" data-hits="2">  return positionIds</span>
end

-- @dev validates addFunding
<span class="fc" data-hits="2">function CPMMHelpers:validateAddFunding(from, quantity, distribution)</span>
<span class="fc" data-hits="5">  local error = false</span>
<span class="fc" data-hits="5">  local errorMessage = &#39;&#39;</span>
  -- Ensure distribution
<span class="fc" data-hits="5">  if not distribution then</span>
<span class="fc" data-hits="1">    error = true</span>
<span class="fc" data-hits="1">    errorMessage = &#39;X-Distribution is required!&#39;</span>
<span class="fc" data-hits="4">  elseif not error then</span>
<span class="fc" data-hits="4">    if bint.iszero(bint(self.token.totalSupply)) then</span>
      -- Ensure distribution is set across all position ids
<span class="fc" data-hits="2">      if #distribution ~= #self.tokens.positionIds then</span>
<span class="fc" data-hits="1">        error = true</span>
<span class="fc" data-hits="1">        errorMessage = &quot;Distribution length mismatch&quot;</span>
      end
    else
      -- Ensure distribution set only for initial funding
<span class="fc" data-hits="2">      if bint.__lt(0, #distribution) then</span>
<span class="fc" data-hits="1">        error = true</span>
<span class="fc" data-hits="1">        errorMessage = &quot;Cannot specify distribution after initial funding&quot;</span>
      end
    end
  end
<span class="fc" data-hits="5">  if error then</span>
    -- Return funds and assert error
<span class="fc" data-hits="6">    ao.send({</span>
<span class="fc" data-hits="3">      Target = self.tokens.collateralToken,</span>
<span class="fc" data-hits="3">      Action = &#39;Transfer&#39;,</span>
<span class="fc" data-hits="3">      Recipient = from,</span>
<span class="fc" data-hits="3">      Quantity = quantity,</span>
<span class="fc" data-hits="3">      Error = &#39;Add-Funding Error: &#39; .. errorMessage</span>
    })
  end
<span class="fc" data-hits="5">  return not error</span>
end

-- @dev validates removeFunding
<span class="fc" data-hits="2">function CPMMHelpers:validateRemoveFunding(from, quantity)</span>
<span class="fc" data-hits="3">  local error = false</span>
<span class="fc" data-hits="3">  local errorMessage = &#39;&#39;</span>
  -- Get balance
<span class="fc" data-hits="3">  local balance = self.token.balances[from] or &#39;0&#39;</span>
  -- Check for errors
<span class="fc" data-hits="3">  if from == self.creatorFeeTarget and self.payoutDenominator[self.conditionId] and self.payoutDenominator[self.conditionId] == 0 then</span>
<span class="fc" data-hits="1">    error = true</span>
<span class="fc" data-hits="1">    errorMessage = &#39;Creator liquidity locked until market resolution!&#39;</span>
<span class="fc" data-hits="2">  elseif not bint.__le(bint(quantity), bint(balance)) then</span>
<span class="fc" data-hits="1">    error = true</span>
<span class="fc" data-hits="1">    errorMessage = &#39;Quantity must be less than balance!&#39;</span>
  end
  -- Return funds on error.
<span class="fc" data-hits="3">  if error then</span>
<span class="fc" data-hits="4">    ao.send({</span>
<span class="fc" data-hits="2">      Target = ao.id,</span>
<span class="fc" data-hits="2">      Action = &#39;Transfer&#39;,</span>
<span class="fc" data-hits="2">      Recipient = from,</span>
<span class="fc" data-hits="2">      Quantity = quantity,</span>
<span class="fc" data-hits="2">      Error = errorMessage</span>
    })
  end
<span class="fc" data-hits="3">  return not error</span>
end

-- @dev get pool balances
<span class="fc" data-hits="2">function CPMMHelpers:getPoolBalances()</span>
  -- Get poolBalances
<span class="fc" data-hits="1">  local selves = {}</span>
<span class="fc" data-hits="4">  for _ = 1, #self.tokens.positionIds do</span>
<span class="fc" data-hits="3">    table.insert(selves, ao.id)</span>
  end
<span class="fc" data-hits="1">  local poolBalances = self.tokens:getBatchBalance(selves, self.tokens.positionIds)</span>
<span class="fc" data-hits="1">  return poolBalances</span>
end

<span class="fc" data-hits="2">return CPMMHelpers</span>
</pre>
      </div>

      <div class="hidden file success-high" id="src-modules-cpmmnotices">
         <h2 class="title">
            src/modules/cpmmNotices.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 100.00%"></span>
                  <span><strong>100.00%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>78</strong> Hits</span>
               <span class="miss"><strong>0</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums"><span class="fc" data-hits="2">local ao = require(&#39;.ao&#39;)</span>
<span class="fc" data-hits="2">local json = require(&#39;json&#39;)</span>

<span class="fc" data-hits="2">local CPMMNotices = {}</span>

<span class="fc" data-hits="2">function CPMMNotices.newMarketNotice(configurator, incentives, collateralToken, marketId, conditionId, positionIds, outcomeSlotCount, name, ticker, logo, lpFee, creatorFee, creatorFeeTarget, protocolFee, protocolFeeTarget, msg)</span>
<span class="fc" data-hits="4">  return msg.reply({</span>
<span class="fc" data-hits="2">    Action = &quot;New-Market-Notice&quot;,</span>
<span class="fc" data-hits="2">    MarketId = marketId,</span>
<span class="fc" data-hits="2">    ConditionId = conditionId,</span>
<span class="fc" data-hits="2">    Configurator = configurator,</span>
<span class="fc" data-hits="2">    Incentives = incentives,</span>
<span class="fc" data-hits="2">    CollateralToken = collateralToken,</span>
<span class="fc" data-hits="2">    PositionIds = json.encode(positionIds),</span>
<span class="fc" data-hits="2">    OutcomeSlotCount = tostring(outcomeSlotCount),</span>
<span class="fc" data-hits="2">    LpFee = lpFee,</span>
<span class="fc" data-hits="2">    CreatorFee = creatorFee,</span>
<span class="fc" data-hits="2">    CreatorFeeTarget = creatorFeeTarget,</span>
<span class="fc" data-hits="2">    ProtocolFee = protocolFee,</span>
<span class="fc" data-hits="2">    ProtocolFeeTarget = protocolFeeTarget,</span>
<span class="fc" data-hits="2">    Name = name,</span>
<span class="fc" data-hits="2">    Ticker = ticker,</span>
<span class="fc" data-hits="2">    Logo = logo,</span>
<span class="fc" data-hits="2">    Data = &quot;Successfully created market&quot;</span>
  })
end

<span class="fc" data-hits="2">function CPMMNotices.fundingAddedNotice(from, fundingAdded, mintAmount)</span>
<span class="fc" data-hits="2">  return ao.send({</span>
<span class="fc" data-hits="1">    Target = from,</span>
<span class="fc" data-hits="1">    Action = &quot;Funding-Added-Notice&quot;,</span>
<span class="fc" data-hits="1">    FundingAdded = json.encode(fundingAdded),</span>
<span class="fc" data-hits="1">    MintAmount = tostring(mintAmount),</span>
<span class="fc" data-hits="1">    Data = &quot;Successfully added funding&quot;</span>
  })
end

<span class="fc" data-hits="2">function CPMMNotices.fundingRemovedNotice(from, sendAmounts, collateralRemovedFromFeePool, sharesToBurn)</span>
<span class="fc" data-hits="2">  return ao.send({</span>
<span class="fc" data-hits="1">    Target = from,</span>
<span class="fc" data-hits="1">    Action = &quot;Funding-Removed-Notice&quot;,</span>
<span class="fc" data-hits="1">    SendAmounts = json.encode(sendAmounts),</span>
<span class="fc" data-hits="1">    CollateralRemovedFromFeePool = tostring(collateralRemovedFromFeePool),</span>
<span class="fc" data-hits="1">    SharesToBurn = tostring(sharesToBurn),</span>
<span class="fc" data-hits="1">    Data = &quot;Successfully removed funding&quot;</span>
  })
end

<span class="fc" data-hits="2">function CPMMNotices.buyNotice(from, investmentAmount, feeAmount, positionId, outcomeTokensToBuy)</span>
<span class="fc" data-hits="2">  return ao.send({</span>
<span class="fc" data-hits="1">    Target = from,</span>
<span class="fc" data-hits="1">    Action = &quot;Buy-Notice&quot;,</span>
<span class="fc" data-hits="1">    InvestmentAmount = tostring(investmentAmount),</span>
<span class="fc" data-hits="1">    FeeAmount = tostring(feeAmount),</span>
<span class="fc" data-hits="1">    PositionId = positionId,</span>
<span class="fc" data-hits="1">    OutcomeTokensToBuy = tostring(outcomeTokensToBuy),</span>
<span class="fc" data-hits="1">    Data = &quot;Successful buy order&quot;</span>
  })
end

<span class="fc" data-hits="2">function CPMMNotices.sellNotice(from, returnAmount, feeAmount, positionId, outcomeTokensToSell)</span>
<span class="fc" data-hits="2">  return ao.send({</span>
<span class="fc" data-hits="1">    Target = from,</span>
<span class="fc" data-hits="1">    Action = &quot;Sell-Notice&quot;,</span>
<span class="fc" data-hits="1">    ReturnAmount = tostring(returnAmount),</span>
<span class="fc" data-hits="1">    FeeAmount = tostring(feeAmount),</span>
<span class="fc" data-hits="1">    PositionId = positionId,</span>
<span class="fc" data-hits="1">    OutcomeTokensToSell = tostring(outcomeTokensToSell),</span>
<span class="fc" data-hits="1">    Data = &quot;Successful sell order&quot;</span>
  })
end

<span class="fc" data-hits="2">function CPMMNotices.updateConfiguratorNotice(configurator, msg)</span>
<span class="fc" data-hits="2">  return msg.reply({</span>
<span class="fc" data-hits="1">    Action = &quot;Configurator-Updated&quot;,</span>
<span class="fc" data-hits="1">    Data = configurator</span>
  })
end

<span class="fc" data-hits="2">function CPMMNotices.updateIncentivesNotice(incentives, msg)</span>
<span class="fc" data-hits="2">  return msg.reply({</span>
<span class="fc" data-hits="1">    Action = &quot;Incentives-Updated&quot;,</span>
<span class="fc" data-hits="1">    Data = incentives</span>
  })
end

<span class="fc" data-hits="2">function CPMMNotices.updateTakeFeeNotice(creatorFee, protocolFee, takeFee, msg)</span>
<span class="fc" data-hits="2">  return msg.reply({</span>
<span class="fc" data-hits="1">    Action = &quot;Take-Fee-Updated&quot;,</span>
<span class="fc" data-hits="1">    CreatorFee = tostring(creatorFee),</span>
<span class="fc" data-hits="1">    ProtocolFee = tostring(protocolFee),</span>
<span class="fc" data-hits="1">    Data = tostring(takeFee)</span>
  })
end

<span class="fc" data-hits="2">function CPMMNotices.updateProtocolFeeTargetNotice(protocolFeeTarget, msg)</span>
<span class="fc" data-hits="2">  return msg.reply({</span>
<span class="fc" data-hits="1">    Action = &quot;Protocol-Fee-Target-Updated&quot;,</span>
<span class="fc" data-hits="1">    Data = protocolFeeTarget</span>
  })
end

<span class="fc" data-hits="2">function CPMMNotices.updateLogoNotice(logo, msg)</span>
<span class="fc" data-hits="2">  return msg.reply({</span>
<span class="fc" data-hits="1">    Action = &quot;Logo-Updated&quot;,</span>
<span class="fc" data-hits="1">    Data = logo</span>
  })
end

<span class="fc" data-hits="2">return CPMMNotices</span>
</pre>
      </div>

      <div class="hidden file success-low" id="src-modules-cpmmvalidation">
         <h2 class="title">
            src/modules/cpmmValidation.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 69.81%"></span>
                  <span><strong>69.81%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>37</strong> Hits</span>
               <span class="miss"><strong>16</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums"><span class="fc" data-hits="1">local bint = require(&#39;.bint&#39;)(256)</span>
<span class="fc" data-hits="1">local utils = require(&#39;utils&#39;)</span>
<span class="fc" data-hits="1">local sharedUtils = require(&#39;modules.sharedUtils&#39;)</span>

<span class="fc" data-hits="1">local cpmmValidation = {}</span>

local function validateAddress(recipient, tagName)
<span class="fc" data-hits="26">  assert(type(recipient) == &#39;string&#39;, tagName .. &#39; is required!&#39;)</span>
<span class="fc" data-hits="25">  assert(sharedUtils.isValidArweaveAddress(recipient), tagName .. &#39; must be a valid Arweave address!&#39;)</span>
end

local function validatePositionId(positionId)
<span class="nc">  assert(type(positionId) == &#39;string&#39;, &#39;PositionId is required!&#39;)</span>
<span class="nc">  assert(utils.includes(positionId, CPMM.tokens.positionIds), &#39;Invalid positionId!&#39;)</span>
end

local function validatePositiveInteger(quantity, tagName)
<span class="fc" data-hits="36">  assert(type(quantity) == &#39;string&#39;, tagName .. &#39; is required!&#39;)</span>
<span class="fc" data-hits="33">  assert(tonumber(quantity), tagName .. &#39; must be a number!&#39;)</span>
<span class="fc" data-hits="30">  assert(tonumber(quantity) &gt; 0, tagName .. &#39; must be greater than zero!&#39;)</span>
<span class="fc" data-hits="24">  assert(tonumber(quantity) % 1 == 0, tagName .. &#39; must be an integer!&#39;)</span>
end

<span class="fc" data-hits="1">function cpmmValidation.init(msg)</span>
  -- ownable.onlyOwner(msg) -- access control TODO: test after spawning is enabled
<span class="fc" data-hits="25">  assert(CPMM.initialized == false, &quot;Market already initialized!&quot;)</span>
<span class="fc" data-hits="24">  assert(msg.Tags.MarketId, &quot;MarketId is required!&quot;)</span>
<span class="fc" data-hits="23">  assert(msg.Tags.ConditionId, &quot;ConditionId is required!&quot;)</span>
<span class="fc" data-hits="22">  validateAddress(msg.Tags.CollateralToken, &quot;CollateralToken&quot;)</span>
<span class="fc" data-hits="20">  validatePositiveInteger(msg.Tags.OutcomeSlotCount, &quot;OutcomeSlotCount&quot;)</span>
<span class="fc" data-hits="15">  local outcomeSlotCount = tonumber(msg.Tags.OutcomeSlotCount)</span>
  -- Limit of 256 because we use a partition array that is a number of 256 bits.
<span class="fc" data-hits="15">  assert(outcomeSlotCount &lt;= 256, &quot;Too many outcome slots!&quot;)</span>
<span class="fc" data-hits="14">  assert(outcomeSlotCount &gt; 1, &quot;There should be more than one outcome slot!&quot;)</span>
  -- LP Token Parameters
<span class="fc" data-hits="13">  assert(msg.Tags.Name, &quot;Name is required!&quot;)</span>
<span class="fc" data-hits="12">  assert(msg.Tags.Ticker, &quot;Ticker is required!&quot;)</span>
<span class="fc" data-hits="11">  assert(msg.Tags.Logo, &quot;Logo is required!&quot;)</span>
  -- Fee Parameters
<span class="fc" data-hits="10">  validatePositiveInteger(msg.Tags.LpFee, &quot;LpFee&quot;)</span>
<span class="fc" data-hits="5">  validatePositiveInteger(msg.Tags.CreatorFee, &quot;CreatorFee&quot;)</span>
<span class="fc" data-hits="1">  validatePositiveInteger(msg.Tags.ProtocolFee, &quot;ProtocolFee&quot;)</span>
<span class="fc" data-hits="1">  validateAddress(msg.Tags.CreatorFeeTarget, &quot;CreatorFeeTarget&quot;)</span>
<span class="fc" data-hits="1">  validateAddress(msg.Tags.ProtocolFeeTarget, &quot;ProtocolFeeTarget&quot;)</span>
  -- Take Fee Capped at 1000 bps, ie. 10%
<span class="fc" data-hits="1">  assert(bint.__le(bint.__add(bint(msg.Tags.CreatorFee), bint(msg.Tags.ProtocolFee)), 1000), &#39;Take Fee capped at 10%!&#39;)</span>
  -- Admin Parameter
<span class="fc" data-hits="1">  validateAddress(msg.Tags.Configurator, &quot;Configurator&quot;)</span>
  -- Incentives
<span class="fc" data-hits="1">  validateAddress(msg.Tags.Incentives, &quot;Incentives&quot;)</span>
  -- @dev TODO: include &quot;resolve-by&quot; field to enable fallback resolution
end

<span class="fc" data-hits="1">function cpmmValidation.addFunding(msg)</span>
<span class="nc">  validatePositiveInteger(msg.Tags.Quantity, &quot;Quantity&quot;)</span>
<span class="nc">  assert(msg.Tags[&#39;X-Distribution&#39;], &#39;X-Distribution is required!&#39;)</span>
<span class="nc">  assert(sharedUtils.isJSONArray(msg.Tags[&#39;X-Distribution&#39;]), &#39;X-Distribution must be valid JSON Array!&#39;)</span>
  -- @dev TODO: remove requirement for X-Distribution
end

<span class="fc" data-hits="1">function cpmmValidation.removeFunding(msg)</span>
<span class="nc">  validatePositiveInteger(msg.Tags.Quantity, &quot;Quantity&quot;)</span>
end

<span class="fc" data-hits="1">function cpmmValidation.buy(msg)</span>
<span class="nc">  validatePositionId(msg.Tags.PositionId)</span>
<span class="nc">  validatePositiveInteger(msg.Tags.Quantity, &quot;Quantity&quot;)</span>
end

<span class="fc" data-hits="1">function cpmmValidation.sell(msg)</span>
<span class="nc">  validatePositionId(msg.Tags.PositionId)</span>
<span class="nc">  validatePositiveInteger(msg.Tags.Quantity, &quot;Quantity&quot;)</span>
<span class="nc">  validatePositiveInteger(msg.Tags.ReturnAmount, &quot;ReturnAmount&quot;)</span>
<span class="nc">  validatePositiveInteger(msg.Tags.MaxOutcomeTokensToSell, &quot;MaxOutcomeTokensToSell&quot;)</span>
end

<span class="fc" data-hits="1">function cpmmValidation.calcBuyAmount(msg)</span>
<span class="nc">  validatePositionId(msg.Tags.PositionId)</span>
<span class="nc">  validatePositiveInteger(msg.Tags.InvestmentAmount, &quot;InvestmentAmount&quot;)</span>
end

<span class="fc" data-hits="1">function cpmmValidation.calcSellAmount(msg)</span>
<span class="nc">  validatePositionId(msg.Tags.PositionId)</span>
<span class="nc">  validatePositiveInteger(msg.Tags.ReturnAmount, &quot;ReturnAmount&quot;)</span>
end

<span class="fc" data-hits="1">return cpmmValidation</span>
</pre>
      </div>

      <div class="hidden file success-high" id="src-modules-semifungibletokens">
         <h2 class="title">
            src/modules/semiFungibleTokens.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 100.00%"></span>
                  <span><strong>100.00%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>123</strong> Hits</span>
               <span class="miss"><strong>0</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums"><span class="fc" data-hits="3">local ao = require(&#39;.ao&#39;)</span>
<span class="fc" data-hits="3">local json = require(&#39;json&#39;)</span>
<span class="fc" data-hits="3">local bint = require(&#39;.bint&#39;)(256)</span>

<span class="fc" data-hits="3">local SemiFungibleTokens = {}</span>
<span class="fc" data-hits="3">local SemiFungibleTokensMethods = require(&#39;modules.semiFungibleTokensNotices&#39;)</span>

-- Constructor for SemiFungibleTokens 
<span class="fc" data-hits="3">function SemiFungibleTokens:new()</span>
  -- This will store user semi-fungible tokens balances and metadata
<span class="fc" data-hits="29">  local obj = {</span>
<span class="fc" data-hits="29">    name = &#39;&#39;,</span>
<span class="fc" data-hits="29">    ticker = &#39;&#39;,</span>
<span class="fc" data-hits="29">    logo = &#39;&#39;,</span>
<span class="fc" data-hits="29">    balancesById = {},  -- { id -&gt; userId -&gt; balance of semi-fungible tokens }</span>
<span class="fc" data-hits="29">    totalSupplyById = {}, -- { id -&gt; totalSupply of semi-fungible tokens }</span>
<span class="fc" data-hits="29">    denomination = 12</span>
  }
<span class="fc" data-hits="29">  setmetatable(obj, { __index = SemiFungibleTokensMethods })</span>
<span class="fc" data-hits="29">  return obj</span>
end

-- @dev Mint a quantity of a token with the given ID
-- @param to The address that will own the minted token
-- @param id ID of the token to be minted
-- @param quantity Quantity of the token to be minted
<span class="fc" data-hits="3">function SemiFungibleTokensMethods:mint(to, id, quantity, msg)</span>
<span class="fc" data-hits="6">  assert(quantity, &#39;Quantity is required!&#39;)</span>
<span class="fc" data-hits="6">  assert(bint.__lt(0, quantity), &#39;Quantity must be greater than zero!&#39;)</span>

<span class="fc" data-hits="6">  if not self.balancesById[id] then self.balancesById[id] = {} end</span>
<span class="fc" data-hits="6">  if not self.balancesById[id][to] then self.balancesById[id][to] = &quot;0&quot; end</span>
<span class="fc" data-hits="6">  if not self.totalSupplyById[id] then self.totalSupplyById[id] = &quot;0&quot; end</span>

<span class="fc" data-hits="6">  self.balancesById[id][to] = tostring(bint.__add(self.balancesById[id][to], quantity))</span>
<span class="fc" data-hits="6">  self.totalSupplyById[id] = tostring(bint.__add(self.totalSupplyById[id], quantity))</span>
  -- Send notice
<span class="fc" data-hits="6">  return self.mintSingleNotice(to, id, quantity, msg)</span>
end

-- @dev Batch mint quantities of tokens with the given IDs
-- @param to The address that will own the minted token
-- @param ids IDs of the tokens to be minted
-- @param quantities Quantities of the tokens to be minted
<span class="fc" data-hits="3">function SemiFungibleTokensMethods:batchMint(to, ids, quantities, msg)</span>
<span class="fc" data-hits="9">  assert(#ids == #quantities, &#39;Ids and quantities must have the same lengths&#39;)</span>

<span class="fc" data-hits="36">  for i = 1, #ids do</span>
    -- @dev spacing to resolve text to code eval issue
<span class="fc" data-hits="27">    if not self.balancesById[ ids[i] ] then self.balancesById[ ids[i] ] = {} end</span>
<span class="fc" data-hits="27">    if not self.balancesById[ ids[i] ][to] then self.balancesById[ ids[i] ][to] = &quot;0&quot; end</span>
<span class="fc" data-hits="27">    if not self.totalSupplyById[ ids[i] ] then self.totalSupplyById[ ids[i] ] = &quot;0&quot; end</span>

<span class="fc" data-hits="27">    self.balancesById[ ids[i] ][to] = tostring(bint.__add(self.balancesById[ ids[i] ][to], quantities[i]))</span>
<span class="fc" data-hits="27">    self.totalSupplyById[ ids[i] ] = tostring(bint.__add(self.totalSupplyById[ ids[i] ], quantities[i]))</span>
  end

  -- Send notice
<span class="fc" data-hits="9">  return self.mintBatchNotice(to, ids, quantities, msg)</span>
end

-- @dev Burn a quantity of a token with the given ID
-- @param from The address that will burn the token
-- @param id ID of the token to be burned
-- @param quantity Quantity of the token to be burned
<span class="fc" data-hits="3">function SemiFungibleTokensMethods:burn(from, id, quantity, msg)</span>
<span class="fc" data-hits="1">  assert(bint.__lt(0, quantity), &#39;Quantity must be greater than zero!&#39;)</span>
<span class="fc" data-hits="1">  assert(self.balancesById[id], &#39;Id must exist! &#39; .. id)</span>
<span class="fc" data-hits="1">  assert(self.balancesById[id][from], &#39;User must hold token! :: &#39; .. id)</span>
<span class="fc" data-hits="1">  assert(bint.__le(quantity, self.balancesById[id][from]), &#39;User must have sufficient tokens! &#39; .. id)</span>

  -- Burn tokens
<span class="fc" data-hits="1">  self.balancesById[id][from] = tostring(bint.__sub(self.balancesById[id][from], quantity))</span>
<span class="fc" data-hits="1">  self.totalSupplyById[id] = tostring(bint.__sub(self.totalSupplyById[id], quantity))</span>
  -- Send notice
<span class="fc" data-hits="1">  return self.burnSingleNotice(from, id, quantity, msg)</span>
end

-- @dev Batch burn quantities of tokens with the given IDs
-- @param from The address that will burn the tokens
-- @param ids IDs of the tokens to be burned
-- @param quantities Quantities of the tokens to be burned
-- @param msg For sending X-Tags
<span class="fc" data-hits="3">function SemiFungibleTokensMethods:batchBurn(from, ids, quantities, msg)</span>
<span class="fc" data-hits="5">  assert(#ids == #quantities, &#39;Ids and quantities must have the same lengths&#39;)</span>

<span class="fc" data-hits="14">  for i = 1, #ids do</span>
<span class="fc" data-hits="11">    assert(bint.__lt(0, quantities[i]), &#39;Quantity must be greater than zero!&#39;)</span>
<span class="fc" data-hits="11">    assert(self.balancesById[ ids[i] ], &#39;Id must exist! &#39; .. ids[i])</span>
<span class="fc" data-hits="10">    assert(self.balancesById[ ids[i] ][from], &#39;User must hold token! &#39; .. ids[i])</span>
<span class="fc" data-hits="9">    assert(bint.__le(quantities[i], self.balancesById[ ids[i] ][from]), &#39;User must have sufficient tokens!&#39;)</span>
  end

<span class="fc" data-hits="3">  local remainingBalances = {}</span>

  -- Burn tokens
<span class="fc" data-hits="12">  for i = 1, #ids do</span>
<span class="fc" data-hits="9">    self.balancesById[ ids[i] ][from] = tostring(bint.__sub(self.balancesById[ ids[i] ][from], quantities[i]))</span>
<span class="fc" data-hits="9">    self.totalSupplyById[ ids[i] ] = tostring(bint.__sub(self.totalSupplyById[ ids[i] ], quantities[i]))</span>
<span class="fc" data-hits="9">    remainingBalances[i] = self.balancesById[ ids[i] ][from]</span>
  end
  -- Draft notice
<span class="fc" data-hits="3">  local notice = {</span>
<span class="fc" data-hits="3">    Recipient = from,</span>
<span class="fc" data-hits="3">    TokenIds = json.encode(ids),</span>
<span class="fc" data-hits="3">    Quantities = json.encode(quantities),</span>
<span class="fc" data-hits="3">    RemainingBalances = json.encode(remainingBalances),</span>
<span class="fc" data-hits="3">    Action = &#39;Burn-Batch-Notice&#39;,</span>
<span class="fc" data-hits="3">    Data = &quot;Successfully burned batch&quot;</span>
  }
  -- Forward X-Tags
<span class="fc" data-hits="13">  for tagName, tagValue in pairs(msg) do</span>
    -- Tags beginning with &quot;X-&quot; are forwarded
<span class="fc" data-hits="10">    if string.sub(tagName, 1, 2) == &quot;X-&quot; then</span>
<span class="fc" data-hits="1">      notice[tagName] = tagValue</span>
    end
  end
  -- Send notice
<span class="fc" data-hits="3">  return self.burnBatchNotice(notice, msg)</span>
end

-- @dev Transfer a quantity of tokens with the given ID
-- @param from The address to be debited
-- @param recipient The address to be credited
-- @param id ID of the tokens to be transferred
-- @param quantity Quantity of the tokens to be transferred
-- @param cast The boolean to silence transfer notifications
-- @param msg For sending X-Tags
<span class="fc" data-hits="3">function SemiFungibleTokensMethods:transferSingle(from, recipient, id, quantity, cast, msg)</span>
<span class="fc" data-hits="2">  if not self.balancesById[id] then self.balancesById[id] = {} end</span>
<span class="fc" data-hits="2">  if not self.balancesById[id][from] then self.balancesById[id][from] = &quot;0&quot; end</span>
<span class="fc" data-hits="2">  if not self.balancesById[id][recipient] then self.balancesById[id][recipient] = &quot;0&quot; end</span>

<span class="fc" data-hits="2">  local qty = bint(quantity)</span>
<span class="fc" data-hits="2">  local balance = bint(self.balancesById[id][from])</span>
<span class="fc" data-hits="2">  if bint.__le(qty, balance) then</span>
<span class="fc" data-hits="1">    self.balancesById[id][from] = tostring(bint.__sub(balance, qty))</span>
<span class="fc" data-hits="1">    self.balancesById[id][recipient] = tostring(bint.__add(self.balancesById[id][recipient], qty))</span>

    -- Only send the notifications if the cast tag is not set
<span class="fc" data-hits="1">    if not cast then</span>
<span class="fc" data-hits="1">      return self.transferSingleNotices(from, recipient, id, quantity, msg)</span>
    end
  else
<span class="fc" data-hits="1">    return self.transferErrorNotice(id, msg)</span>
  end
end

-- @dev Batch transfer quantities of tokens with the given IDs
-- @param from The address to be debited
-- @param recipient The address to be credited
-- @param ids IDs of the tokens to be transferred
-- @param quantities Quantities of the tokens to be transferred
-- @param cast The boolean to silence transfer notifications
-- @param msg For sending X-Tags
<span class="fc" data-hits="3">function SemiFungibleTokensMethods:transferBatch(from, recipient, ids, quantities, cast, msg)</span>
<span class="fc" data-hits="2">  local ids_ = {}</span>
<span class="fc" data-hits="2">  local quantities_ = {}</span>

<span class="fc" data-hits="5">  for i = 1, #ids do</span>
<span class="fc" data-hits="4">    if not self.balancesById[ ids[i] ] then self.balancesById[ ids[i] ] = {} end</span>
<span class="fc" data-hits="4">    if not self.balancesById[ ids[i] ][from] then self.balancesById[ ids[i] ][from] = &quot;0&quot; end</span>
<span class="fc" data-hits="4">    if not self.balancesById[ ids[i] ][recipient] then self.balancesById[ ids[i] ][recipient] = &quot;0&quot; end</span>

<span class="fc" data-hits="4">    local qty = bint(quantities[i])</span>
<span class="fc" data-hits="4">    local balance = bint(self.balancesById[ ids[i] ][from])</span>

<span class="fc" data-hits="4">    if bint.__le(qty, balance) then</span>
<span class="fc" data-hits="3">      self.balancesById[ ids[i] ][from] = tostring(bint.__sub(balance, qty))</span>
<span class="fc" data-hits="3">      self.balancesById[ ids[i] ][recipient] = tostring(bint.__add(self.balancesById[ ids[i] ][recipient], qty))</span>
<span class="fc" data-hits="3">      table.insert(ids_, ids[i])</span>
<span class="fc" data-hits="3">      table.insert(quantities_, quantities[i])</span>
    else
<span class="fc" data-hits="1">      return self.transferErrorNotice(ids[i], msg)</span>
    end
  end

  -- Only send the notifications if the cast tag is not set
<span class="fc" data-hits="1">  if not cast and #ids_ &gt; 0 then</span>
<span class="fc" data-hits="1">    return self.transferBatchNotices(from, recipient, ids_, quantities_, msg)</span>
  end
end

<span class="fc" data-hits="3">function SemiFungibleTokensMethods:getBalance(from, recipient, tokenId)</span>
<span class="fc" data-hits="2">  local bal = &#39;0&#39;</span>
  -- If Id is found then cointinue
<span class="fc" data-hits="2">  if self.balancesById[tokenId] then</span>
    -- If not Recipient is provided, then return the Senders balance
<span class="fc" data-hits="2">    if (recipient and self.balancesById[tokenId][recipient]) then</span>
<span class="fc" data-hits="1">      bal = self.balancesById[tokenId][recipient]</span>
<span class="fc" data-hits="1">    elseif self.balancesById[tokenId][from] then</span>
<span class="fc" data-hits="1">      bal = self.balancesById[tokenId][from]</span>
    end
  end
  -- return balance
<span class="fc" data-hits="2">  return bal</span>
end

<span class="fc" data-hits="3">function SemiFungibleTokensMethods:getBatchBalance(recipients, tokenIds)</span>
<span class="fc" data-hits="1">  assert(#recipients == #tokenIds, &#39;Recipients and TokenIds must have same lengths&#39;)</span>
<span class="fc" data-hits="1">  local bals = {}</span>

<span class="fc" data-hits="4">  for i = 1, #recipients do</span>
<span class="fc" data-hits="3">    table.insert(bals, &#39;0&#39;)</span>
<span class="fc" data-hits="3">    if self.balancesById[ tokenIds[i] ] then</span>
<span class="fc" data-hits="3">      if self.balancesById[ tokenIds[i] ][ recipients[i] ] then</span>
<span class="fc" data-hits="3">        bals[i] = self.balancesById[ tokenIds[i] ][ recipients[i] ]</span>
      end
    end
  end

<span class="fc" data-hits="1">  return bals</span>
end

<span class="fc" data-hits="3">function SemiFungibleTokensMethods:getBalances(tokenId)</span>
<span class="fc" data-hits="1">  local bals = {}</span>
<span class="fc" data-hits="1">  if self.balancesById[tokenId] then</span>
<span class="fc" data-hits="1">    bals = self.balancesById[tokenId]</span>
  end
  -- return balances
<span class="fc" data-hits="1">  return bals</span>
end

<span class="fc" data-hits="3">function SemiFungibleTokensMethods:getBatchBalances(tokenIds)</span>
<span class="fc" data-hits="1">  local bals = {}</span>

<span class="fc" data-hits="4">  for i = 1, #tokenIds do</span>
<span class="fc" data-hits="3">    bals[ tokenIds[i] ] = {}</span>
<span class="fc" data-hits="3">    if self.balancesById[ tokenIds[i] ] then</span>
<span class="fc" data-hits="3">      bals[ tokenIds[i] ] = self.balancesById[ tokenIds[i] ]</span>
    end
  end
  -- return balances
<span class="fc" data-hits="1">  return bals</span>
end

<span class="fc" data-hits="3">return SemiFungibleTokens</span>
</pre>
      </div>

      <div class="hidden file success-high" id="src-modules-semifungibletokensnotices">
         <h2 class="title">
            src/modules/semiFungibleTokensNotices.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 100.00%"></span>
                  <span><strong>100.00%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>78</strong> Hits</span>
               <span class="miss"><strong>0</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums"><span class="fc" data-hits="4">local ao = require(&#39;.ao&#39;)</span>
<span class="fc" data-hits="4">local json = require(&#39;json&#39;)</span>

<span class="fc" data-hits="4">local SemiFungibleTokensNotices = {}</span>

-- @dev Mint single token notice
-- @param to The address that will own the minted token
-- @param id ID of the token to be minted
-- @param quantity Quantity of the token to be minted
<span class="fc" data-hits="4">function SemiFungibleTokensNotices.mintSingleNotice(to, id, quantity, msg)</span>
<span class="fc" data-hits="14">  return msg.reply({</span>
<span class="fc" data-hits="7">    Recipient = to,</span>
<span class="fc" data-hits="7">    TokenId = tostring(id),</span>
<span class="fc" data-hits="7">    Quantity = tostring(quantity),</span>
<span class="fc" data-hits="7">    Action = &#39;Mint-Single-Notice&#39;,</span>
<span class="fc" data-hits="7">    Data = Colors.gray .. &quot;Successfully minted &quot; .. Colors.blue .. tostring(quantity) .. Colors.gray .. &quot; of id &quot; .. Colors.blue .. tostring(id) .. Colors.reset</span>
  })
end

-- @dev Mint batch notice
-- @param to The address that will own the minted token
-- @param ids IDs of the tokens to be minted
-- @param quantities Quantities of the tokens to be minted
<span class="fc" data-hits="4">function SemiFungibleTokensNotices.mintBatchNotice(to, ids, quantities, msg)</span>
<span class="fc" data-hits="20">  return msg.reply({</span>
<span class="fc" data-hits="10">    Recipient = to,</span>
<span class="fc" data-hits="10">    TokenIds = json.encode(ids),</span>
<span class="fc" data-hits="10">    Quantities = json.encode(quantities),</span>
<span class="fc" data-hits="10">    Action = &#39;Mint-Batch-Notice&#39;,</span>
<span class="fc" data-hits="10">    Data = &quot;Successfully minted batch&quot;</span>
  })
end

-- @dev Burn single token notice
-- @param from The address that will burn the token
-- @param id ID of the token to be burned
-- @param quantity Quantity of the token to be burned
<span class="fc" data-hits="4">function SemiFungibleTokensNotices.burnSingleNotice(from, id, quantity, msg)</span>
  -- Prepare notice
<span class="fc" data-hits="2">  local notice = {</span>
<span class="fc" data-hits="2">    Recipient = from,</span>
<span class="fc" data-hits="2">    TokenId = tostring(id),</span>
<span class="fc" data-hits="2">    Quantity = tostring(quantity),</span>
<span class="fc" data-hits="2">    Action = &#39;Burn-Single-Notice&#39;,</span>
<span class="fc" data-hits="2">    Data = Colors.gray .. &quot;Successfully burned &quot; .. Colors.blue .. tostring(quantity) .. Colors.gray .. &quot; of id &quot; .. Colors.blue .. tostring(id) .. Colors.reset</span>
  }
  -- Forward X-Tags
<span class="fc" data-hits="10">  for tagName, tagValue in pairs(msg) do</span>
    -- Tags beginning with &quot;X-&quot; are forwarded
<span class="fc" data-hits="8">    if string.sub(tagName, 1, 2) == &quot;X-&quot; then</span>
<span class="fc" data-hits="2">      notice[tagName] = tagValue</span>
    end
  end
  -- Send notice
<span class="fc" data-hits="2">  return msg.reply(notice)</span>
end

-- @dev Burn batch tokens notice
-- @param notice The prepared notice to be sent
<span class="fc" data-hits="4">function SemiFungibleTokensNotices.burnBatchNotice(notice, msg)</span>
  -- Forward X-Tags
<span class="fc" data-hits="18">  for tagName, tagValue in pairs(msg) do</span>
    -- Tags beginning with &quot;X-&quot; are forwarded
<span class="fc" data-hits="14">    if string.sub(tagName, 1, 2) == &quot;X-&quot; then</span>
<span class="fc" data-hits="2">      notice[tagName] = tagValue</span>
    end
  end
  -- Send notice
<span class="fc" data-hits="4">  return msg.reply(notice)</span>
end

-- @dev Transfer single token notices
-- @param from The address to be debited
-- @param to The address to be credited
-- @param id ID of the tokens to be transferred
-- @param quantity Quantity of the tokens to be transferred
-- @param msg For sending X-Tags
<span class="fc" data-hits="4">function SemiFungibleTokensNotices.transferSingleNotices(from, to, id, quantity, msg)</span>
  -- Prepare debit notice
<span class="fc" data-hits="2">  local debitNotice = {</span>
<span class="fc" data-hits="2">    Action = &#39;Debit-Single-Notice&#39;,</span>
<span class="fc" data-hits="2">    Recipient = to,</span>
<span class="fc" data-hits="2">    TokenId = tostring(id),</span>
<span class="fc" data-hits="2">    Quantity = tostring(quantity),</span>
<span class="fc" data-hits="2">    Data = Colors.gray .. &quot;You transferred &quot; .. Colors.blue .. tostring(quantity) .. Colors.gray .. &quot; of id &quot; .. Colors.blue .. tostring(id) .. Colors.gray .. &quot; to &quot; .. Colors.green .. to .. Colors.reset</span>
  }
  -- Prepare credit notice
<span class="fc" data-hits="2">  local creditNotice = {</span>
<span class="fc" data-hits="2">    Target = to,</span>
<span class="fc" data-hits="2">    Action = &#39;Credit-Single-Notice&#39;,</span>
<span class="fc" data-hits="2">    Sender = from,</span>
<span class="fc" data-hits="2">    TokenId = tostring(id),</span>
<span class="fc" data-hits="2">    Quantity = tostring(quantity),</span>
<span class="fc" data-hits="2">    Data = Colors.gray .. &quot;You received &quot; .. Colors.blue .. tostring(quantity) .. Colors.gray .. &quot; of id &quot; .. Colors.blue .. tostring(id) .. Colors.gray .. &quot; from &quot; .. Colors.green .. from .. Colors.reset</span>
  }
  -- Forward X-Tags
<span class="fc" data-hits="12">  for tagName, tagValue in pairs(msg) do</span>
    -- Tags beginning with &quot;X-&quot; are forwarded
<span class="fc" data-hits="10">    if string.sub(tagName, 1, 2) == &quot;X-&quot; then</span>
<span class="fc" data-hits="2">      debitNotice[tagName] = tagValue</span>
<span class="fc" data-hits="2">      creditNotice[tagName] = tagValue</span>
    end
  end
  -- Send notices
<span class="fc" data-hits="2">  return { msg.reply(debitNotice), ao.send(creditNotice) }</span>
end

-- @dev Transfer batch tokens notices
-- @param from The address to be debited
-- @param to The address to be credited
-- @param ids IDs of the tokens to be transferred
-- @param quantities Quantities of the tokens to be transferred
-- @param msg For sending X-Tags
<span class="fc" data-hits="4">function SemiFungibleTokensNotices.transferBatchNotices(from, to, ids, quantities, msg)</span>
  -- Prepare debit notice
<span class="fc" data-hits="2">  local debitNotice = {</span>
<span class="fc" data-hits="2">    Action = &#39;Debit-Batch-Notice&#39;,</span>
<span class="fc" data-hits="2">    Recipient = to,</span>
<span class="fc" data-hits="2">    TokenIds = json.encode(ids),</span>
<span class="fc" data-hits="2">    Quantities = json.encode(quantities),</span>
<span class="fc" data-hits="2">    Data = Colors.gray .. &quot;You transferred batch to &quot; .. Colors.green .. to .. Colors.reset</span>
  }
  -- Prepare credit notice
<span class="fc" data-hits="2">  local creditNotice = {</span>
<span class="fc" data-hits="2">    Target = to,</span>
<span class="fc" data-hits="2">    Action = &#39;Credit-Batch-Notice&#39;,</span>
<span class="fc" data-hits="2">    Sender = from,</span>
<span class="fc" data-hits="2">    TokenIds = json.encode(ids),</span>
<span class="fc" data-hits="2">    Quantities = json.encode(quantities),</span>
<span class="fc" data-hits="2">    Data = Colors.gray .. &quot;You received batch from &quot; .. Colors.green .. from .. Colors.reset</span>
  }
  -- Forward X-Tags
<span class="fc" data-hits="12">  for tagName, tagValue in pairs(msg) do</span>
    -- Tags beginning with &quot;X-&quot; are forwarded
<span class="fc" data-hits="10">    if string.sub(tagName, 1, 2) == &quot;X-&quot; then</span>
<span class="fc" data-hits="2">      debitNotice[tagName] = tagValue</span>
<span class="fc" data-hits="2">      creditNotice[tagName] = tagValue</span>
    end
  end
  -- Send notice
<span class="fc" data-hits="2">  return {msg.reply(debitNotice), ao.send(creditNotice)}</span>
end

-- @dev Transfer error notice
-- @param from The address to be debited
-- @param id ID of the tokens to be transferred
-- @param msg The message
<span class="fc" data-hits="4">function SemiFungibleTokensNotices.transferErrorNotice(id, msg)</span>
<span class="fc" data-hits="6">  return msg.reply({</span>
<span class="fc" data-hits="3">    Action = &#39;Transfer-Error&#39;,</span>
<span class="fc" data-hits="3">    [&#39;Message-Id&#39;] = msg.Id,</span>
<span class="fc" data-hits="3">    [&#39;Token-Id&#39;] = id,</span>
<span class="fc" data-hits="3">    Error = &#39;Insufficient Balance!&#39;</span>
  })
end

<span class="fc" data-hits="4">return SemiFungibleTokensNotices</span>
</pre>
      </div>

      <div class="hidden file success-high" id="src-modules-semifungibletokensvalidation">
         <h2 class="title">
            src/modules/semiFungibleTokensValidation.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 100.00%"></span>
                  <span><strong>100.00%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>49</strong> Hits</span>
               <span class="miss"><strong>0</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums"><span class="fc" data-hits="1">local json = require(&quot;json&quot;)</span>
<span class="fc" data-hits="1">local bint = require(&#39;.bint&#39;)(256)</span>
<span class="fc" data-hits="1">local utils = require(&#39;.utils&#39;)</span>
<span class="fc" data-hits="1">local sharedUtils = require(&#39;modules.sharedUtils&#39;)</span>

<span class="fc" data-hits="1">local semiFunctionalTokensValidation = {}</span>

local function validateRecipient(recipient)
<span class="fc" data-hits="29">  assert(type(recipient) == &#39;string&#39;, &#39;Recipient is required!&#39;)</span>
<span class="fc" data-hits="27">  assert(sharedUtils.isValidArweaveAddress(recipient), &#39;Recipient must be a valid Arweave address!&#39;)</span>
end

local function validateTokenId(tokenId)
<span class="fc" data-hits="44">  assert(type(tokenId) == &#39;string&#39;, &#39;TokenId is required!&#39;)</span>
<span class="fc" data-hits="43">  assert(utils.includes(tokenId, CPMM.tokens.positionIds), &#39;Invalid tokenId!&#39;)</span>
end

local function validateQuantity(quantity)
<span class="fc" data-hits="26">  assert(type(quantity) == &#39;string&#39;, &#39;Quantity is required!&#39;)</span>
<span class="fc" data-hits="24">  assert(tonumber(quantity), &#39;Quantity must be a number!&#39;)</span>
<span class="fc" data-hits="22">  assert(tonumber(quantity) &gt; 0, &#39;Quantity must be greater than zero!&#39;)</span>
<span class="fc" data-hits="18">  assert(tonumber(quantity) % 1 == 0, &#39;Quantity must be an integer!&#39;)</span>
end

<span class="fc" data-hits="1">function semiFunctionalTokensValidation.transferSingle(msg)</span>
<span class="fc" data-hits="10">  validateRecipient(msg.Tags.Recipient)</span>
<span class="fc" data-hits="8">  validateTokenId(msg.Tags.TokenId)</span>
<span class="fc" data-hits="6">  validateQuantity(msg.Tags.Quantity)</span>
end

<span class="fc" data-hits="1">function semiFunctionalTokensValidation.transferBatch(msg)</span>
<span class="fc" data-hits="13">  validateRecipient(msg.Tags.Recipient)</span>
<span class="fc" data-hits="11">  assert(type(msg.Tags.TokenIds) == &#39;string&#39;, &#39;TokenIds is required!&#39;)</span>
<span class="fc" data-hits="10">  local tokenIds = json.decode(msg.Tags.TokenIds)</span>
<span class="fc" data-hits="10">  assert(type(msg.Tags.Quantities) == &#39;string&#39;, &#39;Quantities is required!&#39;)</span>
<span class="fc" data-hits="9">  local quantities = json.decode(msg.Tags.Quantities)</span>
<span class="fc" data-hits="9">  assert(#tokenIds == #quantities, &#39;Input array lengths must match!&#39;)</span>
<span class="fc" data-hits="8">  assert(#tokenIds &gt; 0, &quot;Input array length must be greater than zero!&quot;)</span>
<span class="fc" data-hits="22">  for i = 1, #tokenIds do</span>
<span class="fc" data-hits="21">    validateTokenId(tokenIds[i])</span>
<span class="fc" data-hits="20">    validateQuantity(quantities[i])</span>
  end
end

<span class="fc" data-hits="1">function semiFunctionalTokensValidation.balanceById(msg)</span>
<span class="fc" data-hits="2">  validateTokenId(msg.Tags.TokenId)</span>
end

<span class="fc" data-hits="1">function semiFunctionalTokensValidation.balancesById(msg)</span>
<span class="fc" data-hits="2">  validateTokenId(msg.Tags.TokenId)</span>
end

<span class="fc" data-hits="1">function semiFunctionalTokensValidation.batchBalance(msg)</span>
<span class="fc" data-hits="4">  assert(msg.Tags.Recipients, &quot;Recipients is required!&quot;)</span>
<span class="fc" data-hits="3">  local recipients = json.decode(msg.Tags.Recipients)</span>
<span class="fc" data-hits="3">  assert(msg.Tags.TokenIds, &quot;TokenIds is required!&quot;)</span>
<span class="fc" data-hits="3">  local tokenIds = json.decode(msg.Tags.TokenIds)</span>
<span class="fc" data-hits="3">  assert(#recipients == #tokenIds, &quot;Input array lengths must match!&quot;)</span>
<span class="fc" data-hits="3">  assert(#recipients &gt; 0, &quot;Input array length must be greater than zero!&quot;)</span>
<span class="fc" data-hits="7">  for i = 1, #tokenIds do</span>
<span class="fc" data-hits="6">    validateRecipient(recipients[i])</span>
<span class="fc" data-hits="5">    validateTokenId(tokenIds[i])</span>
  end
end

<span class="fc" data-hits="1">function semiFunctionalTokensValidation.batchBalances(msg)</span>
<span class="fc" data-hits="4">  assert(msg.Tags.TokenIds, &quot;TokenIds is required!&quot;)</span>
<span class="fc" data-hits="3">  local tokenIds = json.decode(msg.Tags.TokenIds)</span>
<span class="fc" data-hits="3">  assert(#tokenIds &gt; 0, &quot;Input array length must be greater than zero!&quot;)</span>
<span class="fc" data-hits="7">  for i = 1, #tokenIds do</span>
<span class="fc" data-hits="6">    validateTokenId(tokenIds[i])</span>
  end
end

<span class="fc" data-hits="1">return semiFunctionalTokensValidation</span>
</pre>
      </div>

      <div class="hidden file success-high" id="src-modules-sharedutils">
         <h2 class="title">
            src/modules/sharedUtils.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 100.00%"></span>
                  <span><strong>100.00%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>35</strong> Hits</span>
               <span class="miss"><strong>0</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums"><span class="fc" data-hits="6">local sharedUtils = {}</span>

-- Function to validate if the extracted value is a valid JSON simple value
local function isSimpleValue(value)
  -- Trim whitespace
<span class="fc" data-hits="32">  value = value:match(&quot;^%s*(.-)%s*$&quot;) or value</span>

  -- Check for a quoted string: &quot;someValue&quot;
<span class="fc" data-hits="32">  if value:match(&#39;^&quot;[^&quot;]*&quot;$&#39;) then</span>
<span class="fc" data-hits="21">    return true</span>
  end

  -- Check for a number (integer or float, optional minus sign): 123, -123, 123.45
<span class="fc" data-hits="11">  if value:match(&#39;^[-]?%d+%.?%d*$&#39;) then</span>
<span class="fc" data-hits="7">    return true</span>
  end

  -- Check for boolean
<span class="fc" data-hits="4">  if value == &quot;true&quot; or value == &quot;false&quot; then</span>
<span class="fc" data-hits="1">    return true</span>
  end

<span class="fc" data-hits="3">  return false</span>
end

<span class="fc" data-hits="6">function sharedUtils.isValidKeyValueJSON(str)</span>
<span class="fc" data-hits="32">  if type(str) ~= &quot;string&quot; then return false end</span>

  -- Trim whitespace
<span class="fc" data-hits="32">  str = str:match(&quot;^%s*(.-)%s*$&quot;)</span>

  -- Ensure it starts with `{` and ends with `}`
<span class="fc" data-hits="32">  local isObject = str:match(&quot;^%{%s*(.-)%s*%}$&quot;)</span>
<span class="fc" data-hits="32">  if not isObject then return false end</span>

  -- This pattern only extracts the key and the entire raw value
<span class="fc" data-hits="28">  local keyValuePattern = &#39;^%s*&quot;([^&quot;]+)&quot;%s*:%s*(.-)%s*$&#39;</span>

  -- Check all key-value pairs
<span class="fc" data-hits="53">  for keyValue in isObject:gmatch(&quot;[^,]+&quot;) do</span>
<span class="fc" data-hits="28">    local key, rawValue = keyValue:match(keyValuePattern)</span>
<span class="fc" data-hits="28">    if not key or not rawValue then</span>
<span class="fc" data-hits="1">      return false</span>
    end

    -- Now validate that rawValue is a valid JSON simple value
<span class="fc" data-hits="27">    if not isSimpleValue(rawValue) then</span>
<span class="fc" data-hits="2">      return false</span>
    end
  end

<span class="fc" data-hits="25">  return true</span>
end

<span class="fc" data-hits="6">function sharedUtils.isJSONArray(str)</span>
<span class="fc" data-hits="3">  if type(str) ~= &quot;string&quot; then return false end</span>

  -- Trim whitespace
<span class="fc" data-hits="3">  str = str:match(&quot;^%s*(.-)%s*$&quot;)</span>

  -- Ensure it starts with `[` and ends with `]`
<span class="fc" data-hits="3">  local isArray = str:match(&quot;^%[%s*(.-)%s*%]$&quot;)</span>
<span class="fc" data-hits="3">  if not isArray then return false end</span>

  -- Split the array elements and validate each one
<span class="fc" data-hits="6">  for value in isArray:gmatch(&quot;[^,]+&quot;) do</span>
<span class="fc" data-hits="5">    value = value:match(&quot;^%s*(.-)%s*$&quot;) -- Trim whitespace around each value</span>
<span class="fc" data-hits="5">    if not isSimpleValue(value) then</span>
<span class="fc" data-hits="1">      return false</span>
    end
  end

<span class="fc" data-hits="1">  return true</span>
end

<span class="fc" data-hits="6">function sharedUtils.isValidArweaveAddress(address)</span>
<span class="fc" data-hits="87">	return type(address) == &quot;string&quot; and #address == 43 and string.match(address, &quot;^[%w-_]+$&quot;) ~= nil</span>
end

<span class="fc" data-hits="6">return sharedUtils</span>
</pre>
      </div>

      <div class="hidden file success-high" id="src-modules-token">
         <h2 class="title">
            src/modules/token.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 100.00%"></span>
                  <span><strong>100.00%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>61</strong> Hits</span>
               <span class="miss"><strong>0</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums"><span class="fc" data-hits="2">local bint = require(&#39;.bint&#39;)(256)</span>
<span class="fc" data-hits="2">local json = require(&#39;json&#39;)</span>
<span class="fc" data-hits="2">local ao = require(&#39;.ao&#39;)</span>

<span class="fc" data-hits="2">local Token = {}</span>
<span class="fc" data-hits="2">local TokenMethods = require(&#39;modules.tokenNotices&#39;)</span>

-- Constructor for Token 
<span class="fc" data-hits="2">function Token:new()</span>
  -- This will store user balances of tokens and metadata
<span class="fc" data-hits="10">  local obj = {</span>
<span class="fc" data-hits="10">    name = &#39;&#39;,</span>
<span class="fc" data-hits="10">    ticker = &#39;&#39;,</span>
<span class="fc" data-hits="10">    logo = &#39;&#39;,</span>
<span class="fc" data-hits="10">    balances = {},</span>
<span class="fc" data-hits="10">    totalSupply = &#39;0&#39;,</span>
<span class="fc" data-hits="10">    denomination = 12</span>
  }
<span class="fc" data-hits="10">  setmetatable(obj, { __index = TokenMethods })</span>
<span class="fc" data-hits="10">  return obj</span>
end

-- @dev Internal function to mint a quantity of tokens
-- @param to The address that will own the minted token
-- @param quantity Quantity of the token to be minted
<span class="fc" data-hits="2">function TokenMethods:mint(to, quantity, msg)</span>
<span class="fc" data-hits="3">  assert(quantity, &#39;Quantity is required!&#39;)</span>
<span class="fc" data-hits="3">  assert(bint.__lt(0, quantity), &#39;Quantity must be greater than zero!&#39;)</span>
  -- Mint tokens
<span class="fc" data-hits="3">  if not self.balances[to] then self.balances[to] = &#39;0&#39; end</span>
<span class="fc" data-hits="3">  self.balances[to] = tostring(bint.__add(bint(self.balances[to]), quantity))</span>
<span class="fc" data-hits="3">  self.totalSupply = tostring(bint.__add(bint(self.totalSupply), quantity))</span>
  -- Send notice
<span class="fc" data-hits="3">  return self.mintNotice(to, quantity, msg)</span>
end

-- @dev Internal function to burn a quantity of tokens
-- @param from The address that will burn the token
-- @param quantity Quantity of the token to be burned
<span class="fc" data-hits="2">function TokenMethods:burn(from, quantity, msg)</span>
<span class="fc" data-hits="1">  assert(bint.__lt(0, quantity), &#39;Quantity must be greater than zero!&#39;)</span>
<span class="fc" data-hits="1">  assert(self.balances[from], &#39;Must have token balance!&#39;)</span>
<span class="fc" data-hits="1">  assert(bint.__le(quantity, self.balances[from]), &#39;Must have sufficient tokens!&#39;)</span>
  -- Burn tokens
<span class="fc" data-hits="1">  self.balances[from] = tostring(bint.__sub(self.balances[from], quantity))</span>
<span class="fc" data-hits="1">  self.totalSupply = tostring(bint.__sub(bint(self.totalSupply), quantity))</span>
  -- Send notice
<span class="fc" data-hits="1">  return self.burnNotice(quantity, msg)</span>
end

-- @dev Internal function to transfer a quantity of tokens
-- @param recipient The address that will send the token
-- @param from The address that will receive the token
-- @param quantity Quantity of the token to be burned
-- @param cast Cast to silence the transfer notice
-- @param msg The message (used for x-tag forwarding and reporting)
<span class="fc" data-hits="2">function TokenMethods:transfer(from, recipient, quantity, cast, msg)</span>
<span class="fc" data-hits="2">  if not self.balances[from] then self.balances[from] = &quot;0&quot; end</span>
<span class="fc" data-hits="2">  if not self.balances[recipient] then self.balances[recipient] = &quot;0&quot; end</span>

<span class="fc" data-hits="2">  local qty = bint(quantity)</span>
<span class="fc" data-hits="2">  local balance = bint(self.balances[from])</span>

<span class="fc" data-hits="2">  if bint.__le(qty, balance) then</span>
<span class="fc" data-hits="1">    self.balances[from] = tostring(bint.__sub(balance, qty))</span>
<span class="fc" data-hits="1">    self.balances[recipient] = tostring(bint.__add(self.balances[recipient], qty))</span>

    -- Only send the notifications to the Sender and Recipient
    -- if the Cast tag is not set on the Transfer message
<span class="fc" data-hits="1">    if not cast then</span>
      -- Debit-Notice message template, that is sent to the Sender of the transfer
<span class="fc" data-hits="1">      local debitNotice = {</span>
<span class="fc" data-hits="1">        Target = from,</span>
<span class="fc" data-hits="1">        Action = &#39;Debit-Notice&#39;,</span>
<span class="fc" data-hits="1">        Recipient = recipient,</span>
<span class="fc" data-hits="1">        Quantity = quantity,</span>
<span class="fc" data-hits="1">        Data = Colors.gray ..</span>
<span class="fc" data-hits="1">            &quot;You transferred &quot; ..</span>
<span class="fc" data-hits="1">            Colors.blue .. quantity .. Colors.gray .. &quot; to &quot; .. Colors.green .. recipient .. Colors.reset</span>
      }
      -- Credit-Notice message template, that is sent to the Recipient of the transfer
<span class="fc" data-hits="1">      local creditNotice = {</span>
<span class="fc" data-hits="1">        Target = recipient,</span>
<span class="fc" data-hits="1">        Action = &#39;Credit-Notice&#39;,</span>
<span class="fc" data-hits="1">        Sender = from,</span>
<span class="fc" data-hits="1">        Quantity = quantity,</span>
<span class="fc" data-hits="1">        Data = Colors.gray ..</span>
<span class="fc" data-hits="1">            &quot;You received &quot; ..</span>
<span class="fc" data-hits="1">            Colors.blue .. quantity .. Colors.gray .. &quot; from &quot; .. Colors.green .. from .. Colors.reset</span>
      }

      -- Add forwarded tags to the credit and debit notice messages
<span class="fc" data-hits="5">      for tagName, tagValue in pairs(msg.Tags) do</span>
        -- Tags beginning with &quot;X-&quot; are forwarded
<span class="fc" data-hits="4">        if string.sub(tagName, 1, 2) == &quot;X-&quot; then</span>
<span class="fc" data-hits="1">          debitNotice[tagName] = tagValue</span>
<span class="fc" data-hits="1">          creditNotice[tagName] = tagValue</span>
        end
      end

      -- Send Debit-Notice and Credit-Notice
<span class="fc" data-hits="1">      return self.transferNotices(debitNotice, creditNotice, msg)</span>
    end
  else
<span class="fc" data-hits="1">    return self.transferErrorNotice(msg)</span>
  end
end

<span class="fc" data-hits="2">return Token</span>
</pre>
      </div>

      <div class="hidden file success-high" id="src-modules-tokennotices">
         <h2 class="title">
            src/modules/tokenNotices.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 100.00%"></span>
                  <span><strong>100.00%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>21</strong> Hits</span>
               <span class="miss"><strong>0</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums"><span class="fc" data-hits="3">local ao = require(&#39;.ao&#39;)</span>

<span class="fc" data-hits="3">local TokenNotices = {}</span>

<span class="fc" data-hits="3">function TokenNotices.mintNotice(recipient, quantity, msg)</span>
<span class="fc" data-hits="8">  return msg.reply({</span>
<span class="fc" data-hits="4">    Recipient = recipient,</span>
<span class="fc" data-hits="4">    Quantity = tostring(quantity),</span>
<span class="fc" data-hits="4">    Action = &#39;Mint-Notice&#39;,</span>
<span class="fc" data-hits="4">    Data = Colors.gray .. &quot;Successfully minted &quot; .. Colors.blue .. tostring(quantity) .. Colors.reset</span>
  })
end

<span class="fc" data-hits="3">function TokenNotices.burnNotice(quantity, msg)</span>
<span class="fc" data-hits="4">  return msg.reply({</span>
<span class="fc" data-hits="2">    Quantity = tostring(quantity),</span>
<span class="fc" data-hits="2">    Action = &#39;Burn-Notice&#39;,</span>
<span class="fc" data-hits="2">    Data = Colors.gray .. &quot;Successfully burned &quot; .. Colors.blue .. tostring(quantity) .. Colors.reset</span>
  })
end

<span class="fc" data-hits="3">function TokenNotices.transferNotices(debitNotice, creditNotice, msg)</span>
<span class="fc" data-hits="2">  return { msg.reply(debitNotice), ao.send(creditNotice) }</span>
end

<span class="fc" data-hits="3">function TokenNotices.transferErrorNotice(msg)</span>
<span class="fc" data-hits="4">  return msg.reply({</span>
<span class="fc" data-hits="2">    Action = &#39;Transfer-Error&#39;,</span>
<span class="fc" data-hits="2">    [&#39;Message-Id&#39;] = msg.Id,</span>
<span class="fc" data-hits="2">    Error = &#39;Insufficient Balance!&#39;</span>
  })
end

<span class="fc" data-hits="3">return TokenNotices</span>
</pre>
      </div>

      <div class="hidden file success-high" id="src-modules-tokenvalidation">
         <h2 class="title">
            src/modules/tokenValidation.lua
            <span class="stats">
               <span class="cov">
                  <span class="bg" style="width: 100.00%"></span>
                  <span><strong>100.00%</strong> Coverage</span>
               </span>
               <span class="hits"><strong>10</strong> Hits</span>
               <span class="miss"><strong>0</strong> Missed</span>
            </span>
         </h2>
         <pre class="prettyprint lang-lua linenums"><span class="fc" data-hits="1">local sharedUtils = require(&#39;modules.sharedUtils&#39;)</span>

<span class="fc" data-hits="1">local tokenValidation = {}</span>

<span class="fc" data-hits="1">function tokenValidation.transfer(msg)</span>
<span class="fc" data-hits="8">  assert(type(msg.Tags.Recipient) == &#39;string&#39;, &#39;Recipient is required!&#39;)</span>
<span class="fc" data-hits="7">  assert(sharedUtils.isValidArweaveAddress(msg.Tags.Recipient), &#39;Recipient must be a valid Arweave address!&#39;)</span>
<span class="fc" data-hits="6">  assert(type(msg.Tags.Quantity) == &#39;string&#39;, &#39;Quantity is required!&#39;)</span>
<span class="fc" data-hits="5">  assert(tonumber(msg.Tags.Quantity), &#39;Quantity must be a number!&#39;)</span>
<span class="fc" data-hits="4">  assert(tonumber(msg.Tags.Quantity) &gt; 0, &#39;Quantity must be greater than zero!&#39;)</span>
<span class="fc" data-hits="2">  assert(tonumber(msg.Tags.Quantity) % 1 == 0, &#39;Quantity must be an integer!&#39;)</span>
end

<span class="fc" data-hits="1">return tokenValidation</span>
</pre>
      </div>

   </main>
   <footer>
        Code coverage generated by <a href="https://lunarmodules.github.io/luacov/" target="_blank">LuaCov</a> at 2024-12-18 16:45:38
   </footer>

   <script type="text/javascript">
      !function(){/*
      
       Copyright (C) 2006 Google Inc.
      
       Licensed under the Apache License, Version 2.0 (the "License");
       you may not use this file except in compliance with the License.
       You may obtain a copy of the License at
      
            http://www.apache.org/licenses/LICENSE-2.0
      
       Unless required by applicable law or agreed to in writing, software
       distributed under the License is distributed on an "AS IS" BASIS,
       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       See the License for the specific language governing permissions and
       limitations under the License.
      */
      "undefined"!==typeof window&&(window.PR_SHOULD_USE_CONTINUATION=!0);
      (function(){function T(a){function d(e){var a=e.charCodeAt(0);if(92!==a)return a;var c=e.charAt(1);return(a=w[c])?a:"0"<=c&&"7">=c?parseInt(e.substring(1),8):"u"===c||"x"===c?parseInt(e.substring(2),16):e.charCodeAt(1)}function f(e){if(32>e)return(16>e?"\\x0":"\\x")+e.toString(16);e=String.fromCharCode(e);return"\\"===e||"-"===e||"]"===e||"^"===e?"\\"+e:e}function c(e){var c=e.substring(1,e.length-1).match(RegExp("\\\\u[0-9A-Fa-f]{4}|\\\\x[0-9A-Fa-f]{2}|\\\\[0-3][0-7]{0,2}|\\\\[0-7]{1,2}|\\\\[\\s\\S]|-|[^-\\\\]","g"));
      e=[];var a="^"===c[0],b=["["];a&&b.push("^");for(var a=a?1:0,g=c.length;a<g;++a){var h=c[a];if(/\\[bdsw]/i.test(h))b.push(h);else{var h=d(h),k;a+2<g&&"-"===c[a+1]?(k=d(c[a+2]),a+=2):k=h;e.push([h,k]);65>k||122<h||(65>k||90<h||e.push([Math.max(65,h)|32,Math.min(k,90)|32]),97>k||122<h||e.push([Math.max(97,h)&-33,Math.min(k,122)&-33]))}}e.sort(function(e,a){return e[0]-a[0]||a[1]-e[1]});c=[];g=[];for(a=0;a<e.length;++a)h=e[a],h[0]<=g[1]+1?g[1]=Math.max(g[1],h[1]):c.push(g=h);for(a=0;a<c.length;++a)h=
      c[a],b.push(f(h[0])),h[1]>h[0]&&(h[1]+1>h[0]&&b.push("-"),b.push(f(h[1])));b.push("]");return b.join("")}function m(e){for(var a=e.source.match(RegExp("(?:\\[(?:[^\\x5C\\x5D]|\\\\[\\s\\S])*\\]|\\\\u[A-Fa-f0-9]{4}|\\\\x[A-Fa-f0-9]{2}|\\\\[0-9]+|\\\\[^ux0-9]|\\(\\?[:!=]|[\\(\\)\\^]|[^\\x5B\\x5C\\(\\)\\^]+)","g")),b=a.length,d=[],g=0,h=0;g<b;++g){var k=a[g];"("===k?++h:"\\"===k.charAt(0)&&(k=+k.substring(1))&&(k<=h?d[k]=-1:a[g]=f(k))}for(g=1;g<d.length;++g)-1===d[g]&&(d[g]=++E);for(h=g=0;g<b;++g)k=a[g],
      "("===k?(++h,d[h]||(a[g]="(?:")):"\\"===k.charAt(0)&&(k=+k.substring(1))&&k<=h&&(a[g]="\\"+d[k]);for(g=0;g<b;++g)"^"===a[g]&&"^"!==a[g+1]&&(a[g]="");if(e.ignoreCase&&q)for(g=0;g<b;++g)k=a[g],e=k.charAt(0),2<=k.length&&"["===e?a[g]=c(k):"\\"!==e&&(a[g]=k.replace(/[a-zA-Z]/g,function(a){a=a.charCodeAt(0);return"["+String.fromCharCode(a&-33,a|32)+"]"}));return a.join("")}for(var E=0,q=!1,l=!1,n=0,b=a.length;n<b;++n){var p=a[n];if(p.ignoreCase)l=!0;else if(/[a-z]/i.test(p.source.replace(/\\u[0-9a-f]{4}|\\x[0-9a-f]{2}|\\[^ux]/gi,
      ""))){q=!0;l=!1;break}}for(var w={b:8,t:9,n:10,v:11,f:12,r:13},r=[],n=0,b=a.length;n<b;++n){p=a[n];if(p.global||p.multiline)throw Error(""+p);r.push("(?:"+m(p)+")")}return new RegExp(r.join("|"),l?"gi":"g")}function U(a,d){function f(a){var b=a.nodeType;if(1==b){if(!c.test(a.className)){for(b=a.firstChild;b;b=b.nextSibling)f(b);b=a.nodeName.toLowerCase();if("br"===b||"li"===b)m[l]="\n",q[l<<1]=E++,q[l++<<1|1]=a}}else if(3==b||4==b)b=a.nodeValue,b.length&&(b=d?b.replace(/\r\n?/g,"\n"):b.replace(/[ \t\r\n]+/g,
      " "),m[l]=b,q[l<<1]=E,E+=b.length,q[l++<<1|1]=a)}var c=/(?:^|\s)nocode(?:\s|$)/,m=[],E=0,q=[],l=0;f(a);return{a:m.join("").replace(/\n$/,""),c:q}}function J(a,d,f,c,m){f&&(a={h:a,l:1,j:null,m:null,a:f,c:null,i:d,g:null},c(a),m.push.apply(m,a.g))}function V(a){for(var d=void 0,f=a.firstChild;f;f=f.nextSibling)var c=f.nodeType,d=1===c?d?a:f:3===c?W.test(f.nodeValue)?a:d:d;return d===a?void 0:d}function G(a,d){function f(a){for(var l=a.i,n=a.h,b=[l,"pln"],p=0,q=a.a.match(m)||[],r={},e=0,t=q.length;e<
      t;++e){var z=q[e],v=r[z],g=void 0,h;if("string"===typeof v)h=!1;else{var k=c[z.charAt(0)];if(k)g=z.match(k[1]),v=k[0];else{for(h=0;h<E;++h)if(k=d[h],g=z.match(k[1])){v=k[0];break}g||(v="pln")}!(h=5<=v.length&&"lang-"===v.substring(0,5))||g&&"string"===typeof g[1]||(h=!1,v="src");h||(r[z]=v)}k=p;p+=z.length;if(h){h=g[1];var A=z.indexOf(h),C=A+h.length;g[2]&&(C=z.length-g[2].length,A=C-h.length);v=v.substring(5);J(n,l+k,z.substring(0,A),f,b);J(n,l+k+A,h,K(v,h),b);J(n,l+k+C,z.substring(C),f,b)}else b.push(l+
      k,v)}a.g=b}var c={},m;(function(){for(var f=a.concat(d),l=[],n={},b=0,p=f.length;b<p;++b){var w=f[b],r=w[3];if(r)for(var e=r.length;0<=--e;)c[r.charAt(e)]=w;w=w[1];r=""+w;n.hasOwnProperty(r)||(l.push(w),n[r]=null)}l.push(/[\0-\uffff]/);m=T(l)})();var E=d.length;return f}function x(a){var d=[],f=[];a.tripleQuotedStrings?d.push(["str",/^(?:\'\'\'(?:[^\'\\]|\\[\s\S]|\'{1,2}(?=[^\']))*(?:\'\'\'|$)|\"\"\"(?:[^\"\\]|\\[\s\S]|\"{1,2}(?=[^\"]))*(?:\"\"\"|$)|\'(?:[^\\\']|\\[\s\S])*(?:\'|$)|\"(?:[^\\\"]|\\[\s\S])*(?:\"|$))/,
      null,"'\""]):a.multiLineStrings?d.push(["str",/^(?:\'(?:[^\\\']|\\[\s\S])*(?:\'|$)|\"(?:[^\\\"]|\\[\s\S])*(?:\"|$)|\`(?:[^\\\`]|\\[\s\S])*(?:\`|$))/,null,"'\"`"]):d.push(["str",/^(?:\'(?:[^\\\'\r\n]|\\.)*(?:\'|$)|\"(?:[^\\\"\r\n]|\\.)*(?:\"|$))/,null,"\"'"]);a.verbatimStrings&&f.push(["str",/^@\"(?:[^\"]|\"\")*(?:\"|$)/,null]);var c=a.hashComments;c&&(a.cStyleComments?(1<c?d.push(["com",/^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/,null,"#"]):d.push(["com",/^#(?:(?:define|e(?:l|nd)if|else|error|ifn?def|include|line|pragma|undef|warning)\b|[^\r\n]*)/,
      null,"#"]),f.push(["str",/^<(?:(?:(?:\.\.\/)*|\/?)(?:[\w-]+(?:\/[\w-]+)+)?[\w-]+\.h(?:h|pp|\+\+)?|[a-z]\w*)>/,null])):d.push(["com",/^#[^\r\n]*/,null,"#"]));a.cStyleComments&&(f.push(["com",/^\/\/[^\r\n]*/,null]),f.push(["com",/^\/\*[\s\S]*?(?:\*\/|$)/,null]));if(c=a.regexLiterals){var m=(c=1<c?"":"\n\r")?".":"[\\S\\s]";f.push(["lang-regex",RegExp("^(?:^^\\.?|[+-]|[!=]=?=?|\\#|%=?|&&?=?|\\(|\\*=?|[+\\-]=|->|\\/=?|::?|<<?=?|>>?>?=?|,|;|\\?|@|\\[|~|{|\\^\\^?=?|\\|\\|?=?|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\s*("+
      ("/(?=[^/*"+c+"])(?:[^/\\x5B\\x5C"+c+"]|\\x5C"+m+"|\\x5B(?:[^\\x5C\\x5D"+c+"]|\\x5C"+m+")*(?:\\x5D|$))+/")+")")])}(c=a.types)&&f.push(["typ",c]);c=(""+a.keywords).replace(/^ | $/g,"");c.length&&f.push(["kwd",new RegExp("^(?:"+c.replace(/[\s,]+/g,"|")+")\\b"),null]);d.push(["pln",/^\s+/,null," \r\n\t\u00a0"]);c="^.[^\\s\\w.$@'\"`/\\\\]*";a.regexLiterals&&(c+="(?!s*/)");f.push(["lit",/^@[a-z_$][a-z_$@0-9]*/i,null],["typ",/^(?:[@_]?[A-Z]+[a-z][A-Za-z_$@0-9]*|\w+_t\b)/,null],["pln",/^[a-z_$][a-z_$@0-9]*/i,
      null],["lit",/^(?:0x[a-f0-9]+|(?:\d(?:_\d+)*\d*(?:\.\d*)?|\.\d\+)(?:e[+\-]?\d+)?)[a-z]*/i,null,"0123456789"],["pln",/^\\[\s\S]?/,null],["pun",new RegExp(c),null]);return G(d,f)}function L(a,d,f){function c(a){var b=a.nodeType;if(1==b&&!t.test(a.className))if("br"===a.nodeName.toLowerCase())m(a),a.parentNode&&a.parentNode.removeChild(a);else for(a=a.firstChild;a;a=a.nextSibling)c(a);else if((3==b||4==b)&&f){var e=a.nodeValue,d=e.match(q);d&&(b=e.substring(0,d.index),a.nodeValue=b,(e=e.substring(d.index+
      d[0].length))&&a.parentNode.insertBefore(l.createTextNode(e),a.nextSibling),m(a),b||a.parentNode.removeChild(a))}}function m(a){function c(a,b){var e=b?a.cloneNode(!1):a,k=a.parentNode;if(k){var k=c(k,1),d=a.nextSibling;k.appendChild(e);for(var f=d;f;f=d)d=f.nextSibling,k.appendChild(f)}return e}for(;!a.nextSibling;)if(a=a.parentNode,!a)return;a=c(a.nextSibling,0);for(var e;(e=a.parentNode)&&1===e.nodeType;)a=e;b.push(a)}for(var t=/(?:^|\s)nocode(?:\s|$)/,q=/\r\n?|\n/,l=a.ownerDocument,n=l.createElement("li");a.firstChild;)n.appendChild(a.firstChild);
      for(var b=[n],p=0;p<b.length;++p)c(b[p]);d===(d|0)&&b[0].setAttribute("value",d);var w=l.createElement("ol");w.className="linenums";d=Math.max(0,d-1|0)||0;for(var p=0,r=b.length;p<r;++p)n=b[p],n.className="L"+(p+d)%10,n.firstChild||n.appendChild(l.createTextNode("\u00a0")),w.appendChild(n);a.appendChild(w)}function t(a,d){for(var f=d.length;0<=--f;){var c=d[f];I.hasOwnProperty(c)?D.console&&console.warn("cannot override language handler %s",c):I[c]=a}}function K(a,d){a&&I.hasOwnProperty(a)||(a=/^\s*</.test(d)?
      "default-markup":"default-code");return I[a]}function M(a){var d=a.j;try{var f=U(a.h,a.l),c=f.a;a.a=c;a.c=f.c;a.i=0;K(d,c)(a);var m=/\bMSIE\s(\d+)/.exec(navigator.userAgent),m=m&&8>=+m[1],d=/\n/g,t=a.a,q=t.length,f=0,l=a.c,n=l.length,c=0,b=a.g,p=b.length,w=0;b[p]=q;var r,e;for(e=r=0;e<p;)b[e]!==b[e+2]?(b[r++]=b[e++],b[r++]=b[e++]):e+=2;p=r;for(e=r=0;e<p;){for(var x=b[e],z=b[e+1],v=e+2;v+2<=p&&b[v+1]===z;)v+=2;b[r++]=x;b[r++]=z;e=v}b.length=r;var g=a.h;a="";g&&(a=g.style.display,g.style.display="none");
      try{for(;c<n;){var h=l[c+2]||q,k=b[w+2]||q,v=Math.min(h,k),A=l[c+1],C;if(1!==A.nodeType&&(C=t.substring(f,v))){m&&(C=C.replace(d,"\r"));A.nodeValue=C;var N=A.ownerDocument,u=N.createElement("span");u.className=b[w+1];var B=A.parentNode;B.replaceChild(u,A);u.appendChild(A);f<h&&(l[c+1]=A=N.createTextNode(t.substring(v,h)),B.insertBefore(A,u.nextSibling))}f=v;f>=h&&(c+=2);f>=k&&(w+=2)}}finally{g&&(g.style.display=a)}}catch(y){D.console&&console.log(y&&y.stack||y)}}var D="undefined"!==typeof window?
      window:{},B=["break,continue,do,else,for,if,return,while"],F=[[B,"auto,case,char,const,default,double,enum,extern,float,goto,inline,int,long,register,restrict,short,signed,sizeof,static,struct,switch,typedef,union,unsigned,void,volatile"],"catch,class,delete,false,import,new,operator,private,protected,public,this,throw,true,try,typeof"],H=[F,"alignas,alignof,align_union,asm,axiom,bool,concept,concept_map,const_cast,constexpr,decltype,delegate,dynamic_cast,explicit,export,friend,generic,late_check,mutable,namespace,noexcept,noreturn,nullptr,property,reinterpret_cast,static_assert,static_cast,template,typeid,typename,using,virtual,where"],
      O=[F,"abstract,assert,boolean,byte,extends,finally,final,implements,import,instanceof,interface,null,native,package,strictfp,super,synchronized,throws,transient"],P=[F,"abstract,add,alias,as,ascending,async,await,base,bool,by,byte,checked,decimal,delegate,descending,dynamic,event,finally,fixed,foreach,from,get,global,group,implicit,in,interface,internal,into,is,join,let,lock,null,object,out,override,orderby,params,partial,readonly,ref,remove,sbyte,sealed,select,set,stackalloc,string,select,uint,ulong,unchecked,unsafe,ushort,value,var,virtual,where,yield"],
      F=[F,"abstract,async,await,constructor,debugger,enum,eval,export,from,function,get,import,implements,instanceof,interface,let,null,of,set,undefined,var,with,yield,Infinity,NaN"],Q=[B,"and,as,assert,class,def,del,elif,except,exec,finally,from,global,import,in,is,lambda,nonlocal,not,or,pass,print,raise,try,with,yield,False,True,None"],R=[B,"alias,and,begin,case,class,def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,rescue,retry,self,super,then,true,undef,unless,until,when,yield,BEGIN,END"],
      B=[B,"case,done,elif,esac,eval,fi,function,in,local,set,then,until"],S=/^(DIR|FILE|array|vector|(de|priority_)?queue|(forward_)?list|stack|(const_)?(reverse_)?iterator|(unordered_)?(multi)?(set|map)|bitset|u?(int|float)\d*)\b/,W=/\S/,X=x({keywords:[H,P,O,F,"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END",Q,R,B],hashComments:!0,cStyleComments:!0,multiLineStrings:!0,regexLiterals:!0}),
      I={};t(X,["default-code"]);t(G([],[["pln",/^[^<?]+/],["dec",/^<!\w[^>]*(?:>|$)/],["com",/^<\!--[\s\S]*?(?:-\->|$)/],["lang-",/^<\?([\s\S]+?)(?:\?>|$)/],["lang-",/^<%([\s\S]+?)(?:%>|$)/],["pun",/^(?:<[%?]|[%?]>)/],["lang-",/^<xmp\b[^>]*>([\s\S]+?)<\/xmp\b[^>]*>/i],["lang-js",/^<script\b[^>]*>([\s\S]*?)(<\/script\b[^>]*>)/i],["lang-css",/^<style\b[^>]*>([\s\S]*?)(<\/style\b[^>]*>)/i],["lang-in.tag",/^(<\/?[a-z][^<>]*>)/i]]),"default-markup htm html mxml xhtml xml xsl".split(" "));t(G([["pln",/^[\s]+/,
      null," \t\r\n"],["atv",/^(?:\"[^\"]*\"?|\'[^\']*\'?)/,null,"\"'"]],[["tag",/^^<\/?[a-z](?:[\w.:-]*\w)?|\/?>$/i],["atn",/^(?!style[\s=]|on)[a-z](?:[\w:-]*\w)?/i],["lang-uq.val",/^=\s*([^>\'\"\s]*(?:[^>\'\"\s\/]|\/(?=\s)))/],["pun",/^[=<>\/]+/],["lang-js",/^on\w+\s*=\s*\"([^\"]+)\"/i],["lang-js",/^on\w+\s*=\s*\'([^\']+)\'/i],["lang-js",/^on\w+\s*=\s*([^\"\'>\s]+)/i],["lang-css",/^style\s*=\s*\"([^\"]+)\"/i],["lang-css",/^style\s*=\s*\'([^\']+)\'/i],["lang-css",/^style\s*=\s*([^\"\'>\s]+)/i]]),["in.tag"]);
      t(G([],[["atv",/^[\s\S]+/]]),["uq.val"]);t(x({keywords:H,hashComments:!0,cStyleComments:!0,types:S}),"c cc cpp cxx cyc m".split(" "));t(x({keywords:"null,true,false"}),["json"]);t(x({keywords:P,hashComments:!0,cStyleComments:!0,verbatimStrings:!0,types:S}),["cs"]);t(x({keywords:O,cStyleComments:!0}),["java"]);t(x({keywords:B,hashComments:!0,multiLineStrings:!0}),["bash","bsh","csh","sh"]);t(x({keywords:Q,hashComments:!0,multiLineStrings:!0,tripleQuotedStrings:!0}),["cv","py","python"]);t(x({keywords:"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END",
      hashComments:!0,multiLineStrings:!0,regexLiterals:2}),["perl","pl","pm"]);t(x({keywords:R,hashComments:!0,multiLineStrings:!0,regexLiterals:!0}),["rb","ruby"]);t(x({keywords:F,cStyleComments:!0,regexLiterals:!0}),["javascript","js","ts","typescript"]);t(x({keywords:"all,and,by,catch,class,else,extends,false,finally,for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,throw,true,try,unless,until,when,while,yes",hashComments:3,cStyleComments:!0,multilineStrings:!0,tripleQuotedStrings:!0,
      regexLiterals:!0}),["coffee"]);t(G([],[["str",/^[\s\S]+/]]),["regex"]);var Y=D.PR={createSimpleLexer:G,registerLangHandler:t,sourceDecorator:x,PR_ATTRIB_NAME:"atn",PR_ATTRIB_VALUE:"atv",PR_COMMENT:"com",PR_DECLARATION:"dec",PR_KEYWORD:"kwd",PR_LITERAL:"lit",PR_NOCODE:"nocode",PR_PLAIN:"pln",PR_PUNCTUATION:"pun",PR_SOURCE:"src",PR_STRING:"str",PR_TAG:"tag",PR_TYPE:"typ",prettyPrintOne:D.prettyPrintOne=function(a,d,f){f=f||!1;d=d||null;var c=document.createElement("div");c.innerHTML="<pre>"+a+"</pre>";
      c=c.firstChild;f&&L(c,f,!0);M({j:d,m:f,h:c,l:1,a:null,i:null,c:null,g:null});return c.innerHTML},prettyPrint:D.prettyPrint=function(a,d){function f(){for(var c=D.PR_SHOULD_USE_CONTINUATION?b.now()+250:Infinity;p<x.length&&b.now()<c;p++){for(var d=x[p],l=g,n=d;n=n.previousSibling;){var m=n.nodeType,u=(7===m||8===m)&&n.nodeValue;if(u?!/^\??prettify\b/.test(u):3!==m||/\S/.test(n.nodeValue))break;if(u){l={};u.replace(/\b(\w+)=([\w:.%+-]+)/g,function(a,b,c){l[b]=c});break}}n=d.className;if((l!==g||r.test(n))&&
      !e.test(n)){m=!1;for(u=d.parentNode;u;u=u.parentNode)if(v.test(u.tagName)&&u.className&&r.test(u.className)){m=!0;break}if(!m){d.className+=" prettyprinted";m=l.lang;if(!m){var m=n.match(w),q;!m&&(q=V(d))&&z.test(q.tagName)&&(m=q.className.match(w));m&&(m=m[1])}if(B.test(d.tagName))u=1;else var u=d.currentStyle,y=t.defaultView,u=(u=u?u.whiteSpace:y&&y.getComputedStyle?y.getComputedStyle(d,null).getPropertyValue("white-space"):0)&&"pre"===u.substring(0,3);y=l.linenums;(y="true"===y||+y)||(y=(y=n.match(/\blinenums\b(?::(\d+))?/))?
      y[1]&&y[1].length?+y[1]:!0:!1);y&&L(d,y,u);M({j:m,h:d,m:y,l:u,a:null,i:null,c:null,g:null})}}}p<x.length?D.setTimeout(f,250):"function"===typeof a&&a()}for(var c=d||document.body,t=c.ownerDocument||document,c=[c.getElementsByTagName("pre"),c.getElementsByTagName("code"),c.getElementsByTagName("xmp")],x=[],q=0;q<c.length;++q)for(var l=0,n=c[q].length;l<n;++l)x.push(c[q][l]);var c=null,b=Date;b.now||(b={now:function(){return+new Date}});var p=0,w=/\blang(?:uage)?-([\w.]+)(?!\S)/,r=/\bprettyprint\b/,
      e=/\bprettyprinted\b/,B=/pre|xmp/i,z=/^code$/i,v=/^(?:pre|code|xmp)$/i,g={};f()}},H=D.define;"function"===typeof H&&H.amd&&H("google-code-prettify",[],function(){return Y})})();}()
      
   </script>

   <script type="text/javascript">
      /*
      
       Copyright (C) 2008 Google Inc.
      
       Licensed under the Apache License, Version 2.0 (the "License");
       you may not use this file except in compliance with the License.
       You may obtain a copy of the License at
      
          http://www.apache.org/licenses/LICENSE-2.0
      
       Unless required by applicable law or agreed to in writing, software
       distributed under the License is distributed on an "AS IS" BASIS,
       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       See the License for the specific language governing permissions and
       limitations under the License.
      */
      PR.registerLangHandler(PR.createSimpleLexer([["pln",/^[\t\n\r \xA0]+/,null,"\t\n\r \u00a0"],["str",/^(?:\"(?:[^\"\\]|\\[\s\S])*(?:\"|$)|\'(?:[^\'\\]|\\[\s\S])*(?:\'|$))/,null,"\"'"]],[["com",/^--(?:\[(=*)\[[\s\S]*?(?:\]\1\]|$)|[^\r\n]*)/],["str",/^\[(=*)\[[\s\S]*?(?:\]\1\]|$)/],["kwd",/^(?:and|break|do|else|elseif|end|false|for|function|if|in|local|nil|not|or|repeat|return|then|true|until|while)\b/,null],["lit",/^[+-]?(?:0x[\da-f]+|(?:(?:\.\d+|\d+(?:\.\d*)?)(?:e[+\-]?\d+)?))/i],
      ["pln",/^[a-z_]\w*/i],["pun",/^[^\w\t\n\r \xA0][^\w\t\n\r \xA0\"\'\-\+=]*/]]),["lua"]);
      
   </script>

   <script type="text/javascript">
      function initialize() {
      
         const LOCAL_STORAGE_KEY = "luacov_report_visible_ids";
      
         let visibleIDs;
      
         if (localStorage) {
            visibleIDs = localStorage.getItem(LOCAL_STORAGE_KEY);
         }
         if (!visibleIDs) {
            visibleIDs = []
         } else {
            visibleIDs = JSON.parse(visibleIDs);
         }
      
         function save() {
            if (localStorage) {
               localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(visibleIDs));
            }
         }
      
         function show(id) {
            let classList = document.getElementById(id).classList;
            if (classList.contains('hidden')) {
               classList.remove("hidden");
               if (visibleIDs.indexOf(id) < 0) {
                  visibleIDs.push(id);
                  save();
               }
            }
         }
      
         function hide(id) {
            let classList = document.getElementById(id).classList;
            if (!classList.contains('hidden')) {
               classList.add("hidden");
               if (visibleIDs.indexOf(id) >= 0) {
                  visibleIDs.splice(visibleIDs.indexOf(id), 1);
                  save();
               }
            }
         }
      
         const fileHeaders = Array.prototype.slice.call(document.getElementsByTagName("h2"));
         fileHeaders.forEach(function (h2) {
            let div = h2.parentElement;
            let id = div.getAttribute("id");
            h2.onclick = function () {
               if (div.classList.contains('hidden')) {
                  show(id)
               } else {
                  hide(id)
               }
            }
         });
      
         let changed;
         visibleIDs.forEach((id) => {
            if (!document.getElementById(id)) {
               changed = true;
               visibleIDs.splice(visibleIDs.indexOf(id), 1);
            } else {
               show(id);
            }
         });
         if (changed) {
            save();
         }
      
         prettyPrint()
      }
      
   </script>

</body>
</html>
